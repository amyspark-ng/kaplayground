{
  "version": 3,
  "sources": ["../src/kaboom.ts", "../src/math.ts", "../src/utils.ts", "../src/gamepad.json", "../src/app.ts", "../src/gfx.ts", "../src/assets.ts", "../src/constants.ts", "../src/easings.ts", "../src/texPacker.ts", "../src/components/draw/circle.ts", "../src/components/draw/drawon.ts", "../src/components/draw/fadeIn.ts", "../src/components/draw/mask.ts", "../src/components/draw/opacity.ts", "../src/components/draw/outline.ts", "../src/components/draw/polygon.ts", "../src/components/draw/raycast.ts", "../src/components/draw/rect.ts", "../src/components/draw/shader.ts", "../src/components/draw/sprite.ts", "../src/components/draw/text.ts", "../src/components/draw/uvquad.ts", "../src/components/level/agent.ts", "../src/types.ts", "../src/components/level/tile.ts", "../src/components/misc/health.ts", "../src/components/misc/lifespan.ts", "../src/components/misc/state.ts", "../src/components/misc/stay.ts", "../src/components/misc/timer.ts", "../src/components/physics/area.ts", "../src/components/physics/body.ts", "../src/components/physics/doubleJump.ts", "../src/components/transform/anchor.ts", "../src/components/transform/fixed.ts", "../src/components/transform/follow.ts", "../src/components/transform/move.ts", "../src/components/transform/offscreen.ts", "../src/components/transform/pos.ts", "../src/components/transform/rotate.ts", "../src/components/transform/scale.ts", "../src/components/transform/z.ts"],
  "sourcesContent": ["const VERSION = \"3001.0.0\";\n\nimport initApp from \"./app\";\nimport initGfx, { BatchRenderer, FrameBuffer, Shader, Texture } from \"./gfx\";\n\nimport {\n    Asset,\n    AssetBucket,\n    fetchArrayBuffer,\n    fetchJSON,\n    fetchText,\n    loadImg,\n} from \"./assets\";\n\nimport {\n    ASCII_CHARS,\n    BG_GRID_SIZE,\n    COMP_DESC,\n    COMP_EVENTS,\n    DBG_FONT,\n    DEF_ANCHOR,\n    DEF_FONT,\n    DEF_FONT_FILTER,\n    DEF_FRAG,\n    DEF_HASH_GRID_SIZE,\n    DEF_TEXT_CACHE_SIZE,\n    DEF_VERT,\n    FONT_ATLAS_HEIGHT,\n    FONT_ATLAS_WIDTH,\n    FRAG_TEMPLATE,\n    LOG_MAX,\n    LOG_TIME,\n    MAX_BATCHED_INDICES,\n    MAX_BATCHED_VERTS,\n    MAX_TEXT_CACHE_SIZE,\n    SPRITE_ATLAS_HEIGHT,\n    SPRITE_ATLAS_WIDTH,\n    TEXT_STYLE_RE,\n    UV_PAD,\n    VERT_TEMPLATE,\n    VERTEX_FORMAT,\n} from \"./constants\";\n\nimport {\n    chance,\n    choose,\n    chooseMultiple,\n    Circle,\n    clamp,\n    Color,\n    deg2rad,\n    Ellipse,\n    evaluateBezier,\n    hsl2rgb,\n    isConvex,\n    lerp,\n    Line,\n    map,\n    mapc,\n    Mat4,\n    Polygon,\n    Quad,\n    quad,\n    rad2deg,\n    rand,\n    randi,\n    randSeed,\n    raycastGrid,\n    type RaycastHit as BaseRaycastHit,\n    Rect,\n    rgb,\n    RNG,\n    sat,\n    shuffle,\n    testCirclePolygon,\n    testLineCircle,\n    testLineLine,\n    testLinePoint,\n    testRectLine,\n    testRectPoint,\n    testRectRect,\n    triangulate,\n    Vec2,\n    vec2,\n    wave,\n} from \"./math\";\n\nimport easings from \"./easings\";\nimport TexPacker from \"./texPacker\";\n\nimport {\n    BinaryHeap,\n    dataURLToArrayBuffer,\n    download,\n    downloadBlob,\n    downloadJSON,\n    downloadText,\n    Event,\n    EventController,\n    EventHandler,\n    getErrorMessage,\n    getFileName,\n    isDataURL,\n    overload2,\n    Registry,\n    runes,\n    uid,\n} from \"./utils\";\n\nimport type {\n    Anchor,\n    AreaComp,\n    AsepriteData,\n    AudioPlay,\n    AudioPlayOpt,\n    BitmapFontData,\n    BoomOpt,\n    CharTransform,\n    ColorComp,\n    Comp,\n    CompList,\n    Debug,\n    DrawBezierOpt,\n    DrawCircleOpt,\n    DrawCurveOpt,\n    DrawEllipseOpt,\n    DrawLineOpt,\n    DrawLinesOpt,\n    DrawPolygonOpt,\n    DrawRectOpt,\n    DrawSpriteOpt,\n    DrawTextOpt,\n    DrawTextureOpt,\n    DrawTriangleOpt,\n    DrawUVQuadOpt,\n    FixedComp,\n    FormattedChar,\n    FormattedText,\n    GameObj,\n    GetOpt,\n    GfxFont,\n    ImageSource,\n    InternalCtx,\n    KaboomCtx,\n    KaboomOpt,\n    KaboomPlugin,\n    Key,\n    LevelComp,\n    LevelOpt,\n    LoadBitmapFontOpt,\n    LoadFontOpt,\n    LoadSpriteOpt,\n    LoadSpriteSrc,\n    MaskComp,\n    MouseButton,\n    MusicData,\n    NineSlice,\n    Outline,\n    PathFindOpt,\n    PeditFile,\n    PosComp,\n    Recording,\n    RenderProps,\n    RotateComp,\n    ScaleComp,\n    SceneDef,\n    SceneName,\n    ShaderData,\n    SpriteAnims,\n    SpriteAtlasData,\n    Tag,\n    TexFilter,\n    TextAlign,\n    Uniform,\n    Vec2Args,\n    Vertex,\n} from \"@/types\";\n\nimport {\n    agent,\n    anchor,\n    area,\n    body,\n    circle,\n    doubleJump,\n    drawon,\n    fadeIn,\n    fixed,\n    follow,\n    health,\n    lifespan,\n    mask,\n    move,\n    offscreen,\n    opacity,\n    outline,\n    polygon,\n    pos,\n    raycast,\n    rect,\n    rotate,\n    scale,\n    shader,\n    sprite,\n    state,\n    stay,\n    text,\n    tile,\n    timer,\n    uvquad,\n    z,\n} from \"@/components\";\n\nimport beanSpriteSrc from \"@/assets/bean.png\";\nimport boomSpriteSrc from \"@/assets/boom.png\";\nimport burpSoundSrc from \"@/assets/burp.mp3\";\nimport kaSpriteSrc from \"@/assets/ka.png\";\n\n// convert anchor string to a vec2 offset\nexport function anchorPt(orig: Anchor | Vec2): Vec2 {\n    switch (orig) {\n        case \"topleft\":\n            return new Vec2(-1, -1);\n        case \"top\":\n            return new Vec2(0, -1);\n        case \"topright\":\n            return new Vec2(1, -1);\n        case \"left\":\n            return new Vec2(-1, 0);\n        case \"center\":\n            return new Vec2(0, 0);\n        case \"right\":\n            return new Vec2(1, 0);\n        case \"botleft\":\n            return new Vec2(-1, 1);\n        case \"bot\":\n            return new Vec2(0, 1);\n        case \"botright\":\n            return new Vec2(1, 1);\n        default:\n            return orig;\n    }\n}\n\nfunction alignPt(align: TextAlign): number {\n    switch (align) {\n        case \"left\":\n            return 0;\n        case \"center\":\n            return 0.5;\n        case \"right\":\n            return 1;\n        default:\n            return 0;\n    }\n}\n\nfunction createEmptyAudioBuffer(ctx: AudioContext) {\n    return ctx.createBuffer(1, 1, 44100);\n}\n\nlet ctx: KaboomCtx;\n\n// TODO: A better way to detect KaboomCtx\nexport const isKaboomCtx = (obj: any): obj is KaboomCtx => {\n    return obj && obj[\"loadAseprite\"];\n};\n\nexport const getKaboomContext = (fallBack?: any): KaboomCtx => {\n    if (!ctx) {\n        throw new Error(\n            \"You are trying to access to Kaboom Context before their initialization.\",\n        );\n    }\n\n    if (isKaboomCtx(fallBack)) {\n        return fallBack;\n    }\n\n    return ctx;\n};\n\nexport const getInternalContext = (kaboom: KaboomCtx): InternalCtx => {\n    return kaboom._k;\n};\n\n// only exports one kaboom() which contains all the state\nexport default (gopt: KaboomOpt = {}): KaboomCtx => {\n    const root = gopt.root ?? document.body;\n\n    // if root is not defined (which falls back to <body>) we assume user is using kaboom on a clean page, and modify <body> to better fit a full screen canvas\n    if (root === document.body) {\n        document.body.style[\"width\"] = \"100%\";\n        document.body.style[\"height\"] = \"100%\";\n        document.body.style[\"margin\"] = \"0px\";\n        document.documentElement.style[\"width\"] = \"100%\";\n        document.documentElement.style[\"height\"] = \"100%\";\n    }\n\n    // create a <canvas> if user didn't provide one\n    const canvas = gopt.canvas\n        ?? root.appendChild(document.createElement(\"canvas\"));\n\n    // global pixel scale\n    const gscale = gopt.scale ?? 1;\n    const fixedSize = gopt.width && gopt.height && !gopt.stretch\n        && !gopt.letterbox;\n\n    // adjust canvas size according to user size / viewport settings\n    if (fixedSize) {\n        canvas.width = gopt.width * gscale;\n        canvas.height = gopt.height * gscale;\n    } else {\n        canvas.width = canvas.parentElement.offsetWidth;\n        canvas.height = canvas.parentElement.offsetHeight;\n    }\n\n    // canvas css styles\n    const styles = [\n        \"outline: none\",\n        \"cursor: default\",\n    ];\n\n    if (fixedSize) {\n        const cw = canvas.width;\n        const ch = canvas.height;\n        styles.push(`width: ${cw}px`);\n        styles.push(`height: ${ch}px`);\n    } else {\n        styles.push(\"width: 100%\");\n        styles.push(\"height: 100%\");\n    }\n\n    if (gopt.crisp) {\n        // chrome only supports pixelated and firefox only supports crisp-edges\n        styles.push(\"image-rendering: pixelated\");\n        styles.push(\"image-rendering: crisp-edges\");\n    }\n\n    canvas.style.cssText = styles.join(\";\");\n\n    const pixelDensity = gopt.pixelDensity || window.devicePixelRatio;\n\n    canvas.width *= pixelDensity;\n    canvas.height *= pixelDensity;\n    // make canvas focusable\n    canvas.tabIndex = 0;\n\n    const fontCacheCanvas = document.createElement(\"canvas\");\n    fontCacheCanvas.width = MAX_TEXT_CACHE_SIZE;\n    fontCacheCanvas.height = MAX_TEXT_CACHE_SIZE;\n    const fontCacheC2d = fontCacheCanvas.getContext(\"2d\", {\n        willReadFrequently: true,\n    });\n\n    const app = initApp({\n        canvas: canvas,\n        touchToMouse: gopt.touchToMouse,\n        gamepads: gopt.gamepads,\n        pixelDensity: gopt.pixelDensity,\n        maxFPS: gopt.maxFPS,\n    });\n\n    const gc: Array<() => void> = [];\n\n    const gl = app.canvas\n        .getContext(\"webgl\", {\n            antialias: true,\n            depth: true,\n            stencil: true,\n            alpha: true,\n            preserveDrawingBuffer: true,\n        });\n\n    const ggl = initGfx(gl, {\n        texFilter: gopt.texFilter,\n    });\n\n    const gfx = (() => {\n        const defShader = makeShader(DEF_VERT, DEF_FRAG);\n\n        // a 1x1 white texture to draw raw shapes like rectangles and polygons\n        // we use a texture for those so we can use only 1 pipeline for drawing sprites + shapes\n        const emptyTex = Texture.fromImage(\n            ggl,\n            new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1),\n        );\n\n        const frameBuffer = (gopt.width && gopt.height)\n            ? new FrameBuffer(\n                ggl,\n                gopt.width * pixelDensity * gscale,\n                gopt.height * pixelDensity * gscale,\n            )\n            : new FrameBuffer(\n                ggl,\n                gl.drawingBufferWidth,\n                gl.drawingBufferHeight,\n            );\n\n        let bgColor: null | Color = null;\n        let bgAlpha = 1;\n\n        if (gopt.background) {\n            bgColor = rgb(gopt.background);\n            bgAlpha = Array.isArray(gopt.background)\n                ? gopt.background[3]\n                : 1;\n            gl.clearColor(\n                bgColor.r / 255,\n                bgColor.g / 255,\n                bgColor.b / 255,\n                bgAlpha ?? 1,\n            );\n        }\n\n        gl.enable(gl.BLEND);\n        gl.blendFuncSeparate(\n            gl.SRC_ALPHA,\n            gl.ONE_MINUS_SRC_ALPHA,\n            gl.ONE,\n            gl.ONE_MINUS_SRC_ALPHA,\n        );\n\n        const renderer = new BatchRenderer(\n            ggl,\n            VERTEX_FORMAT,\n            MAX_BATCHED_VERTS,\n            MAX_BATCHED_INDICES,\n        );\n\n        // a checkerboard texture used for the default background\n        const bgTex = Texture.fromImage(\n            ggl,\n            new ImageData(\n                new Uint8ClampedArray([\n                    128,\n                    128,\n                    128,\n                    255,\n                    190,\n                    190,\n                    190,\n                    255,\n                    190,\n                    190,\n                    190,\n                    255,\n                    128,\n                    128,\n                    128,\n                    255,\n                ]),\n                2,\n                2,\n            ),\n            {\n                wrap: \"repeat\",\n                filter: \"nearest\",\n            },\n        );\n\n        return {\n            // how many draw calls we're doing last frame, this is the number we give to users\n            lastDrawCalls: 0,\n\n            // gfx states\n            defShader: defShader,\n            defTex: emptyTex,\n            frameBuffer: frameBuffer,\n            postShader: null,\n            postShaderUniform: null,\n            renderer: renderer,\n\n            transform: new Mat4(),\n            transformStack: [],\n\n            bgTex: bgTex,\n            bgColor: bgColor,\n            bgAlpha: bgAlpha,\n\n            width: gopt.width\n                ?? gl.drawingBufferWidth / pixelDensity / gscale,\n            height: gopt.height\n                ?? gl.drawingBufferHeight / pixelDensity / gscale,\n\n            viewport: {\n                x: 0,\n                y: 0,\n                width: gl.drawingBufferWidth,\n                height: gl.drawingBufferHeight,\n            },\n\n            fixed: false,\n        };\n    })();\n\n    class SpriteData {\n        tex: Texture;\n        frames: Quad[] = [new Quad(0, 0, 1, 1)];\n        anims: SpriteAnims = {};\n        slice9: NineSlice | null = null;\n\n        constructor(\n            tex: Texture,\n            frames?: Quad[],\n            anims: SpriteAnims = {},\n            slice9: NineSlice = null,\n        ) {\n            this.tex = tex;\n            if (frames) this.frames = frames;\n            this.anims = anims;\n            this.slice9 = slice9;\n        }\n\n        get width() {\n            return this.tex.width * this.frames[0].w;\n        }\n\n        get height() {\n            return this.tex.height * this.frames[0].h;\n        }\n\n        static from(\n            src: LoadSpriteSrc,\n            opt: LoadSpriteOpt = {},\n        ): Promise<SpriteData> {\n            return typeof src === \"string\"\n                ? SpriteData.fromURL(src, opt)\n                : Promise.resolve(SpriteData.fromImage(src, opt));\n        }\n\n        static fromImage(\n            data: ImageSource,\n            opt: LoadSpriteOpt = {},\n        ): SpriteData {\n            const [tex, quad] = assets.packer.add(data);\n            const frames = opt.frames\n                ? opt.frames.map((f) =>\n                    new Quad(\n                        quad.x + f.x * quad.w,\n                        quad.y + f.y * quad.h,\n                        f.w * quad.w,\n                        f.h * quad.h,\n                    )\n                )\n                : slice(\n                    opt.sliceX || 1,\n                    opt.sliceY || 1,\n                    quad.x,\n                    quad.y,\n                    quad.w,\n                    quad.h,\n                );\n            return new SpriteData(tex, frames, opt.anims, opt.slice9);\n        }\n\n        static fromURL(\n            url: string,\n            opt: LoadSpriteOpt = {},\n        ): Promise<SpriteData> {\n            return loadImg(url).then((img) => SpriteData.fromImage(img, opt));\n        }\n    }\n\n    class SoundData {\n        buf: AudioBuffer;\n\n        constructor(buf: AudioBuffer) {\n            this.buf = buf;\n        }\n\n        static fromArrayBuffer(buf: ArrayBuffer): Promise<SoundData> {\n            return new Promise((resolve, reject) =>\n                audio.ctx.decodeAudioData(buf, resolve, reject)\n            ).then((buf: AudioBuffer) => new SoundData(buf));\n        }\n\n        static fromURL(url: string): Promise<SoundData> {\n            if (isDataURL(url)) {\n                return SoundData.fromArrayBuffer(dataURLToArrayBuffer(url));\n            } else {\n                return fetchArrayBuffer(url).then((buf) =>\n                    SoundData.fromArrayBuffer(buf)\n                );\n            }\n        }\n    }\n\n    const audio = (() => {\n        const ctx = new (\n            window.AudioContext || (window as any).webkitAudioContext\n        )() as AudioContext;\n\n        const masterNode = ctx.createGain();\n        masterNode.connect(ctx.destination);\n\n        // by default browsers can only load audio async, we don't deal with that and just start with an empty audio buffer\n        const burpSnd = new SoundData(createEmptyAudioBuffer(ctx));\n\n        // load that burp sound\n        ctx.decodeAudioData(burpSoundSrc.buffer.slice(0)).then((buf) => {\n            burpSnd.buf = buf;\n        }).catch((err) => {\n            console.error(\"Failed to load burp: \", err);\n        });\n\n        return {\n            ctx,\n            masterNode,\n            burpSnd,\n        };\n    })();\n\n    const assets = {\n        urlPrefix: \"\",\n        // asset holders\n        sprites: new AssetBucket<SpriteData>(),\n        fonts: new AssetBucket<FontData>(),\n        bitmapFonts: new AssetBucket<BitmapFontData>(),\n        sounds: new AssetBucket<SoundData>(),\n        shaders: new AssetBucket<ShaderData>(),\n        custom: new AssetBucket<any>(),\n        music: {},\n        packer: new TexPacker(ggl, SPRITE_ATLAS_WIDTH, SPRITE_ATLAS_HEIGHT),\n        // if we finished initially loading all assets\n        loaded: false,\n    };\n\n    function fixURL<D>(url: D): D {\n        if (typeof url !== \"string\" || isDataURL(url)) return url;\n        return assets.urlPrefix + url as D;\n    }\n\n    const game = {\n        // general events\n        events: new EventHandler<{\n            mouseMove: [];\n            mouseDown: [MouseButton];\n            mousePress: [MouseButton];\n            mouseRelease: [MouseButton];\n            charInput: [string];\n            keyPress: [Key];\n            keyDown: [Key];\n            keyPressRepeat: [Key];\n            keyRelease: [Key];\n            touchStart: [Vec2, Touch];\n            touchMove: [Vec2, Touch];\n            touchEnd: [Vec2, Touch];\n            gamepadButtonDown: [string];\n            gamepadButtonPress: [string];\n            gamepadButtonRelease: [string];\n            gamepadStick: [string, Vec2];\n            gamepadConnect: [Gamepad];\n            gamepadDisconnect: [Gamepad];\n            scroll: [Vec2];\n            add: [GameObj];\n            destroy: [GameObj];\n            load: [];\n            loading: [number];\n            error: [Error];\n            input: [];\n            frameEnd: [];\n            resize: [];\n            sceneLeave: [string];\n        }>(),\n\n        // object events\n        objEvents: new EventHandler(),\n\n        // root game object\n        root: make([]),\n\n        // misc\n        gravity: vec2(0, 1),\n        scenes: {},\n        currentScene: null,\n\n        // on screen log\n        logs: [],\n\n        // camera\n        cam: {\n            pos: null,\n            scale: new Vec2(1),\n            angle: 0,\n            shake: 0,\n            transform: new Mat4(),\n        },\n    };\n\n    game.root.use(timer());\n\n    // wrap individual loaders with global loader counter, for stuff like progress bar\n    function load<T>(prom: Promise<T>): Asset<T> {\n        return assets.custom.add(null, prom);\n    }\n\n    // get current load progress\n    function loadProgress(): number {\n        const buckets = [\n            assets.sprites,\n            assets.sounds,\n            assets.shaders,\n            assets.fonts,\n            assets.bitmapFonts,\n            assets.custom,\n        ];\n        return buckets.reduce((n, bucket) => n + bucket.progress(), 0)\n            / buckets.length;\n    }\n\n    // global load path prefix\n    function loadRoot(path?: string): string {\n        if (path !== undefined) {\n            assets.urlPrefix = path;\n        }\n        return assets.urlPrefix;\n    }\n\n    function loadJSON(name, url) {\n        return assets.custom.add(name, fetchJSON(url));\n    }\n\n    class FontData {\n        fontface: FontFace;\n        filter: TexFilter = DEF_FONT_FILTER;\n        outline: Outline | null = null;\n        size: number = DEF_TEXT_CACHE_SIZE;\n        constructor(face: FontFace, opt: LoadFontOpt = {}) {\n            this.fontface = face;\n            this.filter = opt.filter ?? DEF_FONT_FILTER;\n            this.size = opt.size ?? DEF_TEXT_CACHE_SIZE;\n            if (this.size > MAX_TEXT_CACHE_SIZE) {\n                throw new Error(`Max font size: ${MAX_TEXT_CACHE_SIZE}`);\n            }\n            if (opt.outline) {\n                this.outline = {\n                    width: 1,\n                    color: rgb(0, 0, 0),\n                };\n                if (typeof opt.outline === \"number\") {\n                    this.outline.width = opt.outline;\n                } else if (typeof opt.outline === \"object\") {\n                    if (opt.outline.width) {\n                        this.outline.width = opt.outline.width;\n                    }\n                    if (opt.outline.color) {\n                        this.outline.color = opt.outline.color;\n                    }\n                }\n            }\n        }\n    }\n\n    // TODO: pass in null src to store opt for default fonts like \"monospace\"\n    function loadFont(\n        name: string,\n        src: string | BinaryData,\n        opt: LoadFontOpt = {},\n    ): Asset<FontData> {\n        const font = new FontFace(\n            name,\n            typeof src === \"string\" ? `url(${src})` : src,\n        );\n        document.fonts.add(font);\n        return assets.fonts.add(\n            name,\n            font.load().catch((err) => {\n                throw new Error(`Failed to load font from \"${src}\": ${err}`);\n            }).then((face) => new FontData(face, opt)),\n        );\n    }\n\n    // TODO: support outline\n    // TODO: support LoadSpriteSrc\n    function loadBitmapFont(\n        name: string | null,\n        src: string,\n        gw: number,\n        gh: number,\n        opt: LoadBitmapFontOpt = {},\n    ): Asset<BitmapFontData> {\n        return assets.bitmapFonts.add(\n            name,\n            loadImg(src)\n                .then((img) => {\n                    return makeFont(\n                        Texture.fromImage(ggl, img, opt),\n                        gw,\n                        gh,\n                        opt.chars ?? ASCII_CHARS,\n                    );\n                }),\n        );\n    }\n\n    // get an array of frames based on configuration on how to slice the image\n    function slice(x = 1, y = 1, dx = 0, dy = 0, w = 1, h = 1): Quad[] {\n        const frames = [];\n        const qw = w / x;\n        const qh = h / y;\n        for (let j = 0; j < y; j++) {\n            for (let i = 0; i < x; i++) {\n                frames.push(\n                    new Quad(\n                        dx + i * qw,\n                        dy + j * qh,\n                        qw,\n                        qh,\n                    ),\n                );\n            }\n        }\n        return frames;\n    }\n\n    // TODO: load synchronously if passed ImageSource\n    function loadSpriteAtlas(\n        src: LoadSpriteSrc,\n        data: SpriteAtlasData | string,\n    ): Asset<Record<string, SpriteData>> {\n        src = fixURL(src);\n        if (typeof data === \"string\") {\n            return load(\n                new Promise((res, rej) => {\n                    fetchJSON(data).then((json) => {\n                        loadSpriteAtlas(src, json).then(res).catch(rej);\n                    });\n                }),\n            );\n        }\n        return load(\n            SpriteData.from(src).then((atlas) => {\n                const map = {};\n                for (const name in data) {\n                    const info = data[name];\n                    const quad = atlas.frames[0];\n                    const w = SPRITE_ATLAS_WIDTH * quad.w;\n                    const h = SPRITE_ATLAS_HEIGHT * quad.h;\n                    const frames = info.frames\n                        ? info.frames.map((f) =>\n                            new Quad(\n                                quad.x + (info.x + f.x) / w * quad.w,\n                                quad.y + (info.y + f.y) / h * quad.h,\n                                f.w / w * quad.w,\n                                f.h / h * quad.h,\n                            )\n                        )\n                        : slice(\n                            info.sliceX || 1,\n                            info.sliceY || 1,\n                            quad.x + info.x / w * quad.w,\n                            quad.y + info.y / h * quad.h,\n                            info.width / w * quad.w,\n                            info.height / h * quad.h,\n                        );\n                    const spr = new SpriteData(atlas.tex, frames, info.anims);\n                    assets.sprites.addLoaded(name, spr);\n                    map[name] = spr;\n                }\n                return map;\n            }),\n        );\n    }\n\n    function createSpriteSheet(\n        images: ImageSource[],\n        opt: LoadSpriteOpt = {},\n    ): SpriteData {\n        const canvas = document.createElement(\"canvas\");\n        const width = images[0].width;\n        const height = images[0].height;\n        canvas.width = width * images.length;\n        canvas.height = height;\n        const c2d = canvas.getContext(\"2d\");\n        images.forEach((img, i) => {\n            if (img instanceof ImageData) {\n                c2d.putImageData(img, i * width, 0);\n            } else {\n                c2d.drawImage(img, i * width, 0);\n            }\n        });\n        const merged = c2d.getImageData(0, 0, images.length * width, height);\n        return SpriteData.fromImage(merged, {\n            ...opt,\n            sliceX: images.length,\n            sliceY: 1,\n        });\n    }\n\n    // load a sprite to asset manager\n    function loadSprite(\n        name: string | null,\n        src: LoadSpriteSrc | LoadSpriteSrc[],\n        opt: LoadSpriteOpt = {\n            sliceX: 1,\n            sliceY: 1,\n            anims: {},\n        },\n    ): Asset<SpriteData> {\n        src = fixURL(src);\n        if (Array.isArray(src)) {\n            if (src.some((s) => typeof s === \"string\")) {\n                return assets.sprites.add(\n                    name,\n                    Promise.all(src.map((s) => {\n                        return typeof s === \"string\"\n                            ? loadImg(s)\n                            : Promise.resolve(s);\n                    })).then((images) => createSpriteSheet(images, opt)),\n                );\n            } else {\n                return assets.sprites.addLoaded(\n                    name,\n                    createSpriteSheet(src as ImageSource[], opt),\n                );\n            }\n        } else {\n            if (typeof src === \"string\") {\n                return assets.sprites.add(name, SpriteData.from(src, opt));\n            } else {\n                return assets.sprites.addLoaded(\n                    name,\n                    SpriteData.fromImage(src, opt),\n                );\n            }\n        }\n    }\n\n    function loadPedit(\n        name: string | null,\n        src: string | PeditFile,\n    ): Asset<SpriteData> {\n        src = fixURL(src);\n\n        return assets.sprites.add(\n            name,\n            new Promise(async (resolve) => {\n                const data = typeof src === \"string\"\n                    ? await fetchJSON(src)\n                    : src;\n                const images = await Promise.all(data.frames.map(loadImg));\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = data.width;\n                canvas.height = data.height * data.frames.length;\n\n                const c2d = canvas.getContext(\"2d\");\n\n                images.forEach((img: HTMLImageElement, i) => {\n                    c2d.drawImage(img, 0, i * data.height);\n                });\n\n                const spr = await loadSprite(null, canvas, {\n                    sliceY: data.frames.length,\n                    anims: data.anims,\n                });\n\n                resolve(spr);\n            }),\n        );\n    }\n\n    function loadAseprite(\n        name: string | null,\n        imgSrc: LoadSpriteSrc,\n        jsonSrc: string | AsepriteData,\n    ): Asset<SpriteData> {\n        imgSrc = fixURL(imgSrc);\n        jsonSrc = fixURL(jsonSrc);\n\n        if (typeof imgSrc === \"string\" && !jsonSrc) {\n            jsonSrc = getFileName(imgSrc) + \".json\";\n        }\n\n        const resolveJSON = typeof jsonSrc === \"string\"\n            ? fetchJSON(jsonSrc)\n            : Promise.resolve(jsonSrc);\n\n        return assets.sprites.add(\n            name,\n            resolveJSON.then((data: AsepriteData) => {\n                const size = data.meta.size;\n                const frames = data.frames.map((f: any) => {\n                    return new Quad(\n                        f.frame.x / size.w,\n                        f.frame.y / size.h,\n                        f.frame.w / size.w,\n                        f.frame.h / size.h,\n                    );\n                });\n                const anims = {};\n                for (const anim of data.meta.frameTags) {\n                    if (anim.from === anim.to) {\n                        anims[anim.name] = anim.from;\n                    } else {\n                        anims[anim.name] = {\n                            from: anim.from,\n                            to: anim.to,\n                            speed: 10,\n                            loop: true,\n                            pingpong: anim.direction === \"pingpong\",\n                        };\n                    }\n                }\n                return SpriteData.from(imgSrc, {\n                    frames: frames,\n                    anims: anims,\n                });\n            }),\n        );\n    }\n\n    function loadShader(\n        name: string | null,\n        vert?: string,\n        frag?: string,\n    ) {\n        return assets.shaders.addLoaded(name, makeShader(vert, frag));\n    }\n\n    function loadShaderURL(\n        name: string | null,\n        vert?: string,\n        frag?: string,\n    ): Asset<ShaderData> {\n        vert = fixURL(vert);\n        frag = fixURL(frag);\n        const resolveUrl = (url?: string) =>\n            url\n                ? fetchText(url)\n                : Promise.resolve(null);\n        const load = Promise.all([resolveUrl(vert), resolveUrl(frag)])\n            .then(([vcode, fcode]: [string | null, string | null]) => {\n                return makeShader(vcode, fcode);\n            });\n        return assets.shaders.add(name, load);\n    }\n\n    // load a sound to asset manager\n    function loadSound(\n        name: string | null,\n        src: string | ArrayBuffer,\n    ): Asset<SoundData> {\n        src = fixURL(src);\n        return assets.sounds.add(\n            name,\n            typeof src === \"string\"\n                ? SoundData.fromURL(src)\n                : SoundData.fromArrayBuffer(src),\n        );\n    }\n\n    function loadMusic(\n        name: string | null,\n        url: string,\n    ) {\n        const a = new Audio(url);\n        a.preload = \"auto\";\n        return assets.music[name] = fixURL(url);\n    }\n\n    function loadBean(name: string = \"bean\"): Asset<SpriteData> {\n        return loadSprite(name, beanSpriteSrc);\n    }\n\n    function getSprite(name: string): Asset<SpriteData> | void {\n        return assets.sprites.get(name);\n    }\n\n    function getSound(name: string): Asset<SoundData> | void {\n        return assets.sounds.get(name);\n    }\n\n    function getFont(name: string): Asset<FontData> | void {\n        return assets.fonts.get(name);\n    }\n\n    function getBitmapFont(name: string): Asset<BitmapFontData> | void {\n        return assets.bitmapFonts.get(name);\n    }\n\n    function getShader(name: string): Asset<ShaderData> | void {\n        return assets.shaders.get(name);\n    }\n\n    function getAsset(name: string): Asset<any> | void {\n        return assets.custom.get(name);\n    }\n\n    function resolveSprite(\n        src: DrawSpriteOpt[\"sprite\"],\n    ): Asset<SpriteData> | null {\n        if (typeof src === \"string\") {\n            const spr = getSprite(src);\n            if (spr) {\n                // if it's already loaded or being loading, return it\n                return spr;\n            } else if (loadProgress() < 1) {\n                // if there's any other ongoing loading task we return empty and don't error yet\n                return null;\n            } else {\n                // if all other assets are loaded and we still haven't found this sprite, throw\n                throw new Error(`Sprite not found: ${src}`);\n            }\n        } else if (src instanceof SpriteData) {\n            return Asset.loaded(src);\n        } else if (src instanceof Asset) {\n            return src;\n        } else {\n            throw new Error(`Invalid sprite: ${src}`);\n        }\n    }\n\n    function resolveSound(\n        src: string | SoundData | Asset<SoundData>,\n    ): Asset<SoundData> | null {\n        if (typeof src === \"string\") {\n            const snd = getSound(src);\n            if (snd) {\n                return snd;\n            } else if (loadProgress() < 1) {\n                return null;\n            } else {\n                throw new Error(`Sound not found: ${src}`);\n            }\n        } else if (src instanceof SoundData) {\n            return Asset.loaded(src);\n        } else if (src instanceof Asset) {\n            return src;\n        } else {\n            throw new Error(`Invalid sound: ${src}`);\n        }\n    }\n\n    function resolveShader(\n        src: RenderProps[\"shader\"],\n    ): ShaderData | Asset<ShaderData> | null {\n        if (!src) {\n            return gfx.defShader;\n        }\n        if (typeof src === \"string\") {\n            const shader = getShader(src);\n            if (shader) {\n                return shader.data ?? shader;\n            } else if (loadProgress() < 1) {\n                return null;\n            } else {\n                throw new Error(`Shader not found: ${src}`);\n            }\n        } else if (src instanceof Asset) {\n            return src.data ? src.data : src;\n        }\n        // TODO: check type\n        // @ts-ignore\n        return src;\n    }\n\n    function resolveFont(\n        src: DrawTextOpt[\"font\"],\n    ):\n        | FontData\n        | Asset<FontData>\n        | BitmapFontData\n        | Asset<BitmapFontData>\n        | string\n        | void\n    {\n        if (!src) {\n            return resolveFont(gopt.font ?? DEF_FONT);\n        }\n        if (typeof src === \"string\") {\n            const bfont = getBitmapFont(src);\n            const font = getFont(src);\n            if (bfont) {\n                return bfont.data ?? bfont;\n            } else if (font) {\n                return font.data ?? font;\n            } else if (\n                document.fonts.check(`${DEF_TEXT_CACHE_SIZE}px ${src}`)\n            ) {\n                return src;\n            } else if (loadProgress() < 1) {\n                return null;\n            } else {\n                throw new Error(`Font not found: ${src}`);\n            }\n        } else if (src instanceof Asset) {\n            return src.data ? src.data : src;\n        }\n        // TODO: check type\n        // @ts-ignore\n        return src;\n    }\n\n    // get / set master volume\n    function volume(v?: number): number {\n        if (v !== undefined) {\n            audio.masterNode.gain.value = v;\n        }\n        return audio.masterNode.gain.value;\n    }\n\n    function playMusic(url: string, opt: AudioPlayOpt = {}): AudioPlay {\n        const onEndEvents = new Event();\n        const el = new Audio(url);\n        const src = audio.ctx.createMediaElementSource(el);\n\n        src.connect(audio.masterNode);\n\n        function resumeAudioCtx() {\n            if (debug.paused) return;\n            if (app.isHidden() && !gopt.backgroundAudio) return;\n            audio.ctx.resume();\n        }\n\n        function play() {\n            resumeAudioCtx();\n            el.play();\n        }\n\n        if (!opt.paused) {\n            play();\n        }\n\n        el.onended = () => onEndEvents.trigger();\n\n        return {\n            play() {\n                play();\n            },\n\n            seek(time: number) {\n                el.currentTime = time;\n            },\n\n            stop() {\n                el.pause();\n                this.seek(0);\n            },\n\n            set loop(l: boolean) {\n                el.loop = l;\n            },\n\n            get loop() {\n                return el.loop;\n            },\n\n            set paused(p: boolean) {\n                if (p) {\n                    el.pause();\n                } else {\n                    play();\n                }\n            },\n\n            get paused() {\n                return el.paused;\n            },\n\n            time() {\n                return el.currentTime;\n            },\n\n            duration() {\n                return el.duration;\n            },\n\n            set volume(val: number) {\n                el.volume = clamp(val, 0, 1);\n            },\n\n            get volume() {\n                return el.volume;\n            },\n\n            set speed(s) {\n                el.playbackRate = Math.max(s, 0);\n            },\n\n            get speed() {\n                return el.playbackRate;\n            },\n\n            set detune(d) {\n                // TODO\n            },\n\n            get detune() {\n                // TODO\n                return 0;\n            },\n\n            onEnd(action: () => void) {\n                return onEndEvents.add(action);\n            },\n\n            then(action: () => void) {\n                return this.onEnd(action);\n            },\n        };\n    }\n\n    function play(\n        src:\n            | string\n            | SoundData\n            | Asset<SoundData>\n            | MusicData\n            | Asset<MusicData>,\n        opt: AudioPlayOpt = {},\n    ): AudioPlay {\n        if (typeof src === \"string\" && assets.music[src]) {\n            return playMusic(assets.music[src], opt);\n        }\n\n        const ctx = audio.ctx;\n        let paused = opt.paused ?? false;\n        let srcNode = ctx.createBufferSource();\n        const onEndEvents = new Event();\n        const gainNode = ctx.createGain();\n        const pos = opt.seek ?? 0;\n        let startTime = 0;\n        let stopTime = 0;\n        let started = false;\n\n        srcNode.loop = Boolean(opt.loop);\n        srcNode.detune.value = opt.detune ?? 0;\n        srcNode.playbackRate.value = opt.speed ?? 1;\n        srcNode.connect(gainNode);\n        srcNode.onended = () => {\n            if (\n                getTime()\n                    >= (srcNode.buffer?.duration ?? Number.POSITIVE_INFINITY)\n            ) {\n                onEndEvents.trigger();\n            }\n        };\n        gainNode.connect(audio.masterNode);\n        gainNode.gain.value = opt.volume ?? 1;\n\n        const start = (data: SoundData) => {\n            srcNode.buffer = data.buf;\n            if (!paused) {\n                startTime = ctx.currentTime;\n                srcNode.start(0, pos);\n                started = true;\n            }\n        };\n\n        // @ts-ignore\n        const snd = resolveSound(src);\n\n        if (snd instanceof Asset) {\n            snd.onLoad(start);\n        }\n\n        const getTime = () => {\n            if (!srcNode.buffer) return 0;\n            const t = paused\n                ? stopTime - startTime\n                : ctx.currentTime - startTime;\n            const d = srcNode.buffer.duration;\n            return srcNode.loop ? t % d : Math.min(t, d);\n        };\n\n        const cloneNode = (oldNode: AudioBufferSourceNode) => {\n            const newNode = ctx.createBufferSource();\n            newNode.buffer = oldNode.buffer;\n            newNode.loop = oldNode.loop;\n            newNode.playbackRate.value = oldNode.playbackRate.value;\n            newNode.detune.value = oldNode.detune.value;\n            newNode.onended = oldNode.onended;\n            newNode.connect(gainNode);\n            return newNode;\n        };\n\n        return {\n            stop() {\n                this.paused = true;\n                this.seek(0);\n            },\n\n            set paused(p: boolean) {\n                if (paused === p) return;\n                paused = p;\n                if (p) {\n                    if (started) {\n                        srcNode.stop();\n                        started = false;\n                    }\n                    stopTime = ctx.currentTime;\n                } else {\n                    srcNode = cloneNode(srcNode);\n                    const pos = stopTime - startTime;\n                    srcNode.start(0, pos);\n                    started = true;\n                    startTime = ctx.currentTime - pos;\n                    stopTime = 0;\n                }\n            },\n\n            get paused() {\n                return paused;\n            },\n\n            play(time: number = 0) {\n                this.seek(time);\n                this.paused = false;\n            },\n\n            seek(time: number) {\n                if (!srcNode.buffer?.duration) return;\n                if (time > srcNode.buffer.duration) return;\n                if (paused) {\n                    srcNode = cloneNode(srcNode);\n                    startTime = stopTime - time;\n                } else {\n                    srcNode.stop();\n                    srcNode = cloneNode(srcNode);\n                    startTime = ctx.currentTime - time;\n                    srcNode.start(0, time);\n                    started = true;\n                    stopTime = 0;\n                }\n            },\n\n            // TODO: affect time()\n            set speed(val: number) {\n                srcNode.playbackRate.value = val;\n            },\n\n            get speed() {\n                return srcNode.playbackRate.value;\n            },\n\n            set detune(val: number) {\n                srcNode.detune.value = val;\n            },\n\n            get detune() {\n                return srcNode.detune.value;\n            },\n\n            set volume(val: number) {\n                gainNode.gain.value = Math.max(val, 0);\n            },\n\n            get volume() {\n                return gainNode.gain.value;\n            },\n\n            set loop(l: boolean) {\n                srcNode.loop = l;\n            },\n\n            get loop() {\n                return srcNode.loop;\n            },\n\n            duration(): number {\n                return srcNode.buffer?.duration ?? 0;\n            },\n\n            time(): number {\n                return getTime() % this.duration();\n            },\n\n            onEnd(action: () => void) {\n                return onEndEvents.add(action);\n            },\n\n            then(action: () => void) {\n                return this.onEnd(action);\n            },\n        };\n    }\n\n    // core kaboom logic\n    function burp(opt?: AudioPlayOpt): AudioPlay {\n        return play(audio.burpSnd, opt);\n    }\n\n    function makeCanvas(w: number, h: number) {\n        const fb = new FrameBuffer(ggl, w, h);\n        return {\n            clear: () => fb.clear(),\n            free: () => fb.free(),\n            toDataURL: () => fb.toDataURL(),\n            toImageData: () => fb.toImageData(),\n            width: fb.width,\n            height: fb.height,\n            draw: (action) => {\n                flush();\n                fb.bind();\n                action();\n                flush();\n                fb.unbind();\n            },\n        };\n    }\n\n    function makeShader(\n        vertSrc: string | null = DEF_VERT,\n        fragSrc: string | null = DEF_FRAG,\n    ): Shader {\n        const vcode = VERT_TEMPLATE.replace(\"{{user}}\", vertSrc ?? DEF_VERT);\n        const fcode = FRAG_TEMPLATE.replace(\"{{user}}\", fragSrc ?? DEF_FRAG);\n        try {\n            return new Shader(\n                ggl,\n                vcode,\n                fcode,\n                VERTEX_FORMAT.map((vert) => vert.name),\n            );\n        } catch (e) {\n            const lineOffset = 14;\n            const fmt =\n                /(?<type>^\\w+) SHADER ERROR: 0:(?<line>\\d+): (?<msg>.+)/;\n            const match = getErrorMessage(e).match(fmt);\n            const line = Number(match.groups.line) - lineOffset;\n            const msg = match.groups.msg.trim();\n            const ty = match.groups.type.toLowerCase();\n            throw new Error(`${ty} shader line ${line}: ${msg}`);\n        }\n    }\n\n    function makeFont(\n        tex: Texture,\n        gw: number,\n        gh: number,\n        chars: string,\n    ): GfxFont {\n        const cols = tex.width / gw;\n        const map: Record<string, Quad> = {};\n        const charMap = chars.split(\"\").entries();\n\n        for (const [i, ch] of charMap) {\n            map[ch] = new Quad(\n                (i % cols) * gw,\n                Math.floor(i / cols) * gh,\n                gw,\n                gh,\n            );\n        }\n\n        return {\n            tex: tex,\n            map: map,\n            size: gh,\n        };\n    }\n\n    // TODO: expose\n    function drawRaw(\n        verts: Vertex[],\n        indices: number[],\n        fixed: boolean,\n        tex: Texture = gfx.defTex,\n        shaderSrc: RenderProps[\"shader\"] = gfx.defShader,\n        uniform: Uniform = {},\n    ) {\n        const shader = resolveShader(shaderSrc);\n\n        if (!shader || shader instanceof Asset) {\n            return;\n        }\n\n        const transform = (gfx.fixed || fixed)\n            ? gfx.transform\n            : game.cam.transform.mult(gfx.transform);\n\n        const vv = [];\n\n        for (const v of verts) {\n            // normalized world space coordinate [-1.0 ~ 1.0]\n            const pt = screen2ndc(transform.multVec2(v.pos));\n            vv.push(\n                pt.x,\n                pt.y,\n                v.uv.x,\n                v.uv.y,\n                v.color.r / 255,\n                v.color.g / 255,\n                v.color.b / 255,\n                v.opacity,\n            );\n        }\n\n        gfx.renderer.push(gl.TRIANGLES, vv, indices, shader, tex, uniform);\n    }\n\n    // draw all batched shapes\n    function flush() {\n        gfx.renderer.flush();\n    }\n\n    // start a rendering frame, reset some states\n    function frameStart() {\n        // clear backbuffer\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gfx.frameBuffer.bind();\n        // clear framebuffer\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        if (!gfx.bgColor) {\n            drawUnscaled(() => {\n                drawUVQuad({\n                    width: width(),\n                    height: height(),\n                    quad: new Quad(\n                        0,\n                        0,\n                        width() / BG_GRID_SIZE,\n                        height() / BG_GRID_SIZE,\n                    ),\n                    tex: gfx.bgTex,\n                    fixed: true,\n                });\n            });\n        }\n\n        gfx.renderer.numDraws = 0;\n        gfx.fixed = false;\n        gfx.transformStack.length = 0;\n        gfx.transform = new Mat4();\n    }\n\n    function usePostEffect(name: string, uniform?: Uniform | (() => Uniform)) {\n        gfx.postShader = name;\n        gfx.postShaderUniform = uniform ?? null;\n    }\n\n    function frameEnd() {\n        // TODO: don't render debug UI with framebuffer\n        // TODO: polish framebuffer rendering / sizing issues\n        flush();\n        gfx.lastDrawCalls = gfx.renderer.numDraws;\n        gfx.frameBuffer.unbind();\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n        const ow = gfx.width;\n        const oh = gfx.height;\n        gfx.width = gl.drawingBufferWidth / pixelDensity;\n        gfx.height = gl.drawingBufferHeight / pixelDensity;\n\n        drawTexture({\n            flipY: true,\n            tex: gfx.frameBuffer.tex,\n            pos: new Vec2(gfx.viewport.x, gfx.viewport.y),\n            width: gfx.viewport.width,\n            height: gfx.viewport.height,\n            shader: gfx.postShader,\n            uniform: typeof gfx.postShaderUniform === \"function\"\n                ? gfx.postShaderUniform()\n                : gfx.postShaderUniform,\n            fixed: true,\n        });\n\n        flush();\n        gfx.width = ow;\n        gfx.height = oh;\n    }\n\n    // convert a screen space coordinate to webgl normalized device coordinate\n    function screen2ndc(pt: Vec2): Vec2 {\n        return new Vec2(\n            pt.x / width() * 2 - 1,\n            -pt.y / height() * 2 + 1,\n        );\n    }\n\n    function pushMatrix(m: Mat4) {\n        gfx.transform = m.clone();\n    }\n\n    function pushTranslate(...args: Vec2Args) {\n        if (args[0] === undefined) return;\n        const p = vec2(...args);\n        if (p.x === 0 && p.y === 0) return;\n        gfx.transform.translate(p);\n    }\n\n    function pushScale(...args: Vec2Args) {\n        if (args[0] === undefined) return;\n        const p = vec2(...args);\n        if (p.x === 1 && p.y === 1) return;\n        gfx.transform.scale(p);\n    }\n\n    function pushRotate(a: number) {\n        if (!a) return;\n        gfx.transform.rotate(a);\n    }\n\n    function pushTransform() {\n        gfx.transformStack.push(gfx.transform.clone());\n    }\n\n    function popTransform() {\n        if (gfx.transformStack.length > 0) {\n            gfx.transform = gfx.transformStack.pop();\n        }\n    }\n\n    // draw a uv textured quad\n    function drawUVQuad(opt: DrawUVQuadOpt) {\n        if (opt.width === undefined || opt.height === undefined) {\n            throw new Error(\n                \"drawUVQuad() requires property \\\"width\\\" and \\\"height\\\".\",\n            );\n        }\n\n        if (opt.width <= 0 || opt.height <= 0) {\n            return;\n        }\n\n        const w = opt.width;\n        const h = opt.height;\n        const anchor = anchorPt(opt.anchor || DEF_ANCHOR);\n        const offset = anchor.scale(new Vec2(w, h).scale(-0.5));\n        const q = opt.quad || new Quad(0, 0, 1, 1);\n        const color = opt.color || rgb(255, 255, 255);\n        const opacity = opt.opacity ?? 1;\n\n        // apply uv padding to avoid artifacts\n        const uvPadX = opt.tex ? UV_PAD / opt.tex.width : 0;\n        const uvPadY = opt.tex ? UV_PAD / opt.tex.height : 0;\n        const qx = q.x + uvPadX;\n        const qy = q.y + uvPadY;\n        const qw = q.w - uvPadX * 2;\n        const qh = q.h - uvPadY * 2;\n\n        pushTransform();\n        pushTranslate(opt.pos);\n        pushRotate(opt.angle);\n        pushScale(opt.scale);\n        pushTranslate(offset);\n\n        drawRaw(\n            [\n                {\n                    pos: new Vec2(-w / 2, h / 2),\n                    uv: new Vec2(\n                        opt.flipX ? qx + qw : qx,\n                        opt.flipY ? qy : qy + qh,\n                    ),\n                    color: color,\n                    opacity: opacity,\n                },\n                {\n                    pos: new Vec2(-w / 2, -h / 2),\n                    uv: new Vec2(\n                        opt.flipX ? qx + qw : qx,\n                        opt.flipY ? qy + qh : qy,\n                    ),\n                    color: color,\n                    opacity: opacity,\n                },\n                {\n                    pos: new Vec2(w / 2, -h / 2),\n                    uv: new Vec2(\n                        opt.flipX ? qx : qx + qw,\n                        opt.flipY ? qy + qh : qy,\n                    ),\n                    color: color,\n                    opacity: opacity,\n                },\n                {\n                    pos: new Vec2(w / 2, h / 2),\n                    uv: new Vec2(\n                        opt.flipX ? qx : qx + qw,\n                        opt.flipY ? qy : qy + qh,\n                    ),\n                    color: color,\n                    opacity: opacity,\n                },\n            ],\n            [0, 1, 3, 1, 2, 3],\n            opt.fixed,\n            opt.tex,\n            opt.shader,\n            opt.uniform,\n        );\n\n        popTransform();\n    }\n\n    // TODO: clean\n    function drawTexture(opt: DrawTextureOpt) {\n        if (!opt.tex) {\n            throw new Error(\"drawTexture() requires property \\\"tex\\\".\");\n        }\n\n        const q = opt.quad ?? new Quad(0, 0, 1, 1);\n        const w = opt.tex.width * q.w;\n        const h = opt.tex.height * q.h;\n        const scale = new Vec2(1);\n\n        if (opt.tiled) {\n            // TODO: draw fract\n            const repX = Math.ceil((opt.width || w) / w);\n            const repY = Math.ceil((opt.height || h) / h);\n            const anchor = anchorPt(opt.anchor || DEF_ANCHOR).add(\n                new Vec2(1, 1),\n            ).scale(0.5);\n            const offset = anchor.scale(repX * w, repY * h);\n\n            // TODO: rotation\n            for (let i = 0; i < repX; i++) {\n                for (let j = 0; j < repY; j++) {\n                    drawUVQuad(Object.assign({}, opt, {\n                        pos: (opt.pos || new Vec2(0)).add(\n                            new Vec2(w * i, h * j),\n                        ).sub(offset),\n                        scale: scale.scale(opt.scale || new Vec2(1)),\n                        tex: opt.tex,\n                        quad: q,\n                        width: w,\n                        height: h,\n                        anchor: \"topleft\",\n                    }));\n                }\n            }\n        } else {\n            // TODO: should this ignore scale?\n            if (opt.width && opt.height) {\n                scale.x = opt.width / w;\n                scale.y = opt.height / h;\n            } else if (opt.width) {\n                scale.x = opt.width / w;\n                scale.y = scale.x;\n            } else if (opt.height) {\n                scale.y = opt.height / h;\n                scale.x = scale.y;\n            }\n\n            drawUVQuad(Object.assign({}, opt, {\n                scale: scale.scale(opt.scale || new Vec2(1)),\n                tex: opt.tex,\n                quad: q,\n                width: w,\n                height: h,\n            }));\n        }\n    }\n\n    function drawSprite(opt: DrawSpriteOpt) {\n        if (!opt.sprite) {\n            throw new Error(\"drawSprite() requires property \\\"sprite\\\"\");\n        }\n\n        // TODO: slow\n        const spr = resolveSprite(opt.sprite);\n\n        if (!spr || !spr.data) {\n            return;\n        }\n\n        const q = spr.data.frames[opt.frame ?? 0];\n\n        if (!q) {\n            throw new Error(`Frame not found: ${opt.frame ?? 0}`);\n        }\n\n        drawTexture(Object.assign({}, opt, {\n            tex: spr.data.tex,\n            quad: q.scale(opt.quad ?? new Quad(0, 0, 1, 1)),\n        }));\n    }\n\n    // generate vertices to form an arc\n    function getArcPts(\n        pos: Vec2,\n        radiusX: number,\n        radiusY: number,\n        start: number,\n        end: number,\n        res: number = 1,\n    ): Vec2[] {\n        // normalize and turn start and end angles to radians\n        start = deg2rad(start % 360);\n        end = deg2rad(end % 360);\n        if (end <= start) end += Math.PI * 2;\n\n        const pts = [];\n        const nverts = Math.ceil((end - start) / deg2rad(8) * res);\n        const step = (end - start) / nverts;\n\n        // calculate vertices\n        for (let a = start; a < end; a += step) {\n            pts.push(pos.add(radiusX * Math.cos(a), radiusY * Math.sin(a)));\n        }\n\n        pts.push(pos.add(radiusX * Math.cos(end), radiusY * Math.sin(end)));\n\n        return pts;\n    }\n\n    function drawRect(opt: DrawRectOpt) {\n        if (opt.width === undefined || opt.height === undefined) {\n            throw new Error(\n                \"drawRect() requires property \\\"width\\\" and \\\"height\\\".\",\n            );\n        }\n\n        if (opt.width <= 0 || opt.height <= 0) {\n            return;\n        }\n\n        const w = opt.width;\n        const h = opt.height;\n        const anchor = anchorPt(opt.anchor || DEF_ANCHOR).add(1, 1);\n        const offset = anchor.scale(new Vec2(w, h).scale(-0.5));\n\n        let pts = [\n            new Vec2(0, 0),\n            new Vec2(w, 0),\n            new Vec2(w, h),\n            new Vec2(0, h),\n        ];\n\n        // TODO: gradient for rounded rect\n        // TODO: drawPolygon should handle generic rounded corners\n        if (opt.radius) {\n            // maximum radius is half the shortest side\n            const r = Math.min(Math.min(w, h) / 2, opt.radius);\n\n            pts = [\n                new Vec2(r, 0),\n                new Vec2(w - r, 0),\n                ...getArcPts(new Vec2(w - r, r), r, r, 270, 360),\n                new Vec2(w, r),\n                new Vec2(w, h - r),\n                ...getArcPts(new Vec2(w - r, h - r), r, r, 0, 90),\n                new Vec2(w - r, h),\n                new Vec2(r, h),\n                ...getArcPts(new Vec2(r, h - r), r, r, 90, 180),\n                new Vec2(0, h - r),\n                new Vec2(0, r),\n                ...getArcPts(new Vec2(r, r), r, r, 180, 270),\n            ];\n        }\n\n        drawPolygon(Object.assign({}, opt, {\n            offset,\n            pts,\n            ...(opt.gradient\n                ? {\n                    colors: opt.horizontal\n                        ? [\n                            opt.gradient[0],\n                            opt.gradient[1],\n                            opt.gradient[1],\n                            opt.gradient[0],\n                        ]\n                        : [\n                            opt.gradient[0],\n                            opt.gradient[0],\n                            opt.gradient[1],\n                            opt.gradient[1],\n                        ],\n                }\n                : {}),\n        }));\n    }\n\n    function drawLine(opt: DrawLineOpt) {\n        const { p1, p2 } = opt;\n\n        if (!p1 || !p2) {\n            throw new Error(\n                \"drawLine() requires properties \\\"p1\\\" and \\\"p2\\\".\",\n            );\n        }\n\n        const w = opt.width || 1;\n\n        // the displacement from the line end point to the corner point\n        const dis = p2.sub(p1).unit().normal().scale(w * 0.5);\n\n        // calculate the 4 corner points of the line polygon\n        const verts = [\n            p1.sub(dis),\n            p1.add(dis),\n            p2.add(dis),\n            p2.sub(dis),\n        ].map((p) => ({\n            pos: new Vec2(p.x, p.y),\n            uv: new Vec2(0),\n            color: opt.color ?? Color.WHITE,\n            opacity: opt.opacity ?? 1,\n        }));\n\n        drawRaw(\n            verts,\n            [0, 1, 3, 1, 2, 3],\n            opt.fixed,\n            gfx.defTex,\n            opt.shader,\n            opt.uniform,\n        );\n    }\n\n    function drawLines(opt: DrawLinesOpt) {\n        const pts = opt.pts;\n\n        if (!pts) {\n            throw new Error(\"drawLines() requires property \\\"pts\\\".\");\n        }\n\n        if (pts.length < 2) {\n            return;\n        }\n\n        if (opt.radius && pts.length >= 3) {\n            // TODO: line joines\n            // TODO: rounded vertices for arbitury polygonic shape\n            let minSLen = pts[0].sdist(pts[1]);\n\n            for (let i = 1; i < pts.length - 1; i++) {\n                minSLen = Math.min(pts[i].sdist(pts[i + 1]), minSLen);\n            }\n\n            const radius = Math.min(opt.radius, Math.sqrt(minSLen) / 2);\n\n            drawLine(Object.assign({}, opt, { p1: pts[0], p2: pts[1] }));\n\n            for (let i = 1; i < pts.length - 2; i++) {\n                const p1 = pts[i];\n                const p2 = pts[i + 1];\n                drawLine(Object.assign({}, opt, {\n                    p1: p1,\n                    p2: p2,\n                }));\n            }\n\n            drawLine(Object.assign({}, opt, {\n                p1: pts[pts.length - 2],\n                p2: pts[pts.length - 1],\n            }));\n        } else {\n            for (let i = 0; i < pts.length - 1; i++) {\n                drawLine(Object.assign({}, opt, {\n                    p1: pts[i],\n                    p2: pts[i + 1],\n                }));\n                // TODO: other line join types\n                if (opt.join !== \"none\") {\n                    drawCircle(Object.assign({}, opt, {\n                        pos: pts[i],\n                        radius: opt.width / 2,\n                    }));\n                }\n            }\n        }\n    }\n\n    function drawCurve(curve: (t: number) => Vec2, opt: DrawCurveOpt) {\n        const segments = opt.segments ?? 16;\n        const p: Vec2[] = [];\n        for (let i = 0; i <= segments; i++) {\n            p.push(curve(i / segments));\n        }\n        drawLines({\n            pts: p,\n            width: opt.width || 1,\n            pos: opt.pos,\n            color: opt.color,\n        });\n    }\n\n    function drawBezier(opt: DrawBezierOpt) {\n        drawCurve(\n            t => evaluateBezier(opt.pt1, opt.pt2, opt.pt3, opt.pt4, t),\n            opt,\n        );\n    }\n\n    function drawTriangle(opt: DrawTriangleOpt) {\n        if (!opt.p1 || !opt.p2 || !opt.p3) {\n            throw new Error(\n                \"drawTriangle() requires properties \\\"p1\\\", \\\"p2\\\" and \\\"p3\\\".\",\n            );\n        }\n        return drawPolygon(Object.assign({}, opt, {\n            pts: [opt.p1, opt.p2, opt.p3],\n        }));\n    }\n\n    function drawCircle(opt: DrawCircleOpt) {\n        if (typeof opt.radius !== \"number\") {\n            throw new Error(\"drawCircle() requires property \\\"radius\\\".\");\n        }\n\n        if (opt.radius === 0) {\n            return;\n        }\n\n        drawEllipse(Object.assign({}, opt, {\n            radiusX: opt.radius,\n            radiusY: opt.radius,\n            angle: 0,\n        }));\n    }\n\n    function drawEllipse(opt: DrawEllipseOpt) {\n        if (opt.radiusX === undefined || opt.radiusY === undefined) {\n            throw new Error(\n                \"drawEllipse() requires properties \\\"radiusX\\\" and \\\"radiusY\\\".\",\n            );\n        }\n\n        if (opt.radiusX === 0 || opt.radiusY === 0) {\n            return;\n        }\n\n        const start = opt.start ?? 0;\n        const end = opt.end ?? 360;\n        const offset = anchorPt(opt.anchor ?? \"center\").scale(\n            new Vec2(-opt.radiusX, -opt.radiusY),\n        );\n\n        const pts = getArcPts(\n            offset,\n            opt.radiusX,\n            opt.radiusY,\n            start,\n            end,\n            opt.resolution,\n        );\n\n        // center\n        pts.unshift(offset);\n\n        const polyOpt = Object.assign({}, opt, {\n            pts,\n            radius: 0,\n            ...(opt.gradient\n                ? {\n                    colors: [\n                        opt.gradient[0],\n                        ...Array(pts.length - 1).fill(opt.gradient[1]),\n                    ],\n                }\n                : {}),\n        });\n\n        // full circle with outline shouldn't have the center point\n        if (end - start >= 360 && opt.outline) {\n            if (opt.fill !== false) {\n                drawPolygon(Object.assign({}, polyOpt, {\n                    outline: null,\n                }));\n            }\n            drawPolygon(Object.assign({}, polyOpt, {\n                pts: pts.slice(1),\n                fill: false,\n            }));\n            return;\n        }\n\n        drawPolygon(polyOpt);\n    }\n\n    function drawPolygon(opt: DrawPolygonOpt) {\n        if (!opt.pts) {\n            throw new Error(\"drawPolygon() requires property \\\"pts\\\".\");\n        }\n\n        const npts = opt.pts.length;\n\n        if (npts < 3) {\n            return;\n        }\n\n        pushTransform();\n        pushTranslate(opt.pos);\n        pushScale(opt.scale);\n        pushRotate(opt.angle);\n        pushTranslate(opt.offset);\n\n        if (opt.fill !== false) {\n            const color = opt.color ?? Color.WHITE;\n\n            const verts = opt.pts.map((pt, i) => ({\n                pos: new Vec2(pt.x, pt.y),\n                uv: opt.uv\n                    ? opt.uv[i]\n                    : new Vec2(0, 0),\n                color: opt.colors\n                    ? (opt.colors[i] ? opt.colors[i].mult(color) : color)\n                    : color,\n                opacity: opt.opacity ?? 1,\n            }));\n\n            // TODO: better triangulation\n            let indices;\n\n            if (opt.triangulate && isConvex(opt.pts)) {\n                const triangles = triangulate(opt.pts);\n                indices = triangles.map(t => t.map(p => opt.pts.indexOf(p)))\n                    .flat();\n            } else {\n                indices = [...Array(npts - 2).keys()]\n                    .map((n) => [0, n + 1, n + 2])\n                    .flat();\n            }\n\n            drawRaw(\n                verts,\n                opt.indices ?? indices,\n                opt.fixed,\n                opt.uv ? opt.tex : gfx.defTex,\n                opt.shader,\n                opt.uniform,\n            );\n        }\n\n        if (opt.outline) {\n            drawLines({\n                pts: [...opt.pts, opt.pts[0]],\n                radius: opt.radius,\n                width: opt.outline.width,\n                color: opt.outline.color,\n                join: opt.outline.join,\n                uniform: opt.uniform,\n                fixed: opt.fixed,\n                opacity: opt.opacity,\n            });\n        }\n\n        popTransform();\n    }\n\n    function drawStenciled(\n        content: () => void,\n        mask: () => void,\n        test: number,\n    ) {\n        flush();\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        gl.enable(gl.STENCIL_TEST);\n\n        // don't perform test, pure write\n        gl.stencilFunc(\n            gl.NEVER,\n            1,\n            0xFF,\n        );\n\n        // always replace since we're writing to the buffer\n        gl.stencilOp(\n            gl.REPLACE,\n            gl.REPLACE,\n            gl.REPLACE,\n        );\n\n        mask();\n        flush();\n\n        // perform test\n        gl.stencilFunc(\n            test,\n            1,\n            0xFF,\n        );\n\n        // don't write since we're only testing\n        gl.stencilOp(\n            gl.KEEP,\n            gl.KEEP,\n            gl.KEEP,\n        );\n\n        content();\n        flush();\n        gl.disable(gl.STENCIL_TEST);\n    }\n\n    function drawMasked(content: () => void, mask: () => void) {\n        drawStenciled(content, mask, gl.EQUAL);\n    }\n\n    function drawSubtracted(content: () => void, mask: () => void) {\n        drawStenciled(content, mask, gl.NOTEQUAL);\n    }\n\n    function getViewportScale() {\n        return (gfx.viewport.width + gfx.viewport.height)\n            / (gfx.width + gfx.height);\n    }\n\n    function drawUnscaled(content: () => void) {\n        flush();\n        const ow = gfx.width;\n        const oh = gfx.height;\n        gfx.width = gfx.viewport.width;\n        gfx.height = gfx.viewport.height;\n        content();\n        flush();\n        gfx.width = ow;\n        gfx.height = oh;\n    }\n\n    function applyCharTransform(fchar: FormattedChar, tr: CharTransform) {\n        if (tr.pos) fchar.pos = fchar.pos.add(tr.pos);\n        if (tr.scale) fchar.scale = fchar.scale.scale(vec2(tr.scale));\n        if (tr.angle) fchar.angle += tr.angle;\n        if (tr.color && fchar.ch.length === 1) {\n            fchar.color = fchar.color.mult(tr.color);\n        }\n        if (tr.opacity) fchar.opacity *= tr.opacity;\n    }\n\n    // TODO: handle nested\n    function compileStyledText(text: string): {\n        charStyleMap: Record<number, string[]>;\n        text: string;\n    } {\n        const charStyleMap = {};\n        // get the text without the styling syntax\n        const renderText = text.replace(TEXT_STYLE_RE, \"$2\");\n        let idxOffset = 0;\n\n        // put each styled char index into a map for easy access when iterating each char\n        for (const match of text.matchAll(TEXT_STYLE_RE)) {\n            const origIdx = match.index - idxOffset;\n            for (let i = 0; i < match.groups.text.length; i++) {\n                charStyleMap[i + origIdx] = [match.groups.style];\n            }\n            // omit the style syntax in format string when calculating index\n            idxOffset += match[0].length - match.groups.text.length;\n        }\n\n        return {\n            charStyleMap: charStyleMap,\n            text: renderText,\n        };\n    }\n\n    type FontAtlas = {\n        font: BitmapFontData;\n        cursor: Vec2;\n        outline: Outline | null;\n    };\n\n    const fontAtlases: Record<string, FontAtlas> = {};\n\n    // TODO: cache formatted text\n    // format text and return a list of chars with their calculated position\n    function formatText(opt: DrawTextOpt): FormattedText {\n        if (opt.text === undefined) {\n            throw new Error(\"formatText() requires property \\\"text\\\".\");\n        }\n\n        let font = resolveFont(opt.font);\n\n        // if it's still loading\n        if (opt.text === \"\" || font instanceof Asset || !font) {\n            return {\n                width: 0,\n                height: 0,\n                chars: [],\n                opt: opt,\n            };\n        }\n\n        const { charStyleMap, text } = compileStyledText(opt.text + \"\");\n        const chars = runes(text);\n\n        // if it's not bitmap font, we draw it with 2d canvas or use cached image\n        if (font instanceof FontData || typeof font === \"string\") {\n            const fontName = font instanceof FontData\n                ? font.fontface.family\n                : font;\n            const opts: {\n                outline: Outline | null;\n                filter: TexFilter;\n            } = font instanceof FontData\n                ? {\n                    outline: font.outline,\n                    filter: font.filter,\n                }\n                : {\n                    outline: null,\n                    filter: DEF_FONT_FILTER,\n                };\n\n            // TODO: customizable font tex filter\n            const atlas: FontAtlas = fontAtlases[fontName] ?? {\n                font: {\n                    tex: new Texture(ggl, FONT_ATLAS_WIDTH, FONT_ATLAS_HEIGHT, {\n                        filter: opts.filter,\n                    }),\n                    map: {},\n                    size: DEF_TEXT_CACHE_SIZE,\n                },\n                cursor: new Vec2(0),\n                outline: opts.outline,\n            };\n\n            if (!fontAtlases[fontName]) {\n                fontAtlases[fontName] = atlas;\n            }\n\n            font = atlas.font;\n\n            for (const ch of chars) {\n                if (!atlas.font.map[ch]) {\n                    // TODO: use assets.packer to pack font texture\n                    const c2d = fontCacheC2d;\n                    c2d.clearRect(\n                        0,\n                        0,\n                        fontCacheCanvas.width,\n                        fontCacheCanvas.height,\n                    );\n                    c2d.font = `${font.size}px ${fontName}`;\n                    c2d.textBaseline = \"top\";\n                    c2d.textAlign = \"left\";\n                    c2d.fillStyle = \"#ffffff\";\n                    const m = c2d.measureText(ch);\n                    let w = Math.ceil(m.width);\n                    if (!w) continue;\n                    let h = font.size;\n                    if (atlas.outline) {\n                        c2d.lineJoin = \"round\";\n                        c2d.lineWidth = atlas.outline.width * 2;\n                        c2d.strokeStyle = atlas.outline.color.toHex();\n                        c2d.strokeText(\n                            ch,\n                            atlas.outline.width,\n                            atlas.outline.width,\n                        );\n                        w += atlas.outline.width * 2;\n                        h += atlas.outline.width * 3;\n                    }\n                    c2d.fillText(\n                        ch,\n                        atlas.outline?.width ?? 0,\n                        atlas.outline?.width ?? 0,\n                    );\n\n                    const img = c2d.getImageData(0, 0, w, h);\n\n                    // if we are about to exceed the X axis of the texture, go to another line\n                    if (atlas.cursor.x + w > FONT_ATLAS_WIDTH) {\n                        atlas.cursor.x = 0;\n                        atlas.cursor.y += h;\n                        if (atlas.cursor.y > FONT_ATLAS_HEIGHT) {\n                            // TODO: create another atlas\n                            throw new Error(\n                                \"Font atlas exceeds character limit\",\n                            );\n                        }\n                    }\n\n                    font.tex.update(img, atlas.cursor.x, atlas.cursor.y);\n                    font.map[ch] = new Quad(\n                        atlas.cursor.x,\n                        atlas.cursor.y,\n                        w,\n                        h,\n                    );\n                    atlas.cursor.x += w;\n                }\n            }\n        }\n\n        const size = opt.size || font.size;\n        const scale = vec2(opt.scale ?? 1).scale(size / font.size);\n        const lineSpacing = opt.lineSpacing ?? 0;\n        const letterSpacing = opt.letterSpacing ?? 0;\n        let curX = 0;\n        let tw = 0;\n        let th = 0;\n        const lines: Array<{\n            width: number;\n            chars: FormattedChar[];\n        }> = [];\n        let curLine: FormattedChar[] = [];\n        let cursor = 0;\n        let lastSpace = null;\n        let lastSpaceWidth = null;\n\n        // TODO: word break\n        while (cursor < chars.length) {\n            let ch = chars[cursor];\n\n            // always new line on '\\n'\n            if (ch === \"\\n\") {\n                th += size + lineSpacing;\n\n                lines.push({\n                    width: curX - letterSpacing,\n                    chars: curLine,\n                });\n\n                lastSpace = null;\n                lastSpaceWidth = null;\n                curX = 0;\n                curLine = [];\n            } else {\n                let q = font.map[ch];\n\n                // TODO: leave space if character not found?\n                if (q) {\n                    let gw = q.w * scale.x;\n\n                    if (opt.width && curX + gw > opt.width) {\n                        // new line on last word if width exceeds\n                        th += size + lineSpacing;\n                        if (lastSpace != null) {\n                            cursor -= curLine.length - lastSpace;\n                            ch = chars[cursor];\n                            q = font.map[ch];\n                            gw = q.w * scale.x;\n                            // omit trailing space\n                            curLine = curLine.slice(0, lastSpace - 1);\n                            curX = lastSpaceWidth;\n                        }\n                        lastSpace = null;\n                        lastSpaceWidth = null;\n                        lines.push({\n                            width: curX - letterSpacing,\n                            chars: curLine,\n                        });\n                        curX = 0;\n                        curLine = [];\n                    }\n\n                    // push char\n                    curLine.push({\n                        tex: font.tex,\n                        width: q.w,\n                        height: q.h,\n                        // without some padding there'll be visual artifacts on edges\n                        quad: new Quad(\n                            q.x / font.tex.width,\n                            q.y / font.tex.height,\n                            q.w / font.tex.width,\n                            q.h / font.tex.height,\n                        ),\n                        ch: ch,\n                        pos: new Vec2(curX, th),\n                        opacity: opt.opacity ?? 1,\n                        color: opt.color ?? Color.WHITE,\n                        scale: vec2(scale),\n                        angle: 0,\n                    });\n\n                    if (ch === \" \") {\n                        lastSpace = curLine.length;\n                        lastSpaceWidth = curX;\n                    }\n\n                    curX += gw;\n                    tw = Math.max(tw, curX);\n                    curX += letterSpacing;\n                }\n            }\n\n            cursor++;\n        }\n\n        lines.push({\n            width: curX - letterSpacing,\n            chars: curLine,\n        });\n\n        th += size;\n\n        if (opt.width) {\n            tw = opt.width;\n        }\n\n        const fchars: FormattedChar[] = [];\n\n        for (let i = 0; i < lines.length; i++) {\n            const ox = (tw - lines[i].width) * alignPt(opt.align ?? \"left\");\n\n            for (const fchar of lines[i].chars) {\n                const q = font.map[fchar.ch];\n                const idx = fchars.length + i;\n\n                fchar.pos = fchar.pos.add(ox, 0).add(\n                    q.w * scale.x * 0.5,\n                    q.h * scale.y * 0.5,\n                );\n\n                if (opt.transform) {\n                    const tr = typeof opt.transform === \"function\"\n                        ? opt.transform(idx, fchar.ch)\n                        : opt.transform;\n                    if (tr) {\n                        applyCharTransform(fchar, tr);\n                    }\n                }\n\n                if (charStyleMap[idx]) {\n                    const styles = charStyleMap[idx];\n                    for (const name of styles) {\n                        const style = opt.styles[name];\n                        const tr = typeof style === \"function\"\n                            ? style(idx, fchar.ch)\n                            : style;\n                        if (tr) {\n                            applyCharTransform(fchar, tr);\n                        }\n                    }\n                }\n\n                fchars.push(fchar);\n            }\n        }\n\n        return {\n            width: tw,\n            height: th,\n            chars: fchars,\n            opt: opt,\n        };\n    }\n\n    function drawText(opt: DrawTextOpt) {\n        drawFormattedText(formatText(opt));\n    }\n\n    function drawFormattedText(ftext: FormattedText) {\n        pushTransform();\n        pushTranslate(ftext.opt.pos);\n        pushRotate(ftext.opt.angle);\n        pushTranslate(\n            anchorPt(ftext.opt.anchor ?? \"topleft\").add(1, 1).scale(\n                ftext.width,\n                ftext.height,\n            ).scale(-0.5),\n        );\n        ftext.chars.forEach((ch) => {\n            drawUVQuad({\n                tex: ch.tex,\n                width: ch.width,\n                height: ch.height,\n                pos: ch.pos,\n                scale: ch.scale,\n                angle: ch.angle,\n                color: ch.color,\n                opacity: ch.opacity,\n                quad: ch.quad,\n                anchor: \"center\",\n                uniform: ftext.opt.uniform,\n                shader: ftext.opt.shader,\n                fixed: ftext.opt.fixed,\n            });\n        });\n        popTransform();\n    }\n\n    // get game width\n    function width(): number {\n        return gfx.width;\n    }\n\n    // get game height\n    function height(): number {\n        return gfx.height;\n    }\n\n    // transform a point from window space to content space\n    function windowToContent(pt: Vec2) {\n        return new Vec2(\n            (pt.x - gfx.viewport.x) * width() / gfx.viewport.width,\n            (pt.y - gfx.viewport.y) * height() / gfx.viewport.height,\n        );\n    }\n\n    // transform a point from content space to view space\n    function contentToView(pt: Vec2) {\n        return new Vec2(\n            pt.x * gfx.viewport.width / gfx.width,\n            pt.y * gfx.viewport.height / gfx.height,\n        );\n    }\n\n    function mousePos() {\n        return windowToContent(app.mousePos());\n    }\n\n    let debugPaused = false;\n\n    const debug: Debug = {\n        inspect: false,\n        timeScale: 1,\n        showLog: true,\n        fps: () => app.fps(),\n        numFrames: () => app.numFrames(),\n        stepFrame: updateFrame,\n        drawCalls: () => gfx.lastDrawCalls,\n        clearLog: () => game.logs = [],\n        log: (msg) => {\n            const max = gopt.logMax ?? LOG_MAX;\n            game.logs.unshift({\n                msg: msg,\n                time: app.time(),\n            });\n            if (game.logs.length > max) {\n                game.logs = game.logs.slice(0, max);\n            }\n        },\n        error: (msg) =>\n            debug.log(new Error(msg.toString ? msg.toString() : msg as string)),\n        curRecording: null,\n        numObjects: () => get(\"*\", { recursive: true }).length,\n        get paused() {\n            return debugPaused;\n        },\n        set paused(v) {\n            debugPaused = v;\n            if (v) {\n                audio.ctx.suspend();\n            } else {\n                audio.ctx.resume();\n            }\n        },\n    };\n\n    function dt() {\n        return app.dt() * debug.timeScale;\n    }\n\n    function camPos(...pos: Vec2Args): Vec2 {\n        if (pos.length > 0) {\n            game.cam.pos = vec2(...pos);\n        }\n        return game.cam.pos ? game.cam.pos.clone() : center();\n    }\n\n    function camScale(...scale: Vec2Args): Vec2 {\n        if (scale.length > 0) {\n            game.cam.scale = vec2(...scale);\n        }\n        return game.cam.scale.clone();\n    }\n\n    function camRot(angle: number): number {\n        if (angle !== undefined) {\n            game.cam.angle = angle;\n        }\n        return game.cam.angle;\n    }\n\n    function shake(intensity: number = 12) {\n        game.cam.shake += intensity;\n    }\n\n    function toScreen(p: Vec2): Vec2 {\n        return game.cam.transform.multVec2(p);\n    }\n\n    function toWorld(p: Vec2): Vec2 {\n        return game.cam.transform.invert().multVec2(p);\n    }\n\n    function calcTransform(obj: GameObj): Mat4 {\n        const tr = new Mat4();\n        if (obj.pos) tr.translate(obj.pos);\n        if (obj.scale) tr.scale(obj.scale);\n        if (obj.angle) tr.rotate(obj.angle);\n        return obj.parent ? tr.mult(obj.parent.transform) : tr;\n    }\n\n    function make<T>(comps: CompList<T> = []): GameObj<T> {\n        const compStates = new Map();\n        const cleanups = {};\n        const events = new EventHandler();\n        const inputEvents: EventController[] = [];\n        let onCurCompCleanup = null;\n        let paused = false;\n\n        // @ts-ignore\n        const obj: GameObj = {\n            id: uid(),\n            // TODO: a nice way to hide / pause when add()-ing\n            hidden: false,\n            transform: new Mat4(),\n            children: [],\n            parent: null,\n\n            set paused(p) {\n                if (p === paused) return;\n                paused = p;\n                for (const e of inputEvents) {\n                    e.paused = p;\n                }\n            },\n\n            get paused() {\n                return paused;\n            },\n\n            add<T2>(a: CompList<T2> | GameObj<T2> = []): GameObj<T2> {\n                const obj = Array.isArray(a) ? make(a) : a;\n                if (obj.parent) {\n                    throw new Error(\n                        \"Cannot add a game obj that already has a parent.\",\n                    );\n                }\n                obj.parent = this;\n                obj.transform = calcTransform(obj);\n                this.children.push(obj);\n                // TODO: trigger add for children\n                obj.trigger(\"add\", obj);\n                game.events.trigger(\"add\", obj);\n                return obj;\n            },\n\n            readd(obj: GameObj): GameObj {\n                const idx = this.children.indexOf(obj);\n                if (idx !== -1) {\n                    this.children.splice(idx, 1);\n                    this.children.push(obj);\n                }\n                return obj;\n            },\n\n            remove(obj: GameObj): void {\n                const idx = this.children.indexOf(obj);\n                if (idx !== -1) {\n                    obj.parent = null;\n                    this.children.splice(idx, 1);\n                    const trigger = (o) => {\n                        o.trigger(\"destroy\");\n                        game.events.trigger(\"destroy\", o);\n                        o.children.forEach((child) => trigger(child));\n                    };\n                    trigger(obj);\n                }\n            },\n\n            // TODO: recursive\n            removeAll(tag?: Tag) {\n                if (tag) {\n                    this.get(tag).forEach((obj) => this.remove(obj));\n                } else {\n                    for (const child of [...this.children]) this.remove(child);\n                }\n            },\n\n            update() {\n                if (this.paused) return;\n                this.children\n                    .sort((o1, o2) => (o1.z ?? 0) - (o2.z ?? 0))\n                    .forEach((child) => child.update());\n                this.trigger(\"update\");\n            },\n\n            draw(\n                this: GameObj<\n                    PosComp | ScaleComp | RotateComp | FixedComp | MaskComp\n                >,\n            ) {\n                if (this.hidden) return;\n                if (this.canvas) {\n                    flush();\n                    this.canvas.bind();\n                }\n                const f = gfx.fixed;\n                if (this.fixed) gfx.fixed = true;\n                pushTransform();\n                pushTranslate(this.pos);\n                pushScale(this.scale);\n                pushRotate(this.angle);\n                const children = this.children.sort((o1, o2) =>\n                    (o1.z ?? 0) - (o2.z ?? 0)\n                );\n                // TODO: automatically don't draw if offscreen\n                if (this.mask) {\n                    const maskFunc = {\n                        intersect: drawMasked,\n                        subtract: drawSubtracted,\n                    }[this.mask];\n                    if (!maskFunc) {\n                        throw new Error(`Invalid mask func: \"${this.mask}\"`);\n                    }\n                    maskFunc(() => {\n                        children.forEach((child) => child.draw());\n                    }, () => {\n                        this.trigger(\"draw\");\n                    });\n                } else {\n                    this.trigger(\"draw\");\n                    children.forEach((child) => child.draw());\n                }\n                popTransform();\n                gfx.fixed = f;\n                if (this.canvas) {\n                    flush();\n                    this.canvas.unbind();\n                }\n            },\n\n            drawInspect(this: GameObj<PosComp | ScaleComp | RotateComp>) {\n                if (this.hidden) return;\n                pushTransform();\n                pushTranslate(this.pos);\n                pushScale(this.scale);\n                pushRotate(this.angle);\n                this.children\n                    .sort((o1, o2) => (o1.z ?? 0) - (o2.z ?? 0))\n                    .forEach((child) => child.drawInspect());\n                this.trigger(\"drawInspect\");\n                popTransform();\n            },\n\n            // use a comp, or tag\n            use(comp: Comp | Tag) {\n                if (!comp) {\n                    return;\n                }\n\n                // tag\n                if (typeof comp === \"string\") {\n                    return this.use({\n                        id: comp,\n                    });\n                }\n\n                let gc = [];\n\n                // clear if overwrite\n                if (comp.id) {\n                    this.unuse(comp.id);\n                    cleanups[comp.id] = [];\n                    gc = cleanups[comp.id];\n                    compStates.set(comp.id, comp);\n                }\n\n                for (const k in comp) {\n                    if (COMP_DESC.has(k)) {\n                        continue;\n                    }\n\n                    const prop = Object.getOwnPropertyDescriptor(comp, k);\n\n                    if (typeof prop.value === \"function\") {\n                        comp[k] = comp[k].bind(this);\n                    }\n\n                    if (prop.set) {\n                        Object.defineProperty(comp, k, {\n                            set: prop.set.bind(this),\n                        });\n                    }\n\n                    if (prop.get) {\n                        Object.defineProperty(comp, k, {\n                            get: prop.get.bind(this),\n                        });\n                    }\n\n                    if (COMP_EVENTS.has(k)) {\n                        // automatically clean up events created by components in add() stage\n                        const func = k === \"add\"\n                            ? () => {\n                                onCurCompCleanup = (c) => gc.push(c);\n                                comp[k]();\n                                onCurCompCleanup = null;\n                            }\n                            : comp[k];\n                        gc.push(this.on(k, func).cancel);\n                    } else {\n                        if (this[k] === undefined) {\n                            // assign comp fields to game obj\n                            Object.defineProperty(this, k, {\n                                get: () => comp[k],\n                                set: (val) => comp[k] = val,\n                                configurable: true,\n                                enumerable: true,\n                            });\n                            gc.push(() => delete this[k]);\n                        } else {\n                            throw new Error(\n                                `Duplicate component property: \"${k}\"`,\n                            );\n                        }\n                    }\n                }\n\n                // check for component dependencies\n                const checkDeps = () => {\n                    if (!comp.require) return;\n                    for (const dep of comp.require) {\n                        if (!this.c(dep)) {\n                            throw new Error(\n                                `Component \"${comp.id}\" requires component \"${dep}\"`,\n                            );\n                        }\n                    }\n                };\n\n                if (comp.destroy) {\n                    gc.push(comp.destroy.bind(this));\n                }\n\n                // manually trigger add event if object already exist\n                if (this.exists()) {\n                    checkDeps();\n                    if (comp.add) {\n                        onCurCompCleanup = (c) => gc.push(c);\n                        comp.add.call(this);\n                        onCurCompCleanup = null;\n                    }\n                } else {\n                    if (comp.require) {\n                        gc.push(this.on(\"add\", checkDeps).cancel);\n                    }\n                }\n            },\n\n            unuse(id: Tag) {\n                if (cleanups[id]) {\n                    cleanups[id].forEach((e) => e());\n                    delete cleanups[id];\n                }\n                if (compStates.has(id)) {\n                    compStates.delete(id);\n                }\n            },\n\n            c(id: Tag): Comp {\n                return compStates.get(id);\n            },\n\n            get(t: Tag | Tag[], opts: GetOpt = {}): GameObj[] {\n                let list: GameObj[] = opts.recursive\n                    ? this.children.flatMap(function recurse(child) {\n                        return [child, ...child.children.flatMap(recurse)];\n                    })\n                    : this.children;\n                list = list.filter((child) => t ? child.is(t) : true);\n                if (opts.liveUpdate) {\n                    const isChild = (obj) => {\n                        return opts.recursive\n                            ? this.isAncestorOf(obj)\n                            : obj.parent === this;\n                    };\n                    const events = [];\n                    // TODO: handle when object add / remove tags\n                    // TODO: clean up when obj destroyed\n                    events.push(onAdd((obj) => {\n                        if (isChild(obj) && obj.is(t)) {\n                            list.push(obj);\n                        }\n                    }));\n                    events.push(onDestroy((obj) => {\n                        if (isChild(obj) && obj.is(t)) {\n                            const idx = list.findIndex((o) => o.id === obj.id);\n                            if (idx !== -1) {\n                                list.splice(idx, 1);\n                            }\n                        }\n                    }));\n                    this.onDestroy(() => {\n                        for (const ev of events) {\n                            ev.cancel();\n                        }\n                    });\n                }\n                return list;\n            },\n\n            isAncestorOf(obj: GameObj) {\n                if (!obj.parent) {\n                    return false;\n                }\n                return obj.parent === this || this.isAncestorOf(obj.parent);\n            },\n\n            exists(): boolean {\n                return game.root.isAncestorOf(this);\n            },\n\n            is(tag: Tag | Tag[]): boolean {\n                if (tag === \"*\") {\n                    return true;\n                }\n                if (Array.isArray(tag)) {\n                    for (const t of tag) {\n                        if (!this.c(t)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                } else {\n                    return this.c(tag) != null;\n                }\n            },\n\n            on(name: string, action: (...args) => void): EventController {\n                const ctrl = events.on(name, action.bind(this));\n                if (onCurCompCleanup) {\n                    onCurCompCleanup(() => ctrl.cancel());\n                }\n                return ctrl;\n            },\n\n            trigger(name: string, ...args): void {\n                events.trigger(name, ...args);\n                game.objEvents.trigger(name, this, ...args);\n            },\n\n            destroy() {\n                if (this.parent) {\n                    this.parent.remove(this);\n                }\n            },\n\n            inspect() {\n                const info = {};\n                for (const [tag, comp] of compStates) {\n                    info[tag] = comp.inspect ? comp.inspect() : null;\n                }\n                return info;\n            },\n\n            onAdd(cb: () => void): EventController {\n                return this.on(\"add\", cb);\n            },\n\n            onUpdate(cb: () => void): EventController {\n                return this.on(\"update\", cb);\n            },\n\n            onDraw(cb: () => void): EventController {\n                return this.on(\"draw\", cb);\n            },\n\n            onDestroy(action: () => void): EventController {\n                return this.on(\"destroy\", action);\n            },\n\n            clearEvents() {\n                events.clear();\n            },\n        };\n\n        // TODO: type with as const\n        const evs = [\n            \"onKeyPress\",\n            \"onKeyPressRepeat\",\n            \"onKeyDown\",\n            \"onKeyRelease\",\n            \"onMousePress\",\n            \"onMouseDown\",\n            \"onMouseRelease\",\n            \"onMouseMove\",\n            \"onCharInput\",\n            \"onMouseMove\",\n            \"onTouchStart\",\n            \"onTouchMove\",\n            \"onTouchEnd\",\n            \"onScroll\",\n            \"onGamepadButtonPress\",\n            \"onGamepadButtonDown\",\n            \"onGamepadButtonRelease\",\n            \"onGamepadStick\",\n        ];\n\n        for (const e of evs) {\n            obj[e] = (...args) => {\n                const ev = app[e](...args);\n                inputEvents.push(ev);\n                // TODO: what if the game object is destroy and re-added\n                obj.onDestroy(() => ev.cancel());\n                return ev;\n            };\n        }\n\n        for (const comp of comps) {\n            obj.use(comp);\n        }\n\n        return obj as unknown as GameObj<T>;\n    }\n\n    // add an event to a tag\n    function on(\n        event: string,\n        tag: Tag,\n        cb: (obj: GameObj, ...args) => void,\n    ): EventController {\n        if (!game.objEvents[event]) {\n            game.objEvents[event] = new Registry();\n        }\n        return game.objEvents.on(event, (obj, ...args) => {\n            if (obj.is(tag)) {\n                cb(obj, ...args);\n            }\n        });\n    }\n\n    const onUpdate = overload2((action: () => void): EventController => {\n        const obj = add([{ update: action }]);\n        return {\n            get paused() {\n                return obj.paused;\n            },\n            set paused(p) {\n                obj.paused = p;\n            },\n            cancel: () => obj.destroy(),\n        };\n    }, (tag: Tag, action: (obj: GameObj) => void) => {\n        return on(\"update\", tag, action);\n    });\n\n    const onDraw = overload2((action: () => void): EventController => {\n        const obj = add([{ draw: action }]);\n        return {\n            get paused() {\n                return obj.hidden;\n            },\n            set paused(p) {\n                obj.hidden = p;\n            },\n            cancel: () => obj.destroy(),\n        };\n    }, (tag: Tag, action: (obj: GameObj) => void) => {\n        return on(\"draw\", tag, action);\n    });\n\n    const onAdd = overload2((action: (obj: GameObj) => void) => {\n        return game.events.on(\"add\", action);\n    }, (tag: Tag, action: (obj: GameObj) => void) => {\n        return on(\"add\", tag, action);\n    });\n\n    const onDestroy = overload2((action: (obj: GameObj) => void) => {\n        return game.events.on(\"destroy\", action);\n    }, (tag: Tag, action: (obj: GameObj) => void) => {\n        return on(\"destroy\", tag, action);\n    });\n\n    // add an event that runs with objs with t1 collides with objs with t2\n    function onCollide(\n        t1: Tag,\n        t2: Tag,\n        f: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController {\n        return on(\"collide\", t1, (a, b, col) => b.is(t2) && f(a, b, col));\n    }\n\n    function onCollideUpdate(\n        t1: Tag,\n        t2: Tag,\n        f: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController {\n        return on(\"collideUpdate\", t1, (a, b, col) => b.is(t2) && f(a, b, col));\n    }\n\n    function onCollideEnd(\n        t1: Tag,\n        t2: Tag,\n        f: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController {\n        return on(\"collideEnd\", t1, (a, b, col) => b.is(t2) && f(a, b, col));\n    }\n\n    function forAllCurrentAndFuture(t: Tag, action: (obj: GameObj) => void) {\n        get(t, { recursive: true }).forEach(action);\n        onAdd(t, action);\n    }\n\n    const onClick = overload2((action: () => void) => {\n        return app.onMousePress(action);\n    }, (tag: Tag, action: (obj: GameObj) => void) => {\n        const events = [];\n        forAllCurrentAndFuture(tag, (obj) => {\n            if (!obj.area) {\n                throw new Error(\n                    \"onClick() requires the object to have area() component\",\n                );\n            }\n            events.push(obj.onClick(() => action(obj)));\n        });\n        return EventController.join(events);\n    });\n\n    // add an event that runs once when objs with tag t is hovered\n    function onHover(t: Tag, action: (obj: GameObj) => void): EventController {\n        const events = [];\n        forAllCurrentAndFuture(t, (obj) => {\n            if (!obj.area) {\n                throw new Error(\n                    \"onHover() requires the object to have area() component\",\n                );\n            }\n            events.push(obj.onHover(() => action(obj)));\n        });\n        return EventController.join(events);\n    }\n\n    // add an event that runs once when objs with tag t is hovered\n    function onHoverUpdate(\n        t: Tag,\n        action: (obj: GameObj) => void,\n    ): EventController {\n        const events = [];\n        forAllCurrentAndFuture(t, (obj) => {\n            if (!obj.area) {\n                throw new Error(\n                    \"onHoverUpdate() requires the object to have area() component\",\n                );\n            }\n            events.push(obj.onHoverUpdate(() => action(obj)));\n        });\n        return EventController.join(events);\n    }\n\n    // add an event that runs once when objs with tag t is unhovered\n    function onHoverEnd(\n        t: Tag,\n        action: (obj: GameObj) => void,\n    ): EventController {\n        const events = [];\n        forAllCurrentAndFuture(t, (obj) => {\n            if (!obj.area) {\n                throw new Error(\n                    \"onHoverEnd() requires the object to have area() component\",\n                );\n            }\n            events.push(obj.onHoverEnd(() => action(obj)));\n        });\n        return EventController.join(events);\n    }\n\n    function setGravity(g: number) {\n        game.gravity = game.gravity.unit().scale(g);\n    }\n\n    function getGravity() {\n        return game.gravity.len();\n    }\n\n    function setGravityDirection(d: Vec2) {\n        game.gravity = d.unit().scale(game.gravity.len());\n    }\n\n    function getGravityDirection() {\n        return game.gravity.unit();\n    }\n\n    function setBackground(...args) {\n        if (args.length === 1 || args.length === 2) {\n            gfx.bgColor = rgb(args[0]);\n            if (args[1]) gfx.bgAlpha = args[1];\n        } else if (args.length === 3 || args.length === 4) {\n            gfx.bgColor = rgb(args[0], args[1], args[2]);\n            if (args[3]) gfx.bgAlpha = args[3];\n        }\n        gl.clearColor(\n            gfx.bgColor.r / 255,\n            gfx.bgColor.g / 255,\n            gfx.bgColor.b / 255,\n            gfx.bgAlpha,\n        );\n    }\n\n    function getBackground() {\n        return gfx.bgColor.clone();\n    }\n\n    function color(...args): ColorComp {\n        return {\n            id: \"color\",\n            color: rgb(...args),\n            inspect() {\n                return this.color.toString();\n            },\n        };\n    }\n\n    function toFixed(n: number, f: number) {\n        return Number(n.toFixed(f));\n    }\n\n    function isFixed(obj: GameObj) {\n        if (obj.fixed) return true;\n        return obj.parent ? isFixed(obj.parent) : false;\n    }\n\n    function getRenderProps(obj: GameObj<any>) {\n        return {\n            color: obj.color,\n            opacity: obj.opacity,\n            anchor: obj.anchor,\n            outline: obj.outline,\n            shader: obj.shader,\n            uniform: obj.uniform,\n        };\n    }\n\n    function onLoad(cb: () => void): void {\n        if (assets.loaded) {\n            cb();\n        } else {\n            game.events.on(\"load\", cb);\n        }\n    }\n\n    function scene(id: SceneName, def: SceneDef) {\n        game.scenes[id] = def;\n    }\n\n    function go(name: SceneName, ...args) {\n        if (!game.scenes[name]) {\n            throw new Error(`Scene not found: ${name}`);\n        }\n\n        game.events.onOnce(\"frameEnd\", () => {\n            game.events.trigger(\"sceneLeave\", name);\n            app.events.clear();\n            game.events.clear();\n            game.objEvents.clear();\n            [...game.root.children].forEach((obj) => {\n                if (\n                    !obj.stay\n                    || (obj.scenesToStay && !obj.scenesToStay.includes(name))\n                ) {\n                    game.root.remove(obj);\n                }\n            });\n\n            game.root.clearEvents();\n            initEvents();\n\n            // cam\n            game.cam = {\n                pos: null,\n                scale: vec2(1),\n                angle: 0,\n                shake: 0,\n                transform: new Mat4(),\n            };\n\n            game.scenes[name](...args);\n        });\n\n        game.currentScene = name;\n    }\n\n    function onSceneLeave(\n        action: (newScene?: string) => void,\n    ): EventController {\n        return game.events.on(\"sceneLeave\", action);\n    }\n\n    function getSceneName() {\n        return game.currentScene;\n    }\n\n    function getData<T>(key: string, def?: T): T {\n        try {\n            return JSON.parse(window.localStorage[key]);\n        } catch {\n            if (def) {\n                setData(key, def);\n                return def;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    function setData(key: string, data: any) {\n        window.localStorage[key] = JSON.stringify(data);\n    }\n\n    function plug<T extends Record<string, any>>(\n        plugin: KaboomPlugin<T>,\n        ...args: any\n    ): KaboomCtx & T {\n        const funcs = plugin(ctx);\n        let funcsObj: T;\n        if (typeof funcs === \"function\") {\n            const plugWithOptions = funcs(...args);\n            funcsObj = plugWithOptions(ctx);\n        } else {\n            funcsObj = funcs;\n        }\n        for (const k in funcsObj) {\n            // @ts-ignore\n            ctx[k] = funcsObj[k];\n            if (gopt.global !== false) {\n                // @ts-ignore\n                window[k] = funcsObj[k];\n            }\n        }\n        return ctx as KaboomCtx & T;\n    }\n\n    function center(): Vec2 {\n        return vec2(width() / 2, height() / 2);\n    }\n\n    enum EdgeMask {\n        None = 0,\n        Left = 1,\n        Top = 2,\n        LeftTop = 3,\n        Right = 4,\n        Horizontal = 5,\n        RightTop = 6,\n        HorizontalTop = 7,\n        Bottom = 8,\n        LeftBottom = 9,\n        Vertical = 10,\n        LeftVertical = 11,\n        RightBottom = 12,\n        HorizontalBottom = 13,\n        RightVertical = 14,\n        All = 15,\n    }\n\n    function addLevel(\n        map: string[],\n        opt: LevelOpt,\n    ): GameObj<PosComp | LevelComp> {\n        if (!opt.tileWidth || !opt.tileHeight) {\n            throw new Error(\"Must provide tileWidth and tileHeight.\");\n        }\n\n        // TODO: custom parent\n        const level = add([\n            pos(opt.pos ?? vec2(0)),\n        ]) as GameObj<PosComp | LevelComp>;\n\n        const numRows = map.length;\n        let numColumns = 0;\n\n        // The spatial map keeps track of the objects at each location\n        let spatialMap: GameObj[][] | null = null;\n        let costMap: number[] | null = null;\n        let edgeMap: number[] | null = null;\n        let connectivityMap: number[] | null = null;\n\n        const tile2Hash = (tilePos: Vec2) => tilePos.x + tilePos.y * numColumns;\n        const hash2Tile = (hash: number) =>\n            vec2(\n                Math.floor(hash % numColumns),\n                Math.floor(hash / numColumns),\n            );\n\n        const createSpatialMap = () => {\n            spatialMap = [];\n            for (const child of level.children) {\n                insertIntoSpatialMap(child);\n            }\n        };\n\n        const insertIntoSpatialMap = (obj: GameObj) => {\n            const i = tile2Hash(obj.tilePos);\n            if (spatialMap[i]) {\n                spatialMap[i].push(obj);\n            } else {\n                spatialMap[i] = [obj];\n            }\n        };\n\n        const removeFromSpatialMap = (obj: GameObj) => {\n            const i = tile2Hash(obj.tilePos);\n            if (spatialMap[i]) {\n                const index = spatialMap[i].indexOf(obj);\n                if (index >= 0) {\n                    spatialMap[i].splice(index, 1);\n                }\n            }\n        };\n\n        const updateSpatialMap = () => {\n            let spatialMapChanged = false;\n            for (const child of level.children) {\n                const tilePos = level.pos2Tile(child.pos);\n                if (\n                    child.tilePos.x != tilePos.x || child.tilePos.y != tilePos.y\n                ) {\n                    spatialMapChanged = true;\n                    removeFromSpatialMap(child);\n                    child.tilePos.x = tilePos.x;\n                    child.tilePos.y = tilePos.y;\n                    insertIntoSpatialMap(child);\n                }\n            }\n            if (spatialMapChanged) {\n                level.trigger(\"spatial_map_changed\");\n            }\n        };\n\n        // The obstacle map tells which tiles are accessible\n        // Cost: accessible with cost\n        // Infinite: inaccessible\n        const createCostMap = () => {\n            const spatialMap = level.getSpatialMap();\n            const size = level.numRows() * level.numColumns();\n            if (!costMap) {\n                costMap = new Array<number>(size);\n            } else {\n                costMap.length = size;\n            }\n            costMap.fill(1, 0, size);\n            for (let i = 0; i < spatialMap.length; i++) {\n                const objects = spatialMap[i];\n                if (objects) {\n                    let cost = 0;\n                    for (const obj of objects) {\n                        if (obj.isObstacle) {\n                            cost = Infinity;\n                            break;\n                        } else {\n                            cost += obj.cost;\n                        }\n                    }\n                    costMap[i] = cost || 1;\n                }\n            }\n        };\n\n        // The edge map tells which edges between nodes are walkable\n        const createEdgeMap = () => {\n            const spatialMap = level.getSpatialMap();\n            const size = level.numRows() * level.numColumns();\n            if (!edgeMap) {\n                edgeMap = new Array<number>(size);\n            } else {\n                edgeMap.length = size;\n            }\n            edgeMap.fill(EdgeMask.All, 0, size);\n            for (let i = 0; i < spatialMap.length; i++) {\n                const objects = spatialMap[i];\n                if (objects) {\n                    const len = objects.length;\n                    let mask = EdgeMask.All;\n                    for (let j = 0; j < len; j++) {\n                        mask |= objects[j].edgeMask;\n                    }\n                    edgeMap[i] = mask;\n                }\n            }\n        };\n\n        // The connectivity map is used to see whether two locations are connected\n        // -1: inaccesible n: connectivity group\n        const createConnectivityMap = () => {\n            const size = level.numRows() * level.numColumns();\n            const traverse = (i: number, index: number) => {\n                const frontier: number[] = [];\n                frontier.push(i);\n                while (frontier.length > 0) {\n                    const i = frontier.pop();\n                    getNeighbours(i).forEach((i) => {\n                        if (connectivityMap[i] < 0) {\n                            connectivityMap[i] = index;\n                            frontier.push(i);\n                        }\n                    });\n                }\n            };\n            if (!connectivityMap) {\n                connectivityMap = new Array<number>(size);\n            } else {\n                connectivityMap.length = size;\n            }\n            connectivityMap.fill(-1, 0, size);\n            let index = 0;\n            for (let i = 0; i < costMap.length; i++) {\n                if (connectivityMap[i] >= 0) {\n                    index++;\n                    continue;\n                }\n                traverse(i, index);\n                index++;\n            }\n        };\n\n        const getCost = (node: number, neighbour: number) => {\n            // Cost of destination tile\n            return costMap[neighbour];\n        };\n\n        const getHeuristic = (node: number, goal: number) => {\n            // Euclidian distance to target\n            const p1 = hash2Tile(node);\n            const p2 = hash2Tile(goal);\n            return p1.dist(p2);\n        };\n\n        const getNeighbours = (node: number, diagonals?: boolean) => {\n            const n = [];\n            const x = Math.floor(node % numColumns);\n            const left = x > 0\n                && (edgeMap[node] & EdgeMask.Left)\n                && costMap[node - 1] !== Infinity;\n            const top = node >= numColumns\n                && (edgeMap[node] & EdgeMask.Top)\n                && costMap[node - numColumns] !== Infinity;\n            const right = x < numColumns - 1\n                && (edgeMap[node] & EdgeMask.Right)\n                && costMap[node + 1] !== Infinity;\n            const bottom = node < numColumns * numRows - numColumns - 1\n                && (edgeMap[node] & EdgeMask.Bottom)\n                && costMap[node + numColumns] !== Infinity;\n            if (diagonals) {\n                if (left) {\n                    if (top) n.push(node - numColumns - 1);\n                    n.push(node - 1);\n                    if (bottom) n.push(node + numColumns - 1);\n                }\n                if (top) {\n                    n.push(node - numColumns);\n                }\n                if (right) {\n                    if (top) n.push(node - numColumns + 1);\n                    n.push(node + 1);\n                    if (bottom) n.push(node + numColumns + 1);\n                }\n                if (bottom) {\n                    n.push(node + numColumns);\n                }\n            } else {\n                if (left) {\n                    n.push(node - 1);\n                }\n                if (top) {\n                    n.push(node - numColumns);\n                }\n                if (right) {\n                    n.push(node + 1);\n                }\n                if (bottom) {\n                    n.push(node + numColumns);\n                }\n            }\n            return n;\n        };\n\n        const levelComp: LevelComp = {\n            id: \"level\",\n\n            tileWidth() {\n                return opt.tileWidth;\n            },\n\n            tileHeight() {\n                return opt.tileHeight;\n            },\n\n            spawn(\n                this: GameObj<LevelComp>,\n                key: string | CompList<any>,\n                ...args: Vec2Args\n            ): GameObj | null {\n                const p = vec2(...args);\n\n                const comps = (() => {\n                    if (typeof key === \"string\") {\n                        if (opt.tiles[key]) {\n                            if (typeof opt.tiles[key] !== \"function\") {\n                                throw new Error(\n                                    \"Level symbol def must be a function returning a component list\",\n                                );\n                            }\n                            return opt.tiles[key](p);\n                        } else if (opt.wildcardTile) {\n                            return opt.wildcardTile(key, p);\n                        }\n                    } else if (Array.isArray(key)) {\n                        return key;\n                    } else {\n                        throw new Error(\n                            \"Expected a symbol or a component list\",\n                        );\n                    }\n                })();\n\n                // empty tile\n                if (!comps) {\n                    return null;\n                }\n\n                let hasPos = false;\n                let hasTile = false;\n\n                for (const comp of comps) {\n                    if (comp.id === \"tile\") hasTile = true;\n                    if (comp.id === \"pos\") hasPos = true;\n                }\n\n                if (!hasPos) comps.push(pos());\n                if (!hasTile) comps.push(tile());\n\n                const obj = level.add(comps);\n\n                if (hasPos) {\n                    obj.tilePosOffset = obj.pos.clone();\n                }\n\n                obj.tilePos = p;\n\n                if (spatialMap) {\n                    insertIntoSpatialMap(obj);\n                    this.trigger(\"spatial_map_changed\");\n                    this.trigger(\"navigation_map_invalid\");\n                }\n\n                return obj;\n            },\n\n            numColumns() {\n                return numColumns;\n            },\n\n            numRows() {\n                return numRows;\n            },\n\n            levelWidth() {\n                return numColumns * this.tileWidth();\n            },\n\n            levelHeight() {\n                return numRows * this.tileHeight();\n            },\n\n            tile2Pos(...args: Vec2Args) {\n                return vec2(...args).scale(this.tileWidth(), this.tileHeight());\n            },\n\n            pos2Tile(...args: Vec2Args) {\n                const p = vec2(...args);\n                return vec2(\n                    Math.floor(p.x / this.tileWidth()),\n                    Math.floor(p.y / this.tileHeight()),\n                );\n            },\n\n            getSpatialMap() {\n                if (!spatialMap) {\n                    createSpatialMap();\n                }\n                return spatialMap;\n            },\n\n            onSpatialMapChanged(this: GameObj<LevelComp>, cb: () => void) {\n                return this.on(\"spatial_map_changed\", cb);\n            },\n\n            onNavigationMapInvalid(this: GameObj<LevelComp>, cb: () => void) {\n                return this.on(\"navigation_map_invalid\", cb);\n            },\n\n            getAt(tilePos: Vec2) {\n                if (!spatialMap) {\n                    createSpatialMap();\n                }\n                const hash = tile2Hash(tilePos);\n                return spatialMap[hash] || [];\n            },\n\n            raycast(origin: Vec2, direction: Vec2) {\n                origin = origin.scale(\n                    1 / this.tileWidth(),\n                    1 / this.tileHeight(),\n                );\n                const hit = raycastGrid(origin, direction, (tilePos: Vec2) => {\n                    const tiles = this.getAt(tilePos);\n                    if (tiles.some(t => t.isObstacle)) {\n                        return true;\n                    }\n                }, 64);\n                if (hit) {\n                    hit.point = hit.point.scale(\n                        this.tileWidth(),\n                        this.tileHeight(),\n                    );\n                }\n                return hit;\n            },\n\n            update() {\n                if (spatialMap) {\n                    updateSpatialMap();\n                }\n            },\n\n            invalidateNavigationMap() {\n                costMap = null;\n                edgeMap = null;\n                connectivityMap = null;\n            },\n\n            onNavigationMapChanged(this: GameObj<LevelComp>, cb: () => void) {\n                return this.on(\"navigation_map_changed\", cb);\n            },\n\n            getTilePath(\n                this: GameObj<LevelComp>,\n                from: Vec2,\n                to: Vec2,\n                opts: PathFindOpt = {},\n            ) {\n                if (!costMap) {\n                    createCostMap();\n                }\n                if (!edgeMap) {\n                    createEdgeMap();\n                }\n                if (!connectivityMap) {\n                    createConnectivityMap();\n                }\n\n                // Tiles are outside the grid\n                if (\n                    from.x < 0 || from.x >= numColumns\n                    || from.y < 0 || from.y >= numRows\n                ) {\n                    return null;\n                }\n                if (\n                    to.x < 0 || to.x >= numColumns\n                    || to.y < 0 || to.y >= numRows\n                ) {\n                    return null;\n                }\n\n                const start = tile2Hash(from);\n                const goal = tile2Hash(to);\n\n                // Tiles are not accessible\n                // If we test the start tile, we may get stuck\n                /*if (costMap[start] === Infinity) {\n\t\t\t\t\treturn null\n\t\t\t\t}*/\n                if (costMap[goal] === Infinity) {\n                    return null;\n                }\n\n                // Same Tile, no waypoints needed\n                if (start === goal) {\n                    return [];\n                }\n\n                // Tiles are not within the same section\n                // If we test the start tile when invalid, we may get stuck\n                if (\n                    connectivityMap[start] != -1\n                    && connectivityMap[start] !== connectivityMap[goal]\n                ) {\n                    return null;\n                }\n\n                // Find a path\n                interface CostNode {\n                    cost: number;\n                    node: number;\n                }\n                const frontier = new BinaryHeap<CostNode>((a, b) =>\n                    a.cost < b.cost\n                );\n                frontier.insert({ cost: 0, node: start });\n\n                const cameFrom = new Map<number, number>();\n                cameFrom.set(start, start);\n                const costSoFar = new Map<number, number>();\n                costSoFar.set(start, 0);\n\n                while (frontier.length !== 0) {\n                    const current = frontier.remove()?.node;\n\n                    if (current === goal) {\n                        break;\n                    }\n\n                    const neighbours = getNeighbours(\n                        current,\n                        opts.allowDiagonals,\n                    );\n                    for (const next of neighbours) {\n                        const newCost = (costSoFar.get(current) || 0)\n                            + getCost(current, next)\n                            + getHeuristic(next, goal);\n                        if (\n                            !costSoFar.has(next)\n                            || newCost < costSoFar.get(next)\n                        ) {\n                            costSoFar.set(next, newCost);\n                            frontier.insert({ cost: newCost, node: next });\n                            cameFrom.set(next, current);\n                        }\n                    }\n                }\n\n                const path = [];\n                let node = goal;\n                const p = hash2Tile(node);\n                path.push(p);\n                while (node !== start) {\n                    node = cameFrom.get(node);\n                    const p = hash2Tile(node);\n                    path.push(p);\n                }\n                return path.reverse();\n            },\n\n            getPath(\n                this: GameObj<LevelComp>,\n                from: Vec2,\n                to: Vec2,\n                opts: PathFindOpt = {},\n            ) {\n                const tw = this.tileWidth();\n                const th = this.tileHeight();\n                const path = this.getTilePath(\n                    this.pos2Tile(from),\n                    this.pos2Tile(to),\n                    opts,\n                );\n                if (path) {\n                    return [\n                        from,\n                        ...path\n                            .slice(1, -1)\n                            .map((tilePos) =>\n                                tilePos.scale(tw, th).add(tw / 2, th / 2)\n                            ),\n                        to,\n                    ];\n                } else {\n                    return null;\n                }\n            },\n        };\n\n        level.use(levelComp);\n\n        level.onNavigationMapInvalid(() => {\n            level.invalidateNavigationMap();\n            level.trigger(\"navigation_map_changed\");\n        });\n\n        map.forEach((row, i) => {\n            const keys = row.split(\"\");\n            numColumns = Math.max(keys.length, numColumns);\n            keys.forEach((key, j) => {\n                level.spawn(key, vec2(j, i));\n            });\n        });\n\n        return level;\n    }\n\n    type RaycastHit = BaseRaycastHit & {\n        object?: GameObj;\n    };\n\n    type RaycastResult = RaycastHit | null;\n\n    function record(frameRate?): Recording {\n        const stream = app.canvas.captureStream(frameRate);\n        const audioDest = audio.ctx.createMediaStreamDestination();\n\n        audio.masterNode.connect(audioDest);\n\n        // TODO: Enabling audio results in empty video if no audio received\n        // const audioStream = audioDest.stream\n        // const [firstAudioTrack] = audioStream.getAudioTracks()\n\n        // stream.addTrack(firstAudioTrack);\n\n        const recorder = new MediaRecorder(stream);\n        const chunks = [];\n\n        recorder.ondataavailable = (e) => {\n            if (e.data.size > 0) {\n                chunks.push(e.data);\n            }\n        };\n\n        recorder.onerror = () => {\n            audio.masterNode.disconnect(audioDest);\n            stream.getTracks().forEach(t => t.stop());\n        };\n\n        recorder.start();\n\n        return {\n            resume() {\n                recorder.resume();\n            },\n\n            pause() {\n                recorder.pause();\n            },\n\n            stop(): Promise<Blob> {\n                recorder.stop();\n                // cleanup\n                audio.masterNode.disconnect(audioDest);\n                stream.getTracks().forEach(t => t.stop());\n                return new Promise((resolve) => {\n                    recorder.onstop = () => {\n                        resolve(\n                            new Blob(chunks, {\n                                type: \"video/mp4\",\n                            }),\n                        );\n                    };\n                });\n            },\n\n            download(filename = \"kaboom.mp4\") {\n                this.stop().then((blob) => downloadBlob(filename, blob));\n            },\n        };\n    }\n\n    function isFocused(): boolean {\n        return document.activeElement === app.canvas;\n    }\n\n    function destroy(obj: GameObj) {\n        obj.destroy();\n    }\n\n    // aliases for root game obj operations\n    const add = game.root.add.bind(game.root);\n    const readd = game.root.readd.bind(game.root);\n    const destroyAll = game.root.removeAll.bind(game.root);\n    const get = game.root.get.bind(game.root);\n    const wait = game.root.wait.bind(game.root);\n    const loop = game.root.loop.bind(game.root);\n    const tween = game.root.tween.bind(game.root);\n\n    function boom(speed: number = 2, size: number = 1): Comp {\n        let time = 0;\n        return {\n            require: [\"scale\"],\n            update(this: GameObj<ScaleComp>) {\n                const s = Math.sin(time * speed) * size;\n                if (s < 0) {\n                    this.destroy();\n                }\n                this.scale = vec2(s);\n                time += dt();\n            },\n        };\n    }\n\n    const kaSprite = loadSprite(null, kaSpriteSrc);\n    const boomSprite = loadSprite(null, boomSpriteSrc);\n\n    function addKaboom(p: Vec2, opt: BoomOpt = {}): GameObj {\n        const kaboom = add([\n            pos(p),\n            stay(),\n        ]);\n\n        const speed = (opt.speed || 1) * 5;\n        const s = opt.scale || 1;\n\n        kaboom.add([\n            sprite(boomSprite),\n            scale(0),\n            anchor(\"center\"),\n            boom(speed, s),\n            ...opt.comps ?? [],\n        ]);\n\n        const ka = kaboom.add([\n            sprite(kaSprite),\n            scale(0),\n            anchor(\"center\"),\n            timer(),\n            ...opt.comps ?? [],\n        ]);\n\n        ka.wait(0.4 / speed, () => ka.use(boom(speed, s)));\n        ka.onDestroy(() => kaboom.destroy());\n\n        return kaboom;\n    }\n\n    function updateFrame() {\n        // update every obj\n        game.root.update();\n    }\n\n    class Collision {\n        source: GameObj;\n        target: GameObj;\n        displacement: Vec2;\n        resolved: boolean = false;\n        constructor(\n            source: GameObj,\n            target: GameObj,\n            dis: Vec2,\n            resolved = false,\n        ) {\n            this.source = source;\n            this.target = target;\n            this.displacement = dis;\n            this.resolved = resolved;\n        }\n        reverse() {\n            return new Collision(\n                this.target,\n                this.source,\n                this.displacement.scale(-1),\n                this.resolved,\n            );\n        }\n        hasOverlap() {\n            return !this.displacement.isZero();\n        }\n        isLeft() {\n            return this.displacement.cross(game.gravity) > 0;\n        }\n        isRight() {\n            return this.displacement.cross(game.gravity) < 0;\n        }\n        isTop() {\n            return this.displacement.dot(game.gravity) > 0;\n        }\n        isBottom() {\n            return this.displacement.dot(game.gravity) < 0;\n        }\n        preventResolution() {\n            this.resolved = true;\n        }\n    }\n\n    function checkFrame() {\n        // TODO: persistent grid?\n        // start a spatial hash grid for more efficient collision detection\n        const grid: Record<number, Record<number, GameObj<AreaComp>[]>> = {};\n        const cellSize = gopt.hashGridSize || DEF_HASH_GRID_SIZE;\n\n        // current transform\n        let tr = new Mat4();\n\n        // a local transform stack\n        const stack = [];\n\n        function checkObj(obj: GameObj) {\n            stack.push(tr.clone());\n\n            // Update object transform here. This will be the transform later used in rendering.\n            if (obj.pos) tr.translate(obj.pos);\n            if (obj.scale) tr.scale(obj.scale);\n            if (obj.angle) tr.rotate(obj.angle);\n            obj.transform = tr.clone();\n\n            if (obj.c(\"area\") && !obj.paused) {\n                // TODO: only update worldArea if transform changed\n                const aobj = obj as GameObj<AreaComp>;\n                const area = aobj.worldArea();\n                const bbox = area.bbox();\n\n                // Get spatial hash grid coverage\n                const xmin = Math.floor(bbox.pos.x / cellSize);\n                const ymin = Math.floor(bbox.pos.y / cellSize);\n                const xmax = Math.ceil((bbox.pos.x + bbox.width) / cellSize);\n                const ymax = Math.ceil((bbox.pos.y + bbox.height) / cellSize);\n\n                // Cache objs that are already checked\n                const checked = new Set();\n\n                // insert & check against all covered grids\n                for (let x = xmin; x <= xmax; x++) {\n                    for (let y = ymin; y <= ymax; y++) {\n                        if (!grid[x]) {\n                            grid[x] = {};\n                            grid[x][y] = [aobj];\n                        } else if (!grid[x][y]) {\n                            grid[x][y] = [aobj];\n                        } else {\n                            const cell = grid[x][y];\n                            check: for (const other of cell) {\n                                if (other.paused) continue;\n                                if (!other.exists()) continue;\n                                if (checked.has(other.id)) continue;\n                                for (const tag of aobj.collisionIgnore) {\n                                    if (other.is(tag)) {\n                                        continue check;\n                                    }\n                                }\n                                for (const tag of other.collisionIgnore) {\n                                    if (aobj.is(tag)) {\n                                        continue check;\n                                    }\n                                }\n                                // TODO: cache the world area here\n                                const res = sat(\n                                    aobj.worldArea(),\n                                    other.worldArea(),\n                                );\n                                if (res) {\n                                    // TODO: rehash if the object position is changed after resolution?\n                                    const col1 = new Collision(\n                                        aobj,\n                                        other,\n                                        res,\n                                    );\n                                    aobj.trigger(\"collideUpdate\", other, col1);\n                                    const col2 = col1.reverse();\n                                    // resolution only has to happen once\n                                    col2.resolved = col1.resolved;\n                                    other.trigger(\"collideUpdate\", aobj, col2);\n                                }\n                                checked.add(other.id);\n                            }\n                            cell.push(aobj);\n                        }\n                    }\n                }\n            }\n\n            obj.children.forEach(checkObj);\n            tr = stack.pop();\n        }\n\n        checkObj(game.root);\n    }\n\n    function drawFrame() {\n        // calculate camera matrix\n        const cam = game.cam;\n        const shake = Vec2.fromAngle(rand(0, 360)).scale(cam.shake);\n\n        cam.shake = lerp(cam.shake, 0, 5 * dt());\n        cam.transform = new Mat4()\n            .translate(center())\n            .scale(cam.scale)\n            .rotate(cam.angle)\n            .translate((cam.pos ?? center()).scale(-1).add(shake));\n\n        game.root.draw();\n        flush();\n    }\n\n    function drawLoadScreen() {\n        const progress = loadProgress();\n\n        if (game.events.numListeners(\"loading\") > 0) {\n            game.events.trigger(\"loading\", progress);\n        } else {\n            drawUnscaled(() => {\n                const w = width() / 2;\n                const h = 24;\n                const pos = vec2(width() / 2, height() / 2).sub(\n                    vec2(w / 2, h / 2),\n                );\n                drawRect({\n                    pos: vec2(0),\n                    width: width(),\n                    height: height(),\n                    color: rgb(0, 0, 0),\n                });\n                drawRect({\n                    pos: pos,\n                    width: w,\n                    height: h,\n                    fill: false,\n                    outline: {\n                        width: 4,\n                    },\n                });\n                drawRect({\n                    pos: pos,\n                    width: w * progress,\n                    height: h,\n                });\n            });\n        }\n    }\n\n    function drawInspectText(pos, txt) {\n        drawUnscaled(() => {\n            const pad = vec2(8);\n\n            pushTransform();\n            pushTranslate(pos);\n\n            const ftxt = formatText({\n                text: txt,\n                font: DBG_FONT,\n                size: 16,\n                pos: pad,\n                color: rgb(255, 255, 255),\n                fixed: true,\n            });\n\n            const bw = ftxt.width + pad.x * 2;\n            const bh = ftxt.height + pad.x * 2;\n\n            if (pos.x + bw >= width()) {\n                pushTranslate(vec2(-bw, 0));\n            }\n\n            if (pos.y + bh >= height()) {\n                pushTranslate(vec2(0, -bh));\n            }\n\n            drawRect({\n                width: bw,\n                height: bh,\n                color: rgb(0, 0, 0),\n                radius: 4,\n                opacity: 0.8,\n                fixed: true,\n            });\n\n            drawFormattedText(ftxt);\n            popTransform();\n        });\n    }\n\n    function drawDebug() {\n        if (debug.inspect) {\n            let inspecting = null;\n\n            for (const obj of game.root.get(\"*\", { recursive: true })) {\n                if (obj.c(\"area\") && obj.isHovering()) {\n                    inspecting = obj;\n                    break;\n                }\n            }\n\n            game.root.drawInspect();\n\n            if (inspecting) {\n                const lines = [];\n                const data = inspecting.inspect();\n\n                for (const tag in data) {\n                    if (data[tag]) {\n                        lines.push(`${tag}: ${data[tag]}`);\n                    } else {\n                        lines.push(`${tag}`);\n                    }\n                }\n\n                drawInspectText(contentToView(mousePos()), lines.join(\"\\n\"));\n            }\n\n            drawInspectText(vec2(8), `FPS: ${debug.fps()}`);\n        }\n\n        if (debug.paused) {\n            drawUnscaled(() => {\n                // top right corner\n                pushTransform();\n                pushTranslate(width(), 0);\n                pushTranslate(-8, 8);\n\n                const size = 32;\n\n                // bg\n                drawRect({\n                    width: size,\n                    height: size,\n                    anchor: \"topright\",\n                    color: rgb(0, 0, 0),\n                    opacity: 0.8,\n                    radius: 4,\n                    fixed: true,\n                });\n\n                // pause icon\n                for (let i = 1; i <= 2; i++) {\n                    drawRect({\n                        width: 4,\n                        height: size * 0.6,\n                        anchor: \"center\",\n                        pos: vec2(-size / 3 * i, size * 0.5),\n                        color: rgb(255, 255, 255),\n                        radius: 2,\n                        fixed: true,\n                    });\n                }\n\n                popTransform();\n            });\n        }\n\n        if (debug.timeScale !== 1) {\n            drawUnscaled(() => {\n                // bottom right corner\n                pushTransform();\n                pushTranslate(width(), height());\n                pushTranslate(-8, -8);\n\n                const pad = 8;\n\n                // format text first to get text size\n                const ftxt = formatText({\n                    text: debug.timeScale.toFixed(1),\n                    font: DBG_FONT,\n                    size: 16,\n                    color: rgb(255, 255, 255),\n                    pos: vec2(-pad),\n                    anchor: \"botright\",\n                    fixed: true,\n                });\n\n                // bg\n                drawRect({\n                    width: ftxt.width + pad * 2 + pad * 4,\n                    height: ftxt.height + pad * 2,\n                    anchor: \"botright\",\n                    color: rgb(0, 0, 0),\n                    opacity: 0.8,\n                    radius: 4,\n                    fixed: true,\n                });\n\n                // fast forward / slow down icon\n                for (let i = 0; i < 2; i++) {\n                    const flipped = debug.timeScale < 1;\n                    drawTriangle({\n                        p1: vec2(-ftxt.width - pad * (flipped ? 2 : 3.5), -pad),\n                        p2: vec2(\n                            -ftxt.width - pad * (flipped ? 2 : 3.5),\n                            -pad - ftxt.height,\n                        ),\n                        p3: vec2(\n                            -ftxt.width - pad * (flipped ? 3.5 : 2),\n                            -pad - ftxt.height / 2,\n                        ),\n                        pos: vec2(-i * pad * 1 + (flipped ? -pad * 0.5 : 0), 0),\n                        color: rgb(255, 255, 255),\n                        fixed: true,\n                    });\n                }\n\n                // text\n                drawFormattedText(ftxt);\n\n                popTransform();\n            });\n        }\n\n        if (debug.curRecording) {\n            drawUnscaled(() => {\n                pushTransform();\n                pushTranslate(0, height());\n                pushTranslate(24, -24);\n\n                drawCircle({\n                    radius: 12,\n                    color: rgb(255, 0, 0),\n                    opacity: wave(0, 1, app.time() * 4),\n                    fixed: true,\n                });\n\n                popTransform();\n            });\n        }\n\n        if (debug.showLog && game.logs.length > 0) {\n            drawUnscaled(() => {\n                pushTransform();\n                pushTranslate(0, height());\n                pushTranslate(8, -8);\n\n                const pad = 8;\n                const logs = [];\n\n                for (const log of game.logs) {\n                    let str = \"\";\n                    const style = log.msg instanceof Error ? \"error\" : \"info\";\n                    str += `[time]${log.time.toFixed(2)}[/time]`;\n                    str += \" \";\n                    str += `[${style}]${\n                        log.msg?.toString ? log.msg.toString() : log.msg\n                    }[/${style}]`;\n                    logs.push(str);\n                }\n\n                game.logs = game.logs\n                    .filter((log) =>\n                        app.time() - log.time < (gopt.logTime || LOG_TIME)\n                    );\n\n                const ftext = formatText({\n                    text: logs.join(\"\\n\"),\n                    font: DBG_FONT,\n                    pos: vec2(pad, -pad),\n                    anchor: \"botleft\",\n                    size: 16,\n                    width: width() * 0.6,\n                    lineSpacing: pad / 2,\n                    fixed: true,\n                    styles: {\n                        \"time\": { color: rgb(127, 127, 127) },\n                        \"info\": { color: rgb(255, 255, 255) },\n                        \"error\": { color: rgb(255, 0, 127) },\n                    },\n                });\n\n                drawRect({\n                    width: ftext.width + pad * 2,\n                    height: ftext.height + pad * 2,\n                    anchor: \"botleft\",\n                    color: rgb(0, 0, 0),\n                    radius: 4,\n                    opacity: 0.8,\n                    fixed: true,\n                });\n\n                drawFormattedText(ftext);\n                popTransform();\n            });\n        }\n    }\n\n    function onLoading(action: (progress: number) => void) {\n        game.events.on(\"loading\", action);\n    }\n\n    function onResize(action: () => void) {\n        app.onResize(action);\n    }\n\n    function onError(action: (err: Error) => void) {\n        game.events.on(\"error\", action);\n    }\n\n    function handleErr(err: Error) {\n        console.error(err);\n        audio.ctx.suspend();\n\n        // TODO: this should only run once\n        app.run(() => {\n            frameStart();\n\n            drawUnscaled(() => {\n                const pad = 32;\n                const gap = 16;\n                const gw = width();\n                const gh = height();\n\n                const textStyle = {\n                    size: 36,\n                    width: gw - pad * 2,\n                    letterSpacing: 4,\n                    lineSpacing: 4,\n                    font: DBG_FONT,\n                    fixed: true,\n                };\n\n                drawRect({\n                    width: gw,\n                    height: gh,\n                    color: rgb(0, 0, 255),\n                    fixed: true,\n                });\n\n                const title = formatText({\n                    ...textStyle,\n                    text: \"Error\",\n                    pos: vec2(pad),\n                    color: rgb(255, 128, 0),\n                    fixed: true,\n                });\n\n                drawFormattedText(title);\n\n                drawText({\n                    ...textStyle,\n                    text: err.message,\n                    pos: vec2(pad, pad + title.height + gap),\n                    fixed: true,\n                });\n\n                popTransform();\n                game.events.trigger(\"error\", err);\n            });\n\n            frameEnd();\n        });\n    }\n\n    function onCleanup(action: () => void) {\n        gc.push(action);\n    }\n\n    function quit() {\n        game.events.onOnce(\"frameEnd\", () => {\n            app.quit();\n\n            // clear canvas\n            gl.clear(\n                gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT\n                    | gl.STENCIL_BUFFER_BIT,\n            );\n\n            // unbind everything\n            const numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n            for (let unit = 0; unit < numTextureUnits; unit++) {\n                gl.activeTexture(gl.TEXTURE0 + unit);\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n            // run all scattered gc events\n            ggl.destroy();\n            gc.forEach((f) => f());\n        });\n    }\n\n    let isFirstFrame = true;\n\n    // main game loop\n    app.run(() => {\n        try {\n            if (!assets.loaded) {\n                if (loadProgress() === 1 && !isFirstFrame) {\n                    assets.loaded = true;\n                    game.events.trigger(\"load\");\n                }\n            }\n\n            if (\n                !assets.loaded && gopt.loadingScreen !== false\n                || isFirstFrame\n            ) {\n                frameStart();\n                // TODO: Currently if assets are not initially loaded no updates or timers will be run, however they will run if loadingScreen is set to false. What's the desired behavior or should we make them consistent?\n                drawLoadScreen();\n                frameEnd();\n            } else {\n                if (!debug.paused) updateFrame();\n                checkFrame();\n                frameStart();\n                drawFrame();\n                if (gopt.debug !== false) drawDebug();\n                frameEnd();\n            }\n\n            if (isFirstFrame) {\n                isFirstFrame = false;\n            }\n\n            game.events.trigger(\"frameEnd\");\n        } catch (e) {\n            handleErr(e);\n        }\n    });\n\n    // update viewport based on user setting and fullscreen state\n    function updateViewport() {\n        // content size (scaled content size, with scale, stretch and letterbox)\n        // view size (unscaled viewport size)\n        // window size (will be the same as view size except letterbox mode)\n\n        // canvas size\n        const pd = pixelDensity;\n        const cw = gl.drawingBufferWidth / pd;\n        const ch = gl.drawingBufferHeight / pd;\n\n        if (gopt.letterbox) {\n            if (!gopt.width || !gopt.height) {\n                throw new Error(\n                    \"Letterboxing requires width and height defined.\",\n                );\n            }\n\n            const rc = cw / ch;\n            const rg = gopt.width / gopt.height;\n\n            if (rc > rg) {\n                const sw = ch * rg;\n                const x = (cw - sw) / 2;\n                gfx.viewport = {\n                    x: x,\n                    y: 0,\n                    width: sw,\n                    height: ch,\n                };\n            } else {\n                const sh = cw / rg;\n                const y = (ch - sh) / 2;\n                gfx.viewport = {\n                    x: 0,\n                    y: y,\n                    width: cw,\n                    height: sh,\n                };\n            }\n\n            return;\n        }\n\n        if (gopt.stretch) {\n            if (!gopt.width || !gopt.height) {\n                throw new Error(\n                    \"Stretching requires width and height defined.\",\n                );\n            }\n        }\n\n        gfx.viewport = {\n            x: 0,\n            y: 0,\n            width: cw,\n            height: ch,\n        };\n    }\n\n    function initEvents() {\n        app.onHide(() => {\n            if (!gopt.backgroundAudio) {\n                audio.ctx.suspend();\n            }\n        });\n\n        app.onShow(() => {\n            if (!gopt.backgroundAudio && !debug.paused) {\n                audio.ctx.resume();\n            }\n        });\n\n        app.onResize(() => {\n            if (app.isFullscreen()) return;\n            const fixedSize = gopt.width && gopt.height;\n            if (fixedSize && !gopt.stretch && !gopt.letterbox) return;\n            canvas.width = canvas.offsetWidth * pixelDensity;\n            canvas.height = canvas.offsetHeight * pixelDensity;\n            updateViewport();\n            if (!fixedSize) {\n                gfx.frameBuffer.free();\n                gfx.frameBuffer = new FrameBuffer(\n                    ggl,\n                    gl.drawingBufferWidth,\n                    gl.drawingBufferHeight,\n                );\n                gfx.width = gl.drawingBufferWidth / pixelDensity / gscale;\n                gfx.height = gl.drawingBufferHeight / pixelDensity / gscale;\n            }\n        });\n\n        if (gopt.debug !== false) {\n            app.onKeyPress(\n                gopt.debugKey ?? \"f1\",\n                () => debug.inspect = !debug.inspect,\n            );\n            app.onKeyPress(\"f2\", () => debug.clearLog());\n            app.onKeyPress(\"f8\", () => debug.paused = !debug.paused);\n            app.onKeyPress(\"f7\", () => {\n                debug.timeScale = toFixed(\n                    clamp(debug.timeScale - 0.2, 0, 2),\n                    1,\n                );\n            });\n            app.onKeyPress(\"f9\", () => {\n                debug.timeScale = toFixed(\n                    clamp(debug.timeScale + 0.2, 0, 2),\n                    1,\n                );\n            });\n            app.onKeyPress(\"f10\", () => debug.stepFrame());\n        }\n\n        if (gopt.burp) {\n            app.onKeyPress(\"b\", () => burp());\n        }\n    }\n\n    updateViewport();\n    initEvents();\n\n    const internalCtx = {\n        kaboomCtx: ctx,\n        app,\n        game,\n        isFixed,\n        toFixed,\n        getViewportScale,\n        getRenderProps,\n        resolveSprite,\n        drawTexture,\n        calcTransform,\n    } satisfies InternalCtx;\n\n    // the exported ctx handle\n    ctx = {\n        _k: internalCtx,\n        VERSION,\n        // asset load\n        loadRoot,\n        loadProgress,\n        loadSprite,\n        loadSpriteAtlas,\n        loadSound,\n        loadMusic,\n        loadBitmapFont,\n        loadFont,\n        loadShader,\n        loadShaderURL,\n        loadAseprite,\n        loadPedit,\n        loadBean,\n        loadJSON,\n        load,\n        getSprite,\n        getSound,\n        getFont,\n        getBitmapFont,\n        getShader,\n        getAsset,\n        Asset,\n        SpriteData,\n        SoundData,\n        // query\n        width,\n        height,\n        center,\n        dt,\n        time: app.time,\n        screenshot: app.screenshot,\n        record,\n        isFocused,\n        setCursor: app.setCursor,\n        getCursor: app.getCursor,\n        setCursorLocked: app.setCursorLocked,\n        isCursorLocked: app.isCursorLocked,\n        setFullscreen: app.setFullscreen,\n        isFullscreen: app.isFullscreen,\n        isTouchscreen: app.isTouchscreen,\n        onLoad,\n        onLoading,\n        onResize,\n        onGamepadConnect: app.onGamepadConnect,\n        onGamepadDisconnect: app.onGamepadDisconnect,\n        onError,\n        onCleanup,\n        // misc\n        camPos,\n        camScale,\n        camRot,\n        shake,\n        toScreen,\n        toWorld,\n        setGravity,\n        getGravity,\n        setGravityDirection,\n        getGravityDirection,\n        setBackground,\n        getBackground,\n        getGamepads: app.getGamepads,\n        // obj\n        add,\n        make,\n        destroy,\n        destroyAll,\n        get,\n        readd,\n        // comps\n        pos,\n        scale,\n        rotate,\n        color,\n        opacity,\n        anchor,\n        area,\n        sprite,\n        text,\n        polygon,\n        rect,\n        circle,\n        uvquad,\n        outline,\n        body,\n        doubleJump,\n        shader,\n        timer,\n        fixed,\n        stay,\n        health,\n        lifespan,\n        state,\n        z,\n        move,\n        offscreen,\n        follow,\n        fadeIn,\n        mask,\n        drawon,\n        raycast,\n        tile,\n        agent,\n        // group events\n        on,\n        onUpdate,\n        onDraw,\n        onAdd,\n        onDestroy,\n        onClick,\n        onCollide,\n        onCollideUpdate,\n        onCollideEnd,\n        onHover,\n        onHoverUpdate,\n        onHoverEnd,\n        // input\n        onKeyDown: app.onKeyDown,\n        onKeyPress: app.onKeyPress,\n        onKeyPressRepeat: app.onKeyPressRepeat,\n        onKeyRelease: app.onKeyRelease,\n        onMouseDown: app.onMouseDown,\n        onMousePress: app.onMousePress,\n        onMouseRelease: app.onMouseRelease,\n        onMouseMove: app.onMouseMove,\n        onCharInput: app.onCharInput,\n        onTouchStart: app.onTouchStart,\n        onTouchMove: app.onTouchMove,\n        onTouchEnd: app.onTouchEnd,\n        onScroll: app.onScroll,\n        onHide: app.onHide,\n        onShow: app.onShow,\n        onGamepadButtonDown: app.onGamepadButtonDown,\n        onGamepadButtonPress: app.onGamepadButtonPress,\n        onGamepadButtonRelease: app.onGamepadButtonRelease,\n        onGamepadStick: app.onGamepadStick,\n        mousePos: mousePos,\n        mouseDeltaPos: app.mouseDeltaPos,\n        isKeyDown: app.isKeyDown,\n        isKeyPressed: app.isKeyPressed,\n        isKeyPressedRepeat: app.isKeyPressedRepeat,\n        isKeyReleased: app.isKeyReleased,\n        isMouseDown: app.isMouseDown,\n        isMousePressed: app.isMousePressed,\n        isMouseReleased: app.isMouseReleased,\n        isMouseMoved: app.isMouseMoved,\n        isGamepadButtonPressed: app.isGamepadButtonPressed,\n        isGamepadButtonDown: app.isGamepadButtonDown,\n        isGamepadButtonReleased: app.isGamepadButtonReleased,\n        getGamepadStick: app.getGamepadStick,\n        charInputted: app.charInputted,\n        // timer\n        loop,\n        wait,\n        // audio\n        play,\n        volume,\n        burp,\n        audioCtx: audio.ctx,\n        // math\n        Line,\n        Rect,\n        Circle,\n        Ellipse,\n        Polygon,\n        Vec2,\n        Color,\n        Mat4,\n        Quad,\n        RNG,\n        rand,\n        randi,\n        randSeed,\n        vec2,\n        rgb,\n        hsl2rgb,\n        quad,\n        choose,\n        chooseMultiple,\n        shuffle,\n        chance,\n        lerp,\n        tween,\n        easings,\n        map,\n        mapc,\n        wave,\n        deg2rad,\n        rad2deg,\n        clamp,\n        evaluateBezier,\n        testLineLine,\n        testRectRect,\n        testRectLine,\n        testRectPoint,\n        testCirclePolygon,\n        testLinePoint,\n        testLineCircle,\n        isConvex,\n        triangulate,\n        // raw draw\n        drawSprite,\n        drawText,\n        formatText,\n        drawRect,\n        drawLine,\n        drawLines,\n        drawTriangle,\n        drawCircle,\n        drawEllipse,\n        drawUVQuad,\n        drawPolygon,\n        drawCurve,\n        drawBezier,\n        drawFormattedText,\n        drawMasked,\n        drawSubtracted,\n        pushTransform,\n        popTransform,\n        pushTranslate,\n        pushScale,\n        pushRotate,\n        pushMatrix,\n        usePostEffect,\n        makeCanvas,\n        // debug\n        debug,\n        // scene\n        scene,\n        getSceneName,\n        go,\n        onSceneLeave,\n        // level\n        addLevel,\n        // storage\n        getData,\n        setData,\n        download,\n        downloadJSON,\n        downloadText,\n        downloadBlob,\n        // plugin\n        plug,\n        // char sets\n        ASCII_CHARS,\n        // dom\n        canvas: app.canvas,\n        // misc\n        addKaboom,\n        // dirs\n        LEFT: Vec2.LEFT,\n        RIGHT: Vec2.RIGHT,\n        UP: Vec2.UP,\n        DOWN: Vec2.DOWN,\n        // colors\n        RED: Color.RED,\n        GREEN: Color.GREEN,\n        BLUE: Color.BLUE,\n        YELLOW: Color.YELLOW,\n        MAGENTA: Color.MAGENTA,\n        CYAN: Color.CYAN,\n        WHITE: Color.WHITE,\n        BLACK: Color.BLACK,\n        quit,\n        // helpers\n        Event,\n        EventHandler,\n        EventController,\n    };\n\n    if (gopt.plugins) {\n        gopt.plugins.forEach(plug);\n    }\n\n    // export everything to window if global is set\n    if (gopt.global !== false) {\n        for (const k in ctx) {\n            window[k] = ctx[k];\n        }\n    }\n\n    if (gopt.focus !== false) {\n        app.canvas.focus();\n    }\n\n    return ctx;\n};\n", "import type { LerpValue, Point, RNGValue, Vec2Args } from \"@/types\";\n\nexport function deg2rad(deg: number): number {\n    return deg * Math.PI / 180;\n}\n\nexport function rad2deg(rad: number): number {\n    return rad * 180 / Math.PI;\n}\n\nexport function clamp(\n    val: number,\n    min: number,\n    max: number,\n): number {\n    if (min > max) {\n        return clamp(val, max, min);\n    }\n    return Math.min(Math.max(val, min), max);\n}\n\nexport function lerp<V extends LerpValue>(\n    a: V,\n    b: V,\n    t: number,\n): V {\n    if (typeof a === \"number\" && typeof b === \"number\") {\n        return a + (b - a) * t as V;\n    } else if (a instanceof Vec2 && b instanceof Vec2) {\n        return a.lerp(b, t) as V;\n    } else if (a instanceof Color && b instanceof Color) {\n        return a.lerp(b, t) as V;\n    }\n    throw new Error(\n        `Bad value for lerp(): ${a}, ${b}. Only number, Vec2 and Color is supported.`,\n    );\n}\n\nexport function map(\n    v: number,\n    l1: number,\n    h1: number,\n    l2: number,\n    h2: number,\n): number {\n    return l2 + (v - l1) / (h1 - l1) * (h2 - l2);\n}\n\nexport function mapc(\n    v: number,\n    l1: number,\n    h1: number,\n    l2: number,\n    h2: number,\n): number {\n    return clamp(map(v, l1, h1, l2, h2), l2, h2);\n}\n\nexport class Vec2 {\n    x: number = 0;\n    y: number = 0;\n    constructor(x: number = 0, y: number = x) {\n        this.x = x;\n        this.y = y;\n    }\n    static fromAngle(deg: number) {\n        const angle = deg2rad(deg);\n        return new Vec2(Math.cos(angle), Math.sin(angle));\n    }\n    static LEFT = new Vec2(-1, 0);\n    static RIGHT = new Vec2(1, 0);\n    static UP = new Vec2(0, -1);\n    static DOWN = new Vec2(0, 1);\n    clone(): Vec2 {\n        return new Vec2(this.x, this.y);\n    }\n    add(...args: Vec2Args): Vec2 {\n        const p2 = vec2(...args);\n        return new Vec2(this.x + p2.x, this.y + p2.y);\n    }\n    sub(...args: Vec2Args): Vec2 {\n        const p2 = vec2(...args);\n        return new Vec2(this.x - p2.x, this.y - p2.y);\n    }\n    scale(...args: Vec2Args): Vec2 {\n        const s = vec2(...args);\n        return new Vec2(this.x * s.x, this.y * s.y);\n    }\n    dist(...args: Vec2Args): number {\n        const p2 = vec2(...args);\n        return this.sub(p2).len();\n    }\n    sdist(...args: Vec2Args): number {\n        const p2 = vec2(...args);\n        return this.sub(p2).slen();\n    }\n    len(): number {\n        return Math.sqrt(this.dot(this));\n    }\n    slen(): number {\n        return this.dot(this);\n    }\n    unit(): Vec2 {\n        const len = this.len();\n        return len === 0 ? new Vec2(0) : this.scale(1 / len);\n    }\n    normal(): Vec2 {\n        return new Vec2(this.y, -this.x);\n    }\n    reflect(normal: Vec2) {\n        return this.sub(normal.scale(2 * this.dot(normal)));\n    }\n    project(on: Vec2) {\n        return on.scale(on.dot(this) / on.len());\n    }\n    reject(on: Vec2) {\n        return this.sub(this.project(on));\n    }\n    dot(p2: Vec2): number {\n        return this.x * p2.x + this.y * p2.y;\n    }\n    cross(p2: Vec2): number {\n        return this.x * p2.y - this.y * p2.x;\n    }\n    angle(...args: Vec2Args): number {\n        const p2 = vec2(...args);\n        return rad2deg(Math.atan2(this.y - p2.y, this.x - p2.x));\n    }\n    angleBetween(...args: Vec2Args): number {\n        const p2 = vec2(...args);\n        return rad2deg(Math.atan2(this.cross(p2), this.dot(p2)));\n    }\n    lerp(dest: Vec2, t: number): Vec2 {\n        return new Vec2(lerp(this.x, dest.x, t), lerp(this.y, dest.y, t));\n    }\n    slerp(dest: Vec2, t: number): Vec2 {\n        const cos = this.dot(dest);\n        const sin = this.cross(dest);\n        const angle = Math.atan2(sin, cos);\n        return this\n            .scale(Math.sin((1 - t) * angle))\n            .add(dest.scale(Math.sin(t * angle)))\n            .scale(1 / sin);\n    }\n    isZero(): boolean {\n        return this.x === 0 && this.y === 0;\n    }\n    toFixed(n: number): Vec2 {\n        return new Vec2(Number(this.x.toFixed(n)), Number(this.y.toFixed(n)));\n    }\n    transform(m: Mat4): Vec2 {\n        return m.multVec2(this);\n    }\n    eq(other: Vec2): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n    bbox(): Rect {\n        return new Rect(this, 0, 0);\n    }\n    toString(): string {\n        return `vec2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;\n    }\n}\n\nexport function vec2(...args: Vec2Args): Vec2 {\n    if (args.length === 1) {\n        if (args[0] instanceof Vec2) {\n            return new Vec2(args[0].x, args[0].y);\n        } else if (Array.isArray(args[0]) && args[0].length === 2) {\n            return new Vec2(...args[0]);\n        }\n    }\n    // @ts-ignore\n    return new Vec2(...args);\n}\n\nexport class Color {\n    r: number = 255;\n    g: number = 255;\n    b: number = 255;\n\n    constructor(r: number, g: number, b: number) {\n        this.r = clamp(r, 0, 255);\n        this.g = clamp(g, 0, 255);\n        this.b = clamp(b, 0, 255);\n    }\n\n    static fromArray(arr: number[]) {\n        return new Color(arr[0], arr[1], arr[2]);\n    }\n\n    static fromHex(hex: string | number) {\n        if (typeof hex === \"number\") {\n            return new Color(\n                (hex >> 16) & 0xff,\n                (hex >> 8) & 0xff,\n                (hex >> 0) & 0xff,\n            );\n        } else if (typeof hex === \"string\") {\n            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(\n                hex,\n            );\n            return new Color(\n                parseInt(result[1], 16),\n                parseInt(result[2], 16),\n                parseInt(result[3], 16),\n            );\n        } else {\n            throw new Error(\"Invalid hex color format\");\n        }\n    }\n\n    // TODO: use range of [0, 360] [0, 100] [0, 100]?\n    static fromHSL(h: number, s: number, l: number) {\n        if (s == 0) {\n            return new Color(255 * l, 255 * l, 255 * l);\n        }\n\n        const hue2rgb = (p, q, t) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        const r = hue2rgb(p, q, h + 1 / 3);\n        const g = hue2rgb(p, q, h);\n        const b = hue2rgb(p, q, h - 1 / 3);\n\n        return new Color(\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n        );\n    }\n\n    static RED = new Color(255, 0, 0);\n    static GREEN = new Color(0, 255, 0);\n    static BLUE = new Color(0, 0, 255);\n    static YELLOW = new Color(255, 255, 0);\n    static MAGENTA = new Color(255, 0, 255);\n    static CYAN = new Color(0, 255, 255);\n    static WHITE = new Color(255, 255, 255);\n    static BLACK = new Color(0, 0, 0);\n\n    clone(): Color {\n        return new Color(this.r, this.g, this.b);\n    }\n\n    lighten(a: number): Color {\n        return new Color(this.r + a, this.g + a, this.b + a);\n    }\n\n    darken(a: number): Color {\n        return this.lighten(-a);\n    }\n\n    invert(): Color {\n        return new Color(255 - this.r, 255 - this.g, 255 - this.b);\n    }\n\n    mult(other: Color): Color {\n        return new Color(\n            this.r * other.r / 255,\n            this.g * other.g / 255,\n            this.b * other.b / 255,\n        );\n    }\n\n    lerp(dest: Color, t: number): Color {\n        return new Color(\n            lerp(this.r, dest.r, t),\n            lerp(this.g, dest.g, t),\n            lerp(this.b, dest.b, t),\n        );\n    }\n\n    toHSL(): [number, number, number] {\n        const r = this.r / 255;\n        const g = this.g / 255;\n        const b = this.b / 255;\n        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        const l = h;\n        if (max == min) {\n            h = s = 0;\n        } else {\n            const d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return [h, s, l];\n    }\n\n    eq(other: Color): boolean {\n        return this.r === other.r\n            && this.g === other.g\n            && this.b === other.b;\n    }\n\n    toString(): string {\n        return `rgb(${this.r}, ${this.g}, ${this.b})`;\n    }\n\n    toHex(): string {\n        return \"#\"\n            + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16)\n                .slice(1);\n    }\n\n    toArray(): Array<number> {\n        return [this.r, this.g, this.b];\n    }\n}\n\nexport function rgb(...args): Color {\n    if (args.length === 0) {\n        return new Color(255, 255, 255);\n    } else if (args.length === 1) {\n        if (args[0] instanceof Color) {\n            return args[0].clone();\n        } else if (typeof args[0] === \"string\") {\n            return Color.fromHex(args[0]);\n        } else if (Array.isArray(args[0]) && args[0].length === 3) {\n            return Color.fromArray(args[0]);\n        }\n    }\n    // @ts-ignore\n    return new Color(...args);\n}\n\nexport const hsl2rgb = (h, s, l) => Color.fromHSL(h, s, l);\n\nexport class Quad {\n    x: number = 0;\n    y: number = 0;\n    w: number = 1;\n    h: number = 1;\n    constructor(x: number, y: number, w: number, h: number) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n    scale(other: Quad): Quad {\n        return new Quad(\n            this.x + this.w * other.x,\n            this.y + this.h * other.y,\n            this.w * other.w,\n            this.h * other.h,\n        );\n    }\n    pos() {\n        return new Vec2(this.x, this.y);\n    }\n    clone(): Quad {\n        return new Quad(this.x, this.y, this.w, this.h);\n    }\n    eq(other: Quad): boolean {\n        return this.x === other.x\n            && this.y === other.y\n            && this.w === other.w\n            && this.h === other.h;\n    }\n    toString(): string {\n        return `quad(${this.x}, ${this.y}, ${this.w}, ${this.h})`;\n    }\n}\n\nexport function quad(x: number, y: number, w: number, h: number): Quad {\n    return new Quad(x, y, w, h);\n}\n\n// Internal class\nclass Mat2 {\n    // 2x2 matrix\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n\n    constructor(a: number, b: number, c: number, d: number) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    mul(other: Mat2) {\n        return new Mat2(\n            this.a * other.a + this.b * other.c,\n            this.a * other.b + this.b * other.d,\n            this.c * other.a + this.d * other.c,\n            this.c * other.b + this.d * other.d,\n        );\n    }\n\n    transform(point: Vec2): Vec2 {\n        return vec2(\n            this.a * point.x + this.b * point.y,\n            this.c * point.x + this.d * point.y,\n        );\n    }\n\n    get inverse() {\n        const det = this.det;\n        return new Mat2(\n            this.d / det,\n            -this.b / det,\n            -this.c / det,\n            this.a / det,\n        );\n    }\n\n    get transpose() {\n        return new Mat2(\n            this.a,\n            this.c,\n            this.b,\n            this.d,\n        );\n    }\n\n    get eigenvalues() {\n        const m = this.trace / 2;\n        const d = this.det;\n        const e1 = m + Math.sqrt(m * m - d);\n        const e2 = m - Math.sqrt(m * m - d);\n        return [e1, e2];\n    }\n\n    eigenvectors(e1: number, e2: number) {\n        if (this.c != 0) {\n            return [[e1 - this.d, this.c], [e2 - this.d, this.c]];\n        } else if (this.b != 0) {\n            return [[this.b, e1 - this.a], [this.b, e2 - this.a]];\n        } else {\n            if (Math.abs(this.transform(vec2(1, 0)).x - e1) < Number.EPSILON) {\n                return [[1, 0], [0, 1]];\n            } else {\n                return [[0, 1], [1, 0]];\n            }\n        }\n    }\n\n    get det() {\n        return this.a * this.d - this.b * this.c;\n    }\n\n    get trace() {\n        return this.a + this.d;\n    }\n\n    static rotation(radians: number) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        return new Mat2(\n            c,\n            s,\n            -s,\n            c,\n        );\n    }\n\n    static scale(x: number, y: number) {\n        return new Mat2(x, 0, 0, y);\n    }\n}\n\n// Internal class\nclass Mat23 {\n    // 2x3 matrix, since the last column is always (0, 0, 1)\n    a: number;\n    b: number; // 0\n    c: number;\n    d: number; // 0\n    e: number;\n    f: number; // 1\n    constructor(\n        a: number = 1,\n        b: number = 0,\n        c: number = 0,\n        d: number = 1,\n        e: number = 0,\n        f: number = 0,\n    ) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.e = e;\n        this.f = f;\n    }\n    static fromMat2(m: Mat2) {\n        return new Mat23(\n            m.a,\n            m.b,\n            m.c,\n            m.d,\n            0,\n            0,\n        );\n    }\n    toMat2() {\n        return new Mat2(\n            this.a,\n            this.b,\n            this.c,\n            this.d,\n        );\n    }\n    static fromTranslation(t: Vec2) {\n        return new Mat23(\n            1,\n            0,\n            0,\n            1,\n            t.x,\n            t.y,\n        );\n    }\n    static fromRotation(radians: number) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        return new Mat23(\n            c,\n            s,\n            -s,\n            c,\n            0,\n            0,\n        );\n    }\n    static fromScale(s: Vec2): Mat23 {\n        return new Mat23(\n            s.x,\n            0,\n            0,\n            s.y,\n            0,\n            0,\n        );\n    }\n    mul(other: Mat23): Mat23 {\n        return new Mat23(\n            other.a * this.a + other.b * this.c,\n            other.a * this.b + other.b * this.d,\n            other.c * this.a + other.d * this.c,\n            other.c * this.b + other.d * this.d,\n            other.e * this.a + other.f * this.c + this.e,\n            other.e * this.b + other.f * this.d + this.f,\n        );\n    }\n    translate(t: Vec2): Mat23 {\n        this.e += t.x * this.a + t.y * this.c;\n        this.f += t.y * this.b + t.x * this.d;\n        return this;\n    }\n    rotate(radians: number): Mat23 {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        const oldA = this.a;\n        const oldB = this.b;\n        this.a = c * this.a + s * this.c;\n        this.b = c * this.b + s * this.d;\n        this.c = c * this.c - s * oldA;\n        this.d = c * this.d - s * oldB;\n        return this;\n    }\n    scale(s: Vec2): Mat23 {\n        this.a *= s.x;\n        this.b *= s.x;\n        this.c *= s.y;\n        this.d *= s.y;\n        return this;\n    }\n    transform(p: Vec2) {\n        return vec2(\n            this.a * p.x + this.c * p.y + this.e,\n            this.b * p.x + this.d * p.y + this.f,\n        );\n    }\n\n    get det() {\n        return this.a * this.d - this.b * this.c;\n    }\n\n    get inverse() {\n        const det = this.det;\n        return new Mat23(\n            this.d / det,\n            -this.b / det,\n            -this.c / det,\n            this.a / det,\n            (this.c * this.f - this.d * this.e) / det,\n            (this.b * this.e - this.a * this.f) / det,\n        );\n    }\n}\n\n// Internal class\nclass Mat3 {\n    // m11 m12 m13\n    // m21 m22 m23\n    // m31 m32 m33\n    m11: number;\n    m12: number;\n    m13: number;\n    m21: number;\n    m22: number;\n    m23: number;\n    m31: number;\n    m32: number;\n    m33: number;\n\n    constructor(\n        m11: number,\n        m12: number,\n        m13: number,\n        m21: number,\n        m22: number,\n        m23: number,\n        m31: number,\n        m32: number,\n        m33: number,\n    ) {\n        this.m11 = m11;\n        this.m12 = m12;\n        this.m13 = m13;\n        this.m21 = m21;\n        this.m22 = m22;\n        this.m23 = m23;\n        this.m31 = m31;\n        this.m32 = m32;\n        this.m33 = m33;\n    }\n\n    static fromMat2(m: Mat2) {\n        return new Mat3(\n            m.a,\n            m.b,\n            0,\n            m.c,\n            m.d,\n            0,\n            0,\n            0,\n            1,\n        );\n    }\n\n    toMat2() {\n        return new Mat2(\n            this.m11,\n            this.m12,\n            this.m21,\n            this.m22,\n        );\n    }\n\n    mul(other: Mat3): Mat3 {\n        return new Mat3(\n            this.m11 * other.m11 + this.m12 * other.m21 + this.m13 * other.m31,\n            this.m11 * other.m12 + this.m12 * other.m22 + this.m13 * other.m32,\n            this.m11 * other.m13 + this.m12 * other.m23 + this.m13 * other.m33,\n            this.m21 * other.m11 + this.m22 * other.m21 + this.m23 * other.m31,\n            this.m21 * other.m12 + this.m22 * other.m22 + this.m23 * other.m32,\n            this.m21 * other.m13 + this.m22 * other.m23 + this.m23 * other.m33,\n            this.m31 * other.m11 + this.m32 * other.m21 + this.m33 * other.m31,\n            this.m31 * other.m12 + this.m32 * other.m22 + this.m33 * other.m32,\n            this.m31 * other.m13 + this.m32 * other.m23 + this.m33 * other.m33,\n        );\n    }\n\n    get det(): number {\n        return this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31\n            + this.m13 * this.m21 * this.m32 - this.m13 * this.m22 * this.m31\n            - this.m12 * this.m21 * this.m33 - this.m11 * this.m23 * this.m32;\n    }\n\n    rotate(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        const oldA = this.m11;\n        const oldB = this.m12;\n        this.m11 = c * this.m11 + s * this.m21;\n        this.m12 = c * this.m12 + s * this.m22;\n        this.m21 = c * this.m21 - s * oldA;\n        this.m22 = c * this.m22 - s * oldB;\n        return this;\n    }\n    scale(x, y) {\n        this.m11 *= x;\n        this.m12 *= x;\n        this.m21 *= y;\n        this.m22 *= y;\n        return this;\n    }\n\n    get inverse(): Mat3 {\n        const det = this.det;\n        return new Mat3(\n            (this.m22 * this.m33 - this.m23 * this.m32) / det,\n            (this.m13 * this.m32 - this.m12 * this.m33) / det,\n            (this.m12 * this.m23 - this.m13 * this.m22) / det,\n            (this.m23 * this.m31 - this.m21 * this.m33) / det,\n            (this.m11 * this.m33 - this.m13 * this.m31) / det,\n            (this.m13 * this.m21 - this.m11 * this.m23) / det,\n            (this.m21 * this.m32 - this.m22 * this.m31) / det,\n            (this.m12 * this.m31 - this.m11 * this.m32) / det,\n            (this.m11 * this.m22 - this.m12 * this.m21) / det,\n        );\n    }\n\n    get transpose(): Mat3 {\n        return new Mat3(\n            this.m11,\n            this.m21,\n            this.m31,\n            this.m12,\n            this.m22,\n            this.m32,\n            this.m13,\n            this.m23,\n            this.m33,\n        );\n    }\n}\n\nexport class Mat4 {\n    m: number[] = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n    ];\n\n    constructor(m?: number[]) {\n        if (m) {\n            this.m = m;\n        }\n    }\n\n    static translate(p: Vec2): Mat4 {\n        return new Mat4([\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            p.x,\n            p.y,\n            0,\n            1,\n        ]);\n    }\n\n    static scale(s: Vec2): Mat4 {\n        return new Mat4([\n            s.x,\n            0,\n            0,\n            0,\n            0,\n            s.y,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n        ]);\n    }\n\n    static rotateX(a: number): Mat4 {\n        a = deg2rad(-a);\n        const c = Math.cos(a);\n        const s = Math.sin(a);\n        return new Mat4([\n            1,\n            0,\n            0,\n            0,\n            0,\n            c,\n            -s,\n            0,\n            0,\n            s,\n            c,\n            0,\n            0,\n            0,\n            0,\n            1,\n        ]);\n    }\n\n    static rotateY(a: number): Mat4 {\n        a = deg2rad(-a);\n        const c = Math.cos(a);\n        const s = Math.sin(a);\n        return new Mat4([\n            c,\n            0,\n            s,\n            0,\n            0,\n            1,\n            0,\n            0,\n            -s,\n            0,\n            c,\n            0,\n            0,\n            0,\n            0,\n            1,\n        ]);\n    }\n\n    static rotateZ(a: number): Mat4 {\n        a = deg2rad(-a);\n        const c = Math.cos(a);\n        const s = Math.sin(a);\n        return new Mat4([\n            c,\n            -s,\n            0,\n            0,\n            s,\n            c,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n        ]);\n    }\n\n    translate(p: Vec2) {\n        this.m[12] += this.m[0] * p.x + this.m[4] * p.y;\n        this.m[13] += this.m[1] * p.x + this.m[5] * p.y;\n        this.m[14] += this.m[2] * p.x + this.m[6] * p.y;\n        this.m[15] += this.m[3] * p.x + this.m[7] * p.y;\n        return this;\n    }\n\n    scale(p: Vec2) {\n        this.m[0] *= p.x;\n        this.m[4] *= p.y;\n        this.m[1] *= p.x;\n        this.m[5] *= p.y;\n        this.m[2] *= p.x;\n        this.m[6] *= p.y;\n        this.m[3] *= p.x;\n        this.m[7] *= p.y;\n        return this;\n    }\n\n    rotate(a: number): Mat4 {\n        a = deg2rad(-a);\n        const c = Math.cos(a);\n        const s = Math.sin(a);\n        const m0 = this.m[0];\n        const m1 = this.m[1];\n        const m4 = this.m[4];\n        const m5 = this.m[5];\n        this.m[0] = m0 * c + m1 * s;\n        this.m[1] = -m0 * s + m1 * c;\n        this.m[4] = m4 * c + m5 * s;\n        this.m[5] = -m4 * s + m5 * c;\n        return this;\n    }\n\n    // TODO: in-place variant\n    mult(other: Mat4): Mat4 {\n        const out = [];\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                out[i * 4 + j] = this.m[0 * 4 + j] * other.m[i * 4 + 0]\n                    + this.m[1 * 4 + j] * other.m[i * 4 + 1]\n                    + this.m[2 * 4 + j] * other.m[i * 4 + 2]\n                    + this.m[3 * 4 + j] * other.m[i * 4 + 3];\n            }\n        }\n        return new Mat4(out);\n    }\n\n    multVec2(p: Vec2): Vec2 {\n        return new Vec2(\n            p.x * this.m[0] + p.y * this.m[4] + this.m[12],\n            p.x * this.m[1] + p.y * this.m[5] + this.m[13],\n        );\n    }\n\n    getTranslation() {\n        return new Vec2(this.m[12], this.m[13]);\n    }\n\n    getScale() {\n        if (this.m[0] != 0 || this.m[1] != 0) {\n            const det = this.m[0] * this.m[5] - this.m[1] * this.m[4];\n            const r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);\n            return new Vec2(r, det / r);\n        } else if (this.m[4] != 0 || this.m[5] != 0) {\n            const det = this.m[0] * this.m[5] - this.m[1] * this.m[4];\n            const s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);\n            return new Vec2(det / s, s);\n        } else {\n            return new Vec2(0, 0);\n        }\n    }\n\n    getRotation() {\n        if (this.m[0] != 0 || this.m[1] != 0) {\n            const r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);\n            return rad2deg(\n                this.m[1] > 0\n                    ? Math.acos(this.m[0] / r)\n                    : -Math.acos(this.m[0] / r),\n            );\n        } else if (this.m[4] != 0 || this.m[5] != 0) {\n            const s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);\n            return rad2deg(\n                Math.PI / 2 - (this.m[5] > 0\n                    ? Math.acos(-this.m[4] / s)\n                    : -Math.acos(this.m[4] / s)),\n            );\n        } else {\n            return 0;\n        }\n    }\n\n    getSkew() {\n        if (this.m[0] != 0 || this.m[1] != 0) {\n            const r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);\n            return new Vec2(\n                Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5])\n                    / (r * r),\n                0,\n            );\n        } else if (this.m[4] != 0 || this.m[5] != 0) {\n            const s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);\n            return new Vec2(\n                0,\n                Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5])\n                    / (s * s),\n            );\n        } else {\n            return new Vec2(0, 0);\n        }\n    }\n\n    invert(): Mat4 {\n        const out = [];\n\n        const f00 = this.m[10] * this.m[15] - this.m[14] * this.m[11];\n        const f01 = this.m[9] * this.m[15] - this.m[13] * this.m[11];\n        const f02 = this.m[9] * this.m[14] - this.m[13] * this.m[10];\n        const f03 = this.m[8] * this.m[15] - this.m[12] * this.m[11];\n        const f04 = this.m[8] * this.m[14] - this.m[12] * this.m[10];\n        const f05 = this.m[8] * this.m[13] - this.m[12] * this.m[9];\n        const f06 = this.m[6] * this.m[15] - this.m[14] * this.m[7];\n        const f07 = this.m[5] * this.m[15] - this.m[13] * this.m[7];\n        const f08 = this.m[5] * this.m[14] - this.m[13] * this.m[6];\n        const f09 = this.m[4] * this.m[15] - this.m[12] * this.m[7];\n        const f10 = this.m[4] * this.m[14] - this.m[12] * this.m[6];\n        const f11 = this.m[5] * this.m[15] - this.m[13] * this.m[7];\n        const f12 = this.m[4] * this.m[13] - this.m[12] * this.m[5];\n        const f13 = this.m[6] * this.m[11] - this.m[10] * this.m[7];\n        const f14 = this.m[5] * this.m[11] - this.m[9] * this.m[7];\n        const f15 = this.m[5] * this.m[10] - this.m[9] * this.m[6];\n        const f16 = this.m[4] * this.m[11] - this.m[8] * this.m[7];\n        const f17 = this.m[4] * this.m[10] - this.m[8] * this.m[6];\n        const f18 = this.m[4] * this.m[9] - this.m[8] * this.m[5];\n\n        out[0] = this.m[5] * f00 - this.m[6] * f01 + this.m[7] * f02;\n        out[4] = -(this.m[4] * f00 - this.m[6] * f03 + this.m[7] * f04);\n        out[8] = this.m[4] * f01 - this.m[5] * f03 + this.m[7] * f05;\n        out[12] = -(this.m[4] * f02 - this.m[5] * f04 + this.m[6] * f05);\n\n        out[1] = -(this.m[1] * f00 - this.m[2] * f01 + this.m[3] * f02);\n        out[5] = this.m[0] * f00 - this.m[2] * f03 + this.m[3] * f04;\n        out[9] = -(this.m[0] * f01 - this.m[1] * f03 + this.m[3] * f05);\n        out[13] = this.m[0] * f02 - this.m[1] * f04 + this.m[2] * f05;\n\n        out[2] = this.m[1] * f06 - this.m[2] * f07 + this.m[3] * f08;\n        out[6] = -(this.m[0] * f06 - this.m[2] * f09 + this.m[3] * f10);\n        out[10] = this.m[0] * f11 - this.m[1] * f09 + this.m[3] * f12;\n        out[14] = -(this.m[0] * f08 - this.m[1] * f10 + this.m[2] * f12);\n\n        out[3] = -(this.m[1] * f13 - this.m[2] * f14 + this.m[3] * f15);\n        out[7] = this.m[0] * f13 - this.m[2] * f16 + this.m[3] * f17;\n        out[11] = -(this.m[0] * f14 - this.m[1] * f16 + this.m[3] * f18);\n        out[15] = this.m[0] * f15 - this.m[1] * f17 + this.m[2] * f18;\n\n        const det = this.m[0] * out[0]\n            + this.m[1] * out[4]\n            + this.m[2] * out[8]\n            + this.m[3] * out[12];\n\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                out[i * 4 + j] *= 1.0 / det;\n            }\n        }\n\n        return new Mat4(out);\n    }\n\n    clone(): Mat4 {\n        return new Mat4([...this.m]);\n    }\n\n    toString(): string {\n        return this.m.toString();\n    }\n}\n\nexport function wave(\n    lo: number,\n    hi: number,\n    t: number,\n    f = (t) => -Math.cos(t),\n): number {\n    return lo + (f(t) + 1) / 2 * (hi - lo);\n}\n\n// basic ANSI C LCG\nconst A = 1103515245;\nconst C = 12345;\nconst M = 2147483648;\n\nexport class RNG {\n    seed: number;\n    constructor(seed: number) {\n        this.seed = seed;\n    }\n    gen(): number {\n        this.seed = (A * this.seed + C) % M;\n        return this.seed / M;\n    }\n    genNumber(a: number, b: number): number {\n        return a + this.gen() * (b - a);\n    }\n    genVec2(a: Vec2, b?: Vec2): Vec2 {\n        return new Vec2(\n            this.genNumber(a.x, b.x),\n            this.genNumber(a.y, b.y),\n        );\n    }\n    genColor(a: Color, b: Color): Color {\n        return new Color(\n            this.genNumber(a.r, b.r),\n            this.genNumber(a.g, b.g),\n            this.genNumber(a.b, b.b),\n        );\n    }\n    genAny<T = RNGValue>(...args: T[]): T {\n        if (args.length === 0) {\n            return this.gen() as T;\n        } else if (args.length === 1) {\n            if (typeof args[0] === \"number\") {\n                return this.genNumber(0, args[0]) as T;\n            } else if (args[0] instanceof Vec2) {\n                return this.genVec2(vec2(0, 0), args[0]) as T;\n            } else if (args[0] instanceof Color) {\n                return this.genColor(rgb(0, 0, 0), args[0]) as T;\n            }\n        } else if (args.length === 2) {\n            if (typeof args[0] === \"number\" && typeof args[1] === \"number\") {\n                return this.genNumber(args[0], args[1]) as T;\n            } else if (args[0] instanceof Vec2 && args[1] instanceof Vec2) {\n                return this.genVec2(args[0], args[1]) as T;\n            } else if (args[0] instanceof Color && args[1] instanceof Color) {\n                return this.genColor(args[0], args[1]) as T;\n            }\n        }\n    }\n}\n\n// TODO: let user pass seed\nconst defRNG = new RNG(Date.now());\n\nexport function randSeed(seed?: number): number {\n    if (seed != null) {\n        defRNG.seed = seed;\n    }\n    return defRNG.seed;\n}\n\nexport function rand(...args) {\n    // @ts-ignore\n    return defRNG.genAny(...args);\n}\n\n// TODO: randi() to return 0 / 1?\nexport function randi(...args: number[]) {\n    return Math.floor(rand(...args));\n}\n\nexport function chance(p: number): boolean {\n    return rand() <= p;\n}\n\nexport function shuffle<T>(list: T[]): T[] {\n    for (let i = list.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [list[i], list[j]] = [list[j], list[i]];\n    }\n    return list;\n}\n\nexport function chooseMultiple<T>(list: T[], count: number): T[] {\n    return list.length <= count\n        ? list.slice()\n        : shuffle(list.slice()).slice(0, count);\n}\n\nexport function choose<T>(list: T[]): T {\n    return list[randi(list.length)];\n}\n\n// TODO: better name\nexport function testRectRect2(r1: Rect, r2: Rect): boolean {\n    return r1.pos.x + r1.width >= r2.pos.x\n        && r1.pos.x <= r2.pos.x + r2.width\n        && r1.pos.y + r1.height >= r2.pos.y\n        && r1.pos.y <= r2.pos.y + r2.height;\n}\n\nexport function testRectRect(r1: Rect, r2: Rect): boolean {\n    return r1.pos.x + r1.width > r2.pos.x\n        && r1.pos.x < r2.pos.x + r2.width\n        && r1.pos.y + r1.height > r2.pos.y\n        && r1.pos.y < r2.pos.y + r2.height;\n}\n\n// TODO: better name\nexport function testLineLineT(l1: Line, l2: Line): number | null {\n    if (\n        (l1.p1.x === l1.p2.x && l1.p1.y === l1.p2.y)\n        || (l2.p1.x === l2.p2.x && l2.p1.y === l2.p2.y)\n    ) {\n        return null;\n    }\n\n    const denom = (l2.p2.y - l2.p1.y) * (l1.p2.x - l1.p1.x)\n        - (l2.p2.x - l2.p1.x) * (l1.p2.y - l1.p1.y);\n\n    // parallel\n    if (denom === 0) {\n        return null;\n    }\n\n    const ua = ((l2.p2.x - l2.p1.x) * (l1.p1.y - l2.p1.y)\n        - (l2.p2.y - l2.p1.y) * (l1.p1.x - l2.p1.x)) / denom;\n    const ub = ((l1.p2.x - l1.p1.x) * (l1.p1.y - l2.p1.y)\n        - (l1.p2.y - l1.p1.y) * (l1.p1.x - l2.p1.x)) / denom;\n\n    // is the intersection on the segments\n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n        return null;\n    }\n\n    return ua;\n}\n\nexport function testLineLine(l1: Line, l2: Line): Vec2 | null {\n    const t = testLineLineT(l1, l2);\n    if (!t) return null;\n    return vec2(\n        l1.p1.x + t * (l1.p2.x - l1.p1.x),\n        l1.p1.y + t * (l1.p2.y - l1.p1.y),\n    );\n}\n\nexport function testRectLine(r: Rect, l: Line): boolean {\n    /*if (testRectPoint(r, l.p1) || testRectPoint(r, l.p2)) {\n\t\treturn true\n\t}\n\tconst pts = r.points()\n\treturn !!testLineLine(l, new Line(pts[0], pts[1]))\n\t\t|| !!testLineLine(l, new Line(pts[1], pts[2]))\n\t\t|| !!testLineLine(l, new Line(pts[2], pts[3]))\n\t\t|| !!testLineLine(l, new Line(pts[3], pts[0]))*/\n    const dir = l.p2.sub(l.p1);\n    let tmin = Number.NEGATIVE_INFINITY, tmax = Number.POSITIVE_INFINITY;\n\n    if (dir.x != 0.0) {\n        const tx1 = (r.pos.x - l.p1.x) / dir.x;\n        const tx2 = (r.pos.x + r.width - l.p1.x) / dir.x;\n\n        tmin = Math.max(tmin, Math.min(tx1, tx2));\n        tmax = Math.min(tmax, Math.max(tx1, tx2));\n    }\n\n    if (dir.y != 0.0) {\n        const ty1 = (r.pos.y - l.p1.y) / dir.y;\n        const ty2 = (r.pos.y + r.height - l.p1.y) / dir.y;\n\n        tmin = Math.max(tmin, Math.min(ty1, ty2));\n        tmax = Math.min(tmax, Math.max(ty1, ty2));\n    }\n\n    return tmax >= tmin && tmax >= 0 && tmin <= 1;\n}\n\nexport function testRectPoint2(r: Rect, pt: Point): boolean {\n    return pt.x >= r.pos.x\n        && pt.x <= r.pos.x + r.width\n        && pt.y >= r.pos.y\n        && pt.y <= r.pos.y + r.height;\n}\n\nexport function testRectPoint(r: Rect, pt: Point): boolean {\n    return pt.x > r.pos.x\n        && pt.x < r.pos.x + r.width\n        && pt.y > r.pos.y\n        && pt.y < r.pos.y + r.height;\n}\n\nexport function testRectCircle(r: Rect, c: Circle): boolean {\n    const nx = Math.max(r.pos.x, Math.min(c.center.x, r.pos.x + r.width));\n    const ny = Math.max(r.pos.y, Math.min(c.center.y, r.pos.y + r.height));\n    const nearestPoint = vec2(nx, ny);\n    return nearestPoint.sdist(c.center) <= c.radius * c.radius;\n}\n\nexport function testRectPolygon(r: Rect, p: Polygon): boolean {\n    return testPolygonPolygon(p, new Polygon(r.points()));\n}\n\nexport function testLinePoint(l: Line, pt: Vec2): boolean {\n    const v1 = pt.sub(l.p1);\n    const v2 = l.p2.sub(l.p1);\n\n    // Check if sine is 0, in that case lines are parallel.\n    // If not parallel, the point cannot lie on the line.\n    if (Math.abs(v1.cross(v2)) > Number.EPSILON) {\n        return false;\n    }\n\n    // Scalar projection of v1 on v2\n    const t = v1.dot(v2) / v2.dot(v2);\n    // Since t is percentual distance of pt from line.p1 on the line,\n    // it should be between 0% and 100%\n    return t >= 0 && t <= 1;\n}\n\nexport function testLineCircle(l: Line, circle: Circle): boolean {\n    const v = l.p2.sub(l.p1);\n    const a = v.dot(v);\n    const centerToOrigin = l.p1.sub(circle.center);\n    const b = 2 * v.dot(centerToOrigin);\n    const c = centerToOrigin.dot(centerToOrigin)\n        - circle.radius * circle.radius;\n    // Calculate the discriminant of ax^2 + bx + c\n    const dis = b * b - 4 * a * c;\n\n    // No root\n    if ((a <= Number.EPSILON) || (dis < 0)) {\n        return false;\n    } // One possible root\n    else if (dis == 0) {\n        const t = -b / (2 * a);\n        if (t >= 0 && t <= 1) {\n            return true;\n        }\n    } // Two possible roots\n    else {\n        const t1 = (-b + Math.sqrt(dis)) / (2 * a);\n        const t2 = (-b - Math.sqrt(dis)) / (2 * a);\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true;\n        }\n    }\n\n    // Check if line is completely within the circle\n    // We only need to check one point, since the line didn't cross the circle\n    return testCirclePoint(circle, l.p1);\n}\n\nexport function testLinePolygon(l: Line, p: Polygon): boolean {\n    // test if line is inside\n    if (testPolygonPoint(p, l.p1) || testPolygonPoint(p, l.p2)) {\n        return true;\n    }\n\n    // test each line\n    for (let i = 0; i < p.pts.length; i++) {\n        const p1 = p.pts[i];\n        const p2 = p.pts[(i + 1) % p.pts.length];\n        if (testLineLine(l, new Line(p1, p2))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function testCirclePoint(c: Circle, p: Point): boolean {\n    return c.center.sdist(p) < c.radius * c.radius;\n}\n\nexport function testCircleCircle(c1: Circle, c2: Circle): boolean {\n    return c1.center.sdist(c2.center)\n        < (c1.radius + c2.radius) * (c1.radius + c2.radius);\n}\n\nexport function testCirclePolygon(c: Circle, p: Polygon): boolean {\n    // For each edge check for intersection\n    let prev = p.pts[p.pts.length - 1];\n    for (const cur of p.pts) {\n        if (testLineCircle(new Line(prev, cur), c)) {\n            return true;\n        }\n        prev = cur;\n    }\n\n    // Check if the polygon is completely within the circle\n    // We only need to check one point, since the polygon didn't cross the circle\n    if (testCirclePoint(c, p.pts[0])) {\n        return true;\n    }\n\n    // Check if the circle is completely within the polygon\n    return testPolygonPoint(p, c.center);\n}\n\nexport function testPolygonPolygon(p1: Polygon, p2: Polygon): boolean {\n    for (let i = 0; i < p1.pts.length; i++) {\n        if (\n            testLinePolygon(\n                new Line(p1.pts[i], p1.pts[(i + 1) % p1.pts.length]),\n                p2,\n            )\n        ) {\n            return true;\n        }\n    }\n    // Check if any of the points of the polygon lie in the other polygon\n    if (\n        p1.pts.some(p => testPolygonPoint(p2, p))\n        || p2.pts.some(p => testPolygonPoint(p1, p))\n    ) {\n        return true;\n    }\n    return false;\n}\n\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\nexport function testPolygonPoint(poly: Polygon, pt: Point): boolean {\n    let c = false;\n    const p = poly.pts;\n\n    for (let i = 0, j = p.length - 1; i < p.length; j = i++) {\n        if (\n            ((p[i].y > pt.y) != (p[j].y > pt.y))\n            && (pt.x\n                < (p[j].x - p[i].x) * (pt.y - p[i].y) / (p[j].y - p[i].y)\n                    + p[i].x)\n        ) {\n            c = !c;\n        }\n    }\n\n    return c;\n}\n\nexport function testEllipsePoint(ellipse: Ellipse, pt: Point): boolean {\n    // Transform the point into the ellipse's unrotated coordinate system at the origin\n    pt = pt.sub(ellipse.center);\n    const angle = deg2rad(ellipse.angle);\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const vx = pt.x * c + pt.y * s;\n    const vy = -pt.x * s + pt.y * c;\n    return vx * vx / (ellipse.radiusX * ellipse.radiusX)\n            + vy * vy / (ellipse.radiusY * ellipse.radiusY) < 1;\n}\n\nexport function testEllipseCircle(ellipse: Ellipse, circle: Circle): boolean {\n    // This is an approximation, because the parallel curve of an ellipse is an octic algebraic curve, not just a larger ellipse.\n    // Transform the circle's center into the ellipse's unrotated coordinate system at the origin\n    const center = circle.center.sub(ellipse.center);\n    const angle = deg2rad(ellipse.angle);\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const cx = center.x * c + center.y * s;\n    const cy = -center.x * s + center.y * c;\n    // Test with an approximate Minkowski sum of the ellipse and the circle\n    return testEllipsePoint(\n        new Ellipse(\n            vec2(),\n            ellipse.radiusX + circle.radius,\n            ellipse.radiusY + circle.radius,\n            0,\n        ),\n        vec2(cx, cy),\n    );\n}\n\nexport function testEllipseLine(ellipse: Ellipse, line: Line): boolean {\n    // Transform the line to the coordinate system where the ellipse is a unit circle\n    const T = ellipse.toMat2().inverse;\n    line = new Line(\n        T.transform(line.p1.sub(ellipse.center)),\n        T.transform(line.p2.sub(ellipse.center)),\n    );\n    return testLineCircle(line, new Circle(vec2(), 1));\n}\n\nexport function testEllipseEllipse(\n    ellipse1: Ellipse,\n    ellipse2: Ellipse,\n): boolean {\n    // First check if one of the ellipses isn't secretly a circle\n    if (ellipse1.radiusX === ellipse1.radiusY) {\n        return testEllipseCircle(\n            ellipse2,\n            new Circle(ellipse1.center, ellipse1.radiusX),\n        );\n    } else if (ellipse2.radiusX === ellipse2.radiusY) {\n        return testEllipseCircle(\n            ellipse1,\n            new Circle(ellipse2.center, ellipse2.radiusX),\n        );\n    }\n    // No luck, we need to solve the equation\n    /*\n\tEtayo, Fernando, Laureano Gonzalez-Vega, and Natalia del Rio. \"A new approach to characterizing the relative position of two ellipses depending on one parameter.\" Computer aided geometric design 23, no. 4 (2006): 324-350.\n\t*/\n    const A1 = new Mat3(\n        1 / ellipse1.radiusX ** 2,\n        0,\n        0,\n        0,\n        1 / ellipse1.radiusY ** 2,\n        0,\n        0,\n        0,\n        -1,\n    );\n    const A2 = new Mat3(\n        1 / ellipse2.radiusX ** 2,\n        0,\n        0,\n        0,\n        1 / ellipse2.radiusY ** 2,\n        0,\n        0,\n        0,\n        -1,\n    );\n\n    const x1 = ellipse1.center.x;\n    const y1 = ellipse1.center.y;\n    const x2 = ellipse2.center.x;\n    const y2 = ellipse2.center.y;\n    const theta1 = deg2rad(ellipse1.angle);\n    const theta2 = deg2rad(ellipse2.angle);\n\n    const M1 = new Mat3(\n        Math.cos(theta1),\n        -Math.sin(theta1),\n        x1,\n        Math.sin(theta1),\n        Math.cos(theta1),\n        y1,\n        0,\n        0,\n        1,\n    );\n    const M2 = new Mat3(\n        Math.cos(theta2),\n        -Math.sin(theta2),\n        x2,\n        Math.sin(theta2),\n        Math.cos(theta2),\n        y2,\n        0,\n        0,\n        1,\n    );\n    const M1inv = M1.inverse;\n    const M2inv = M2.inverse;\n\n    const A = M1inv.transpose.mul(A1).mul(M1inv);\n    const B = M2inv.transpose.mul(A2).mul(M2inv);\n\n    const a11 = A.m11;\n    const a12 = A.m12;\n    const a13 = A.m13;\n    const a21 = A.m21;\n    const a22 = A.m22;\n    const a23 = A.m23;\n    const a31 = A.m31;\n    const a32 = A.m32;\n    const a33 = A.m33;\n\n    const b11 = B.m11;\n    const b12 = B.m12;\n    const b13 = B.m13;\n    const b21 = B.m21;\n    const b22 = B.m22;\n    const b23 = B.m23;\n    const b31 = B.m31;\n    const b32 = B.m32;\n    const b33 = B.m33;\n\n    const factor = a11 * a22 * a33 - a11 * a23 * a32 - a12 * a21 * a33\n        + a12 * a23 * a31 + a13 * a21 * a32 - a13 * a22 * a31;\n    const a =\n        (a11 * a22 * b33 - a11 * a23 * b32 - a11 * a32 * b23 + a11 * a33 * b22\n            - a12 * a21 * b33 + a12 * a23 * b31 + a12 * a31 * b23\n            - a12 * a33 * b21 + a13 * a21 * b32 - a13 * a22 * b31\n            - a13 * a31 * b22 + a13 * a32 * b21 + a21 * a32 * b13\n            - a21 * a33 * b12 - a22 * a31 * b13 + a22 * a33 * b11\n            + a23 * a31 * b12 - a23 * a32 * b11) / factor;\n    const b =\n        (a11 * b22 * b33 - a11 * b23 * b32 - a12 * b21 * b33 + a12 * b23 * b31\n            + a13 * b21 * b32 - a13 * b22 * b31 - a21 * b12 * b33\n            + a21 * b13 * b32 + a22 * b11 * b33 - a22 * b13 * b31\n            - a23 * b11 * b32 + a23 * b12 * b31 + a31 * b12 * b23\n            - a31 * b13 * b22 - a32 * b11 * b23 + a32 * b13 * b21\n            + a33 * b11 * b22 - a33 * b12 * b21) / factor;\n    const c =\n        (b11 * b22 * b33 - b11 * b23 * b32 - b12 * b21 * b33 + b12 * b23 * b31\n            + b13 * b21 * b32 - b13 * b22 * b31) / factor;\n\n    if (a >= 0) {\n        const condition1 = -3 * b + a ** 2;\n        const condition2 = 3 * a * c + b * a ** 2 - 4 * b ** 2;\n        const condition3 = -27 * c ** 2 + 18 * c * a * b + a ** 2 * b ** 2\n            - 4 * a ** 3 * c - 4 * b ** 3;\n        if (condition1 > 0 && condition2 < 0 && condition3 > 0) {\n            return false;\n        } else {\n            return true;\n        }\n    } else {\n        const condition1 = -3 * b + a ** 2;\n        const condition2 = -27 * c ** 2 + 18 * c * a * b + a ** 2 * b ** 2\n            - 4 * a ** 3 * c - 4 * b ** 3;\n        if (condition1 > 0 && condition2 > 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nexport function testEllipseRect(ellipse: Ellipse, rect: Rect): boolean {\n    return testEllipsePolygon(ellipse, new Polygon(rect.points()));\n}\n\nexport function testEllipsePolygon(ellipse: Ellipse, poly: Polygon): boolean {\n    // Transform the polygon to the coordinate system where the ellipse is a unit circle\n    const T = ellipse.toMat2().inverse;\n    poly = new Polygon(poly.pts.map(p => T.transform(p.sub(ellipse.center))));\n    return testCirclePolygon(new Circle(vec2(), 1), poly);\n}\n\nexport function testPointPoint(p1: Point, p2: Point): boolean {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\nexport type ShapeType = Vec2 | Circle | Line | Rect | Polygon | Ellipse;\n\nexport function testPointShape(point: Point, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testPointPoint(shape as Point, point);\n    } else if (shape instanceof Circle) {\n        return testCirclePoint(shape as Circle, point);\n    } else if (shape instanceof Line) {\n        return testLinePoint(shape as Line, point as Vec2);\n    } else if (shape instanceof Rect) {\n        return testRectPoint(shape as Rect, point);\n    } else if (shape instanceof Polygon) {\n        return testPolygonPoint(shape as Polygon, point);\n    } else if (shape instanceof Ellipse) {\n        return testEllipsePoint(shape as Ellipse, point);\n    } else {\n        return false;\n    }\n}\n\nexport function testLineShape(line: Line, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testLinePoint(line, shape as Vec2);\n    } else if (shape instanceof Circle) {\n        return testLineCircle(line, shape as Circle);\n    } else if (shape instanceof Line) {\n        return testLineLine(line, shape as Line) != null;\n    } else if (shape instanceof Rect) {\n        return testRectLine(shape as Rect, line);\n    } else if (shape instanceof Polygon) {\n        return testLinePolygon(line, shape as Polygon);\n    } else if (shape instanceof Ellipse) {\n        return testEllipseLine(shape as Ellipse, line);\n    } else {\n        return false;\n    }\n}\n\nexport function testCircleShape(circle: Circle, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testCirclePoint(circle, shape as Point);\n    } else if (shape instanceof Circle) {\n        return testCircleCircle(circle, shape as Circle);\n    } else if (shape instanceof Line) {\n        return testLineCircle(shape as Line, circle);\n    } else if (shape instanceof Rect) {\n        return testRectCircle(shape as Rect, circle);\n    } else if (shape instanceof Polygon) {\n        return testCirclePolygon(circle, shape as Polygon);\n    } else if (shape instanceof Ellipse) {\n        return testEllipseCircle(shape as Ellipse, circle);\n    } else {\n        return false;\n    }\n}\n\nexport function testRectShape(rect: Rect, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testRectPoint(rect, shape as Point);\n    } else if (shape instanceof Circle) {\n        return testRectCircle(rect, shape as Circle);\n    } else if (shape instanceof Line) {\n        return testRectLine(rect, shape as Line);\n    } else if (shape instanceof Rect) {\n        return testRectRect(rect, shape as Rect);\n    } else if (shape instanceof Polygon) {\n        return testRectPolygon(rect, shape as Polygon);\n    } else if (shape instanceof Ellipse) {\n        return testEllipseRect(shape as Ellipse, rect);\n    } else {\n        return false;\n    }\n}\n\nexport function testPolygonShape(polygon: Polygon, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testPolygonPoint(polygon, shape as Point);\n    } else if (shape instanceof Circle) {\n        return testCirclePolygon(shape as Circle, polygon);\n    } else if (shape instanceof Line) {\n        return testLinePolygon(shape as Line, polygon);\n    } else if (shape instanceof Rect) {\n        return testRectPolygon(shape as Rect, polygon);\n    } else if (shape instanceof Polygon) {\n        return testPolygonPolygon(shape as Polygon, polygon);\n    } else if (shape instanceof Ellipse) {\n        return testEllipsePolygon(shape as Ellipse, polygon);\n    } else {\n        return false;\n    }\n}\n\nexport function testEllipseShape(ellipse: Ellipse, shape: ShapeType): boolean {\n    if (shape instanceof Vec2) {\n        return testEllipsePoint(ellipse, shape as Point);\n    } else if (shape instanceof Circle) {\n        return testEllipseCircle(ellipse, shape as Circle);\n    } else if (shape instanceof Line) {\n        return testEllipseLine(ellipse, shape as Line);\n    } else if (shape instanceof Rect) {\n        return testEllipseRect(ellipse, shape as Rect);\n    } else if (shape instanceof Polygon) {\n        return testEllipsePolygon(ellipse, shape as Polygon);\n    } else if (shape instanceof Ellipse) {\n        return testEllipseEllipse(shape as Ellipse, ellipse);\n    } else {\n        return false;\n    }\n}\n\nexport function testShapeShape(shape1: ShapeType, shape2: ShapeType): boolean {\n    if (shape1 instanceof Vec2) {\n        return testPointShape(shape1 as Vec2, shape2);\n    } else if (shape1 instanceof Circle) {\n        return testCircleShape(shape1 as Circle, shape2);\n    } else if (shape1 instanceof Line) {\n        return testLineShape(shape1 as Line, shape2);\n    } else if (shape1 instanceof Rect) {\n        return testRectShape(shape1 as Rect, shape2);\n    } else if (shape1 instanceof Polygon) {\n        return testPolygonShape(shape1 as Polygon, shape2);\n    } else if (shape1 instanceof Ellipse) {\n        return testEllipseShape(shape1 as Ellipse, shape2);\n    } else {\n        return false;\n    }\n}\n\nexport type RaycastHit = {\n    fraction: number;\n    normal: Vec2;\n    point: Vec2;\n    gridPos?: Vec2;\n};\n\nexport type RaycastResult = RaycastHit | null;\n\nfunction raycastLine(origin: Vec2, direction: Vec2, line: Line): RaycastResult {\n    const a = origin;\n    const c = line.p1;\n    const d = line.p2;\n    const ab = direction;\n    const cd = d.sub(c);\n    const abxcd = ab.cross(cd);\n    // If parallel, no intersection\n    if (Math.abs(abxcd) < Number.EPSILON) {\n        return null;\n    }\n    const ac = c.sub(a);\n    const s = ac.cross(cd) / abxcd;\n    // Outside the ray\n    if (s <= 0 || s >= 1) {\n        return null;\n    }\n    // Outside the line\n    const t = ac.cross(ab) / abxcd;\n    if (t <= 0 || t >= 1) {\n        return null;\n    }\n\n    const normal = cd.normal().unit();\n    if (direction.dot(normal) > 0) {\n        normal.x *= -1;\n        normal.y *= -1;\n    }\n\n    return {\n        point: a.add(ab.scale(s)),\n        normal: normal,\n        fraction: s,\n    };\n}\n\nfunction raycastRect(origin: Vec2, direction: Vec2, rect: Rect) {\n    let tmin = Number.NEGATIVE_INFINITY, tmax = Number.POSITIVE_INFINITY;\n    let normal;\n\n    if (origin.x != 0.0) {\n        const tx1 = (rect.pos.x - origin.x) / direction.x;\n        const tx2 = (rect.pos.x + rect.width - origin.x) / direction.x;\n\n        normal = vec2(-Math.sign(direction.x), 0);\n\n        tmin = Math.max(tmin, Math.min(tx1, tx2));\n        tmax = Math.min(tmax, Math.max(tx1, tx2));\n    }\n\n    if (origin.y != 0.0) {\n        const ty1 = (rect.pos.y - origin.y) / direction.y;\n        const ty2 = (rect.pos.y + rect.height - origin.y) / direction.y;\n\n        if (Math.min(ty1, ty2) > tmin) {\n            normal = vec2(0, -Math.sign(direction.y));\n        }\n\n        tmin = Math.max(tmin, Math.min(ty1, ty2));\n        tmax = Math.min(tmax, Math.max(ty1, ty2));\n    }\n\n    if (tmax >= tmin && tmin >= 0 && tmin <= 1) {\n        const point = origin.add(direction.scale(tmin));\n        return {\n            point: point,\n            normal: normal,\n            fraction: tmin,\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction raycastCircle(\n    origin: Vec2,\n    direction: Vec2,\n    circle: Circle,\n): RaycastResult {\n    const a = origin;\n    const c = circle.center;\n    const ab = direction;\n    const A = ab.dot(ab);\n    const centerToOrigin = a.sub(c);\n    const B = 2 * ab.dot(centerToOrigin);\n    const C = centerToOrigin.dot(centerToOrigin)\n        - circle.radius * circle.radius;\n    // Calculate the discriminant of ax^2 + bx + c\n    const disc = B * B - 4 * A * C;\n    // No root\n    if ((A <= Number.EPSILON) || (disc < 0)) {\n        return null;\n    } // One possible root\n    else if (disc == 0) {\n        const t = -B / (2 * A);\n        if (t >= 0 && t <= 1) {\n            const point = a.add(ab.scale(t));\n            return {\n                point: point,\n                normal: point.sub(c),\n                fraction: t,\n            };\n        }\n    } // Two possible roots\n    else {\n        const t1 = (-B + Math.sqrt(disc)) / (2 * A);\n        const t2 = (-B - Math.sqrt(disc)) / (2 * A);\n        let t = null;\n        if (t1 >= 0 && t1 <= 1) {\n            t = t1;\n        }\n        if (t2 >= 0 && t2 <= 1) {\n            t = Math.min(t2, t ?? t2);\n        }\n        if (t != null) {\n            const point = a.add(ab.scale(t));\n            return {\n                point: point,\n                normal: point.sub(c).unit(),\n                fraction: t,\n            };\n        }\n    }\n\n    return null;\n}\n\nfunction raycastPolygon(\n    origin: Vec2,\n    direction: Vec2,\n    polygon: Polygon,\n): RaycastResult {\n    const points = polygon.pts;\n    let minHit = null;\n\n    let prev = points[points.length - 1];\n    for (let i = 0; i < points.length; i++) {\n        const cur = points[i];\n        const hit = raycastLine(origin, direction, new Line(prev, cur));\n        if (hit && (!minHit || minHit.fraction > hit.fraction)) {\n            minHit = hit;\n        }\n        prev = cur;\n    }\n\n    return minHit;\n}\n\nfunction raycastEllipse(\n    origin: Vec2,\n    direction: Vec2,\n    ellipse: Ellipse,\n): RaycastResult {\n    // Transforms from unit circle to rotated ellipse\n    const T = ellipse.toMat2();\n    // Transforms from rotated ellipse to unit circle\n    const TI = T.inverse;\n    // Transform both origin and direction into the unit circle coordinate system\n    const Torigin = TI.transform(origin.sub(ellipse.center));\n    const Tdirection = TI.transform(direction);\n    // Raycast as if we have a circle\n    const result = raycastCircle(Torigin, Tdirection, new Circle(vec2(), 1));\n    if (result) {\n        const R = Mat2.rotation(deg2rad(-ellipse.angle));\n        const S = Mat2.scale(ellipse.radiusX, ellipse.radiusY);\n        // Scale the point so we have a point on the unrotated ellipse\n        const p = S.transform(result.point);\n        // transform the result point to the coordinate system of the rotated ellipse\n        const point = T.transform(result.point).add(ellipse.center);\n        const fraction = point.dist(origin) / direction.len();\n        return {\n            point: point,\n            // Calculate the normal at the unrotated ellipse, then rotate the normal to the rotated ellipse\n            normal: R.transform(\n                vec2(ellipse.radiusY ** 2 * p.x, ellipse.radiusX ** 2 * p.y),\n            ),\n            fraction,\n        };\n    }\n    return result;\n}\n\nexport function raycastGrid(\n    origin: Vec2,\n    direction: Vec2,\n    gridPosHit: (gridPos: Vec2) => boolean,\n    maxDistance: number = 64,\n): RaycastResult | null {\n    const pos = origin;\n    const len = direction.len();\n    const dir = direction.scale(1 / len);\n    let t = 0;\n    const gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));\n    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);\n    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));\n    const dist = vec2(\n        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),\n        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y),\n    );\n    const tMax = vec2(\n        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,\n        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity,\n    );\n    let steppedIndex = -1;\n    while (t <= maxDistance) {\n        const hit = gridPosHit(gridPos);\n        if (hit === true) {\n            return {\n                point: pos.add(dir.scale(t)),\n                normal: vec2(\n                    steppedIndex === 0 ? -step.x : 0,\n                    steppedIndex === 1 ? -step.y : 0,\n                ),\n                fraction: t / len, // Since dir is normalized, t is len times too large\n                gridPos,\n            };\n        } else if (hit) {\n            return hit;\n        }\n        if (tMax.x < tMax.y) {\n            gridPos.x += step.x;\n            t = tMax.x;\n            tMax.x += tDelta.x;\n            steppedIndex = 0;\n        } else {\n            gridPos.y += step.y;\n            t = tMax.y;\n            tMax.y += tDelta.y;\n            steppedIndex = 1;\n        }\n    }\n\n    return null;\n}\n\nexport class Line {\n    p1: Vec2;\n    p2: Vec2;\n    constructor(p1: Vec2, p2: Vec2) {\n        this.p1 = p1.clone();\n        this.p2 = p2.clone();\n    }\n    transform(m: Mat4): Line {\n        return new Line(m.multVec2(this.p1), m.multVec2(this.p2));\n    }\n    bbox(): Rect {\n        return Rect.fromPoints(this.p1, this.p2);\n    }\n    area(): number {\n        return this.p1.dist(this.p2);\n    }\n    clone(): Line {\n        return new Line(this.p1, this.p2);\n    }\n    collides(shape: ShapeType): boolean {\n        return testLineShape(this, shape);\n    }\n    contains(point: Vec2): boolean {\n        return this.collides(point);\n    }\n    raycast(origin: Vec2, direction: Vec2): RaycastResult {\n        return raycastLine(origin, direction, this);\n    }\n}\n\n// TODO: use x: number y: number (x, y, width, height)\nexport class Rect {\n    pos: Vec2;\n    width: number;\n    height: number;\n    constructor(pos: Vec2, width: number, height: number) {\n        this.pos = pos.clone();\n        this.width = width;\n        this.height = height;\n    }\n    static fromPoints(p1: Vec2, p2: Vec2): Rect {\n        return new Rect(p1.clone(), p2.x - p1.x, p2.y - p1.y);\n    }\n    center(): Vec2 {\n        return new Vec2(\n            this.pos.x + this.width / 2,\n            this.pos.y + this.height / 2,\n        );\n    }\n    points(): [Vec2, Vec2, Vec2, Vec2] {\n        return [\n            this.pos,\n            this.pos.add(this.width, 0),\n            this.pos.add(this.width, this.height),\n            this.pos.add(0, this.height),\n        ];\n    }\n    transform(m: Mat4): Polygon {\n        return new Polygon(this.points().map((pt) => m.multVec2(pt)));\n    }\n    bbox(): Rect {\n        return this.clone();\n    }\n    area(): number {\n        return this.width * this.height;\n    }\n    clone(): Rect {\n        return new Rect(this.pos.clone(), this.width, this.height);\n    }\n    distToPoint(p: Vec2): number {\n        return Math.sqrt(this.sdistToPoint(p));\n    }\n    sdistToPoint(p: Vec2): number {\n        const min = this.pos;\n        const max = this.pos.add(this.width, this.height);\n        const dx = Math.max(min.x - p.x, 0, p.x - max.x);\n        const dy = Math.max(min.y - p.y, 0, p.y - max.y);\n        return dx * dx + dy * dy;\n    }\n    collides(shape: ShapeType): boolean {\n        return testRectShape(this, shape);\n    }\n    contains(point: Vec2): boolean {\n        return this.collides(point);\n    }\n    raycast(origin: Vec2, direction: Vec2): RaycastResult {\n        return raycastRect(origin, direction, this);\n    }\n}\n\nexport class Circle {\n    center: Vec2;\n    radius: number;\n    constructor(center: Vec2, radius: number) {\n        this.center = center.clone();\n        this.radius = radius;\n    }\n    transform(tr: Mat4): Ellipse {\n        return new Ellipse(this.center, this.radius, this.radius).transform(tr);\n    }\n    bbox(): Rect {\n        return Rect.fromPoints(\n            this.center.sub(vec2(this.radius)),\n            this.center.add(vec2(this.radius)),\n        );\n    }\n    area(): number {\n        return this.radius * this.radius * Math.PI;\n    }\n    clone(): Circle {\n        return new Circle(this.center, this.radius);\n    }\n    collides(shape: ShapeType): boolean {\n        return testCircleShape(this, shape);\n    }\n    contains(point: Vec2): boolean {\n        return this.collides(point);\n    }\n    raycast(origin: Vec2, direction: Vec2): RaycastResult {\n        return raycastCircle(origin, direction, this);\n    }\n}\n\nexport class Ellipse {\n    center: Vec2;\n    radiusX: number;\n    radiusY: number;\n    angle: number;\n    constructor(center: Vec2, rx: number, ry: number, degrees: number = 0) {\n        this.center = center.clone();\n        this.radiusX = rx;\n        this.radiusY = ry;\n        this.angle = degrees;\n    }\n    static fromMat2(tr: Mat2): Ellipse {\n        const inv = tr.inverse;\n        const M = inv.transpose.mul(inv);\n        const [e1, e2] = M.eigenvalues;\n        const [v1, v2] = M.eigenvectors(e1, e2);\n\n        const [a, b] = [1 / Math.sqrt(e1), 1 / Math.sqrt(e2)];\n\n        // Make sure we use the semi-major axis for the rotation\n        if (a > b) {\n            return new Ellipse(\n                vec2(),\n                a,\n                b,\n                rad2deg(Math.atan2(-v1[1], v1[0])),\n            );\n        } else {\n            return new Ellipse(\n                vec2(),\n                b,\n                a,\n                rad2deg(Math.atan2(-v2[1], v2[0])),\n            );\n        }\n    }\n    toMat2(): Mat2 {\n        const a = deg2rad(this.angle);\n        const c = Math.cos(a);\n        const s = Math.sin(a);\n        return new Mat2(\n            c * this.radiusX,\n            s * this.radiusY,\n            -s * this.radiusX,\n            c * this.radiusY,\n        );\n    }\n    transform(tr: Mat4): Ellipse {\n        if (this.angle == 0 && tr.getRotation() == 0) {\n            // No rotation, so we can just take the scale and translation\n            return new Ellipse(\n                tr.multVec2(this.center),\n                tr.m[0] * this.radiusX,\n                tr.m[5] * this.radiusY,\n            );\n        } else {\n            // Rotation. We can't just add angles, as the scale can squeeze the\n            // ellipse and thus change the angle.\n            // Get the transformation which maps the unit circle onto the ellipse\n            let T = this.toMat2();\n            // Transform the transformation matrix with the rotation+scale matrix\n            const angle = tr.getRotation();\n            const scale = tr.getScale();\n            const M = Mat3.fromMat2(T).scale(scale.x, scale.y).rotate(angle);\n            T = M.toMat2();\n            // Return the ellipse made from the transformed unit circle\n            const ellipse = Ellipse.fromMat2(T);\n            ellipse.center = tr.multVec2(this.center);\n            return ellipse;\n        }\n    }\n    bbox(): Rect {\n        if (this.angle == 0) {\n            // No rotation, so the semi-major and semi-minor axis give the extends\n            return Rect.fromPoints(\n                this.center.sub(vec2(this.radiusX, this.radiusY)),\n                this.center.add(vec2(this.radiusX, this.radiusY)),\n            );\n        } else {\n            // Rotation. We need to find the maximum x and y distance from the\n            // center of the rotated ellipse\n            const angle = deg2rad(this.angle);\n            const c = Math.cos(angle);\n            const s = Math.sin(angle);\n            const ux = this.radiusX * c;\n            const uy = this.radiusX * s;\n            const vx = this.radiusY * s;\n            const vy = this.radiusY * c;\n\n            const halfwidth = Math.sqrt(ux * ux + vx * vx);\n            const halfheight = Math.sqrt(uy * uy + vy * vy);\n\n            return Rect.fromPoints(\n                this.center.sub(vec2(halfwidth, halfheight)),\n                this.center.add(vec2(halfwidth, halfheight)),\n            );\n        }\n    }\n    area(): number {\n        return this.radiusX * this.radiusY * Math.PI;\n    }\n    clone(): Ellipse {\n        return new Ellipse(this.center, this.radiusX, this.radiusY, this.angle);\n    }\n    collides(shape: ShapeType): boolean {\n        return testEllipseShape(this, shape);\n    }\n    contains(point: Vec2): boolean {\n        // Both methods work, but the second one is faster\n        /*let T = this.toTransform()\n\t\tpoint = point.sub(this.center)\n\t\tpoint = T.inverse.transform(point)\n\t\treturn testCirclePoint(new Circle(vec2(), 1), point)*/\n        point = point.sub(this.center);\n        const angle = deg2rad(this.angle);\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const vx = point.x * c + point.y * s;\n        const vy = -point.x * s + point.y * c;\n        return vx * vx / (this.radiusX * this.radiusX)\n                + vy * vy / (this.radiusY * this.radiusY) < 1;\n    }\n    raycast(origin: Vec2, direction: Vec2): RaycastResult {\n        return raycastEllipse(origin, direction, this);\n    }\n}\n\nexport class Polygon {\n    pts: Vec2[];\n    constructor(pts: Vec2[]) {\n        if (pts.length < 3) {\n            throw new Error(\"Polygons should have at least 3 vertices\");\n        }\n        this.pts = pts;\n    }\n    transform(m: Mat4): Polygon {\n        return new Polygon(this.pts.map((pt) => m.multVec2(pt)));\n    }\n    bbox(): Rect {\n        const p1 = vec2(Number.MAX_VALUE);\n        const p2 = vec2(-Number.MAX_VALUE);\n        for (const pt of this.pts) {\n            p1.x = Math.min(p1.x, pt.x);\n            p2.x = Math.max(p2.x, pt.x);\n            p1.y = Math.min(p1.y, pt.y);\n            p2.y = Math.max(p2.y, pt.y);\n        }\n        return Rect.fromPoints(p1, p2);\n    }\n    area(): number {\n        let total = 0;\n        const l = this.pts.length;\n        for (let i = 0; i < l; i++) {\n            const p1 = this.pts[i];\n            const p2 = this.pts[(i + 1) % l];\n            total += p1.x * p2.y * 0.5;\n            total -= p2.x * p1.y * 0.5;\n        }\n        return Math.abs(total);\n    }\n    clone(): Polygon {\n        return new Polygon(this.pts.map((pt) => pt.clone()));\n    }\n    collides(shape: ShapeType): boolean {\n        return testPolygonShape(this, shape);\n    }\n    contains(point: Vec2): boolean {\n        return this.collides(point);\n    }\n    raycast(origin: Vec2, direction: Vec2): RaycastResult {\n        return raycastPolygon(origin, direction, this);\n    }\n}\n\nexport function evaluateBezier(\n    pt1: Vec2,\n    pt2: Vec2,\n    pt3: Vec2,\n    pt4: Vec2,\n    t: number,\n) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const mt = 1 - t;\n    const mt2 = mt * mt;\n    const mt3 = mt2 * mt;\n    return pt1.scale(mt3).add(pt2.scale(3 * mt2 * t)).add(\n        pt3.scale(3 * mt * t2),\n    ).add(pt4.scale(t3));\n}\n\nexport function sat(p1: Polygon, p2: Polygon): Vec2 | null {\n    let overlap = Number.MAX_VALUE;\n    let displacement = vec2(0);\n    for (const poly of [p1, p2]) {\n        for (let i = 0; i < poly.pts.length; i++) {\n            const a = poly.pts[i];\n            const b = poly.pts[(i + 1) % poly.pts.length];\n            const axisProj = b.sub(a).normal().unit();\n            let min1 = Number.MAX_VALUE;\n            let max1 = -Number.MAX_VALUE;\n            for (let j = 0; j < p1.pts.length; j++) {\n                const q = p1.pts[j].dot(axisProj);\n                min1 = Math.min(min1, q);\n                max1 = Math.max(max1, q);\n            }\n            let min2 = Number.MAX_VALUE;\n            let max2 = -Number.MAX_VALUE;\n            for (let j = 0; j < p2.pts.length; j++) {\n                const q = p2.pts[j].dot(axisProj);\n                min2 = Math.min(min2, q);\n                max2 = Math.max(max2, q);\n            }\n            const o = Math.min(max1, max2) - Math.max(min1, min2);\n            if (o < 0) {\n                return null;\n            }\n            if (o < Math.abs(overlap)) {\n                const o1 = max2 - min1;\n                const o2 = min2 - max1;\n                overlap = Math.abs(o1) < Math.abs(o2) ? o1 : o2;\n                displacement = axisProj.scale(overlap);\n            }\n        }\n    }\n    return displacement;\n}\n\n// true if the angle is oriented counter clockwise\nfunction isOrientedCcw(a: Vec2, b: Vec2, c: Vec2) {\n    // return det(b-a, c-a) >= 0\n    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) >= 0;\n}\n\n// true if the polygon is oriented counter clockwise\nfunction isOrientedCcwPolygon(polygon: Vec2[]) {\n    let total = 0;\n    let prev: Vec2 = polygon[polygon.length - 1];\n    for (let i = 0; i < polygon.length; i++) {\n        total += (polygon[i].x - prev.x) * (polygon[i].y + prev.y);\n        prev = polygon[i];\n    }\n    return total < 0;\n}\n\n// true if a and b are on the same side of the line c->d\nfunction onSameSide(a: Vec2, b: Vec2, c: Vec2, d: Vec2) {\n    const px = d.x - c.x, py = d.y - c.y;\n    // return det(p, a-c) * det(p, b-c) >= 0\n    const l = px * (a.y - c.y) - py * (a.x - c.x);\n    const m = px * (b.y - c.y) - py * (b.x - c.x);\n    return l * m >= 0;\n}\n\n// true if p is contained in the triangle abc\nfunction pointInTriangle(p: Vec2, a: Vec2, b: Vec2, c: Vec2) {\n    return onSameSide(p, a, b, c) && onSameSide(p, b, a, c)\n        && onSameSide(p, c, a, b);\n}\n\n// true if any vertex in the list `vertices' is in the triangle abc.\nfunction someInTriangle(vertices: Vec2[], a: Vec2, b: Vec2, c: Vec2) {\n    for (const p of vertices) {\n        if (\n            (p !== a) && (p !== b) && (p !== c) && pointInTriangle(p, a, b, c)\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// true if the triangle is an ear, which is whether it can be cut off from the polygon without leaving a hole behind\nfunction isEar(a: Vec2, b: Vec2, c: Vec2, vertices: Vec2[]) {\n    return isOrientedCcw(a, b, c) && !someInTriangle(vertices, a, b, c);\n}\n\nexport function triangulate(pts: Vec2[]): Vec2[][] {\n    if (pts.length < 3) {\n        return [];\n    }\n    if (pts.length == 3) {\n        return [pts];\n    }\n\n    /* Create a list of indexes to the previous and next points of a given point\n    prev_idx[i] gives the index to the previous point of the point at i */\n    let nextIdx = [];\n    let prevIdx = [];\n    let idx = 0;\n    for (let i = 0; i < pts.length; i++) {\n        const lm = pts[idx];\n        const pt = pts[i];\n        if (pt.x < lm.x || (pt.x == lm.x && pt.y < lm.y)) {\n            idx = idx;\n        }\n        nextIdx[i] = i + 1;\n        prevIdx[i] = i - 1;\n    }\n    nextIdx[nextIdx.length - 1] = 0;\n    prevIdx[0] = prevIdx.length - 1;\n\n    // If the polygon is not counter clockwise, swap the lists, thus reversing the winding\n    if (!isOrientedCcwPolygon(pts)) {\n        [nextIdx, prevIdx] = [prevIdx, nextIdx];\n    }\n\n    const concaveVertices = [];\n    for (let i = 0; i < pts.length; ++i) {\n        if (!isOrientedCcw(pts[prevIdx[i]], pts[i], pts[nextIdx[i]])) {\n            concaveVertices.push(pts[i]);\n        }\n    }\n\n    const triangles = [];\n    let nVertices = pts.length;\n    let current = 1;\n    let skipped = 0;\n    let next;\n    let prev;\n    while (nVertices > 3) {\n        next = nextIdx[current];\n        prev = prevIdx[current];\n        const a = pts[prev];\n        const b = pts[current];\n        const c = pts[next];\n        if (isEar(a, b, c, concaveVertices)) {\n            triangles.push([a, b, c]);\n            nextIdx[prev] = next;\n            prevIdx[next] = prev;\n            concaveVertices.splice(concaveVertices.indexOf(b), 1);\n            --nVertices;\n            skipped = 0;\n        } else if (++skipped > nVertices) {\n            return [];\n        }\n        current = next;\n    }\n    next = nextIdx[current];\n    prev = prevIdx[current];\n    triangles.push([pts[prev], pts[current], pts[next]]);\n\n    return triangles;\n}\n\nexport function isConvex(pts: Vec2[]) {\n    if (pts.length < 3) {\n        return false;\n    }\n\n    // a polygon is convex if all corners turn in the same direction\n    // turning direction can be determined using the cross-product of\n    // the forward difference vectors\n    let i = pts.length - 2;\n    let j = pts.length - 1;\n    let k = 0;\n    let p = pts[j].sub(pts[i]);\n    let q = pts[k].sub(pts[j]);\n    let winding = p.cross(q);\n\n    while (k + 1 < pts.length) {\n        i = j;\n        j = k;\n        k++;\n        p = pts[j].sub(pts[i]);\n        q = pts[k].sub(pts[j]);\n\n        if (p.cross(q) * winding < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "export class Registry<T> extends Map<number, T> {\n    private lastID: number = 0;\n    push(v: T): number {\n        const id = this.lastID;\n        this.set(id, v);\n        this.lastID++;\n        return id;\n    }\n    pushd(v: T): () => void {\n        const id = this.push(v);\n        return () => this.delete(id);\n    }\n}\n\nexport class EventController {\n    paused: boolean = false;\n    readonly cancel: () => void;\n    constructor(cancel: () => void) {\n        this.cancel = cancel;\n    }\n    static join(events: EventController[]): EventController {\n        const ev = new EventController(() => events.forEach((e) => e.cancel()));\n        Object.defineProperty(ev, \"paused\", {\n            get: () => events[0].paused,\n            set: (p: boolean) => events.forEach((e) => e.paused = p),\n        });\n        ev.paused = false;\n        return ev;\n    }\n}\n\nexport class Event<Args extends any[] = any[]> {\n    private handlers: Registry<(...args: Args) => void> = new Registry();\n    add(action: (...args: Args) => void): EventController {\n        const cancel = this.handlers.pushd((...args: Args) => {\n            if (ev.paused) return;\n            action(...args);\n        });\n        const ev = new EventController(cancel);\n        return ev;\n    }\n    addOnce(action: (...args) => void): EventController {\n        const ev = this.add((...args) => {\n            ev.cancel();\n            action(...args);\n        });\n        return ev;\n    }\n    next(): Promise<Args> {\n        return new Promise((res) => this.addOnce(res));\n    }\n    trigger(...args: Args) {\n        this.handlers.forEach((action) => action(...args));\n    }\n    numListeners(): number {\n        return this.handlers.size;\n    }\n    clear() {\n        this.handlers.clear();\n    }\n}\n\n// TODO: only accept one argument?\nexport class EventHandler<EventMap extends Record<string, any[]>> {\n    private handlers: Partial<\n        {\n            [Name in keyof EventMap]: Event<EventMap[Name]>;\n        }\n    > = {};\n    on<Name extends keyof EventMap>(\n        name: Name,\n        action: (...args: EventMap[Name]) => void,\n    ): EventController {\n        if (!this.handlers[name]) {\n            this.handlers[name] = new Event<EventMap[Name]>();\n        }\n        return this.handlers[name].add(action);\n    }\n    onOnce<Name extends keyof EventMap>(\n        name: Name,\n        action: (...args: EventMap[Name]) => void,\n    ): EventController {\n        const ev = this.on(name, (...args) => {\n            ev.cancel();\n            action(...args);\n        });\n        return ev;\n    }\n    next<Name extends keyof EventMap>(name: Name): Promise<unknown> {\n        return new Promise((res) => {\n            // TODO: can only pass 1 val to resolve()\n            this.onOnce(name, (...args: EventMap[Name]) => res(args[0]));\n        });\n    }\n    trigger<Name extends keyof EventMap>(name: Name, ...args: EventMap[Name]) {\n        if (this.handlers[name]) {\n            this.handlers[name].trigger(...args);\n        }\n    }\n    remove<Name extends keyof EventMap>(name: Name) {\n        delete this.handlers[name];\n    }\n    clear() {\n        this.handlers = {};\n    }\n    numListeners<Name extends keyof EventMap>(name: Name): number {\n        return this.handlers[name]?.numListeners() ?? 0;\n    }\n}\n\nexport function deepEq(o1: any, o2: any): boolean {\n    if (o1 === o2) {\n        return true;\n    }\n    const t1 = typeof o1;\n    const t2 = typeof o2;\n    if (t1 !== t2) {\n        return false;\n    }\n    if (t1 === \"object\" && t2 === \"object\" && o1 !== null && o2 !== null) {\n        if (Array.isArray(o1) !== Array.isArray(o2)) {\n            return false;\n        }\n        const k1 = Object.keys(o1);\n        const k2 = Object.keys(o2);\n        if (k1.length !== k2.length) {\n            return false;\n        }\n        for (const k of k1) {\n            const v1 = o1[k];\n            const v2 = o2[k];\n            if (!deepEq(v1, v2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binstr = window.atob(base64);\n    const len = binstr.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binstr.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nexport function dataURLToArrayBuffer(url: string): ArrayBuffer {\n    return base64ToArrayBuffer(url.split(\",\")[1]);\n}\n\nexport function download(filename: string, url: string) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = filename;\n    a.click();\n}\n\nexport function downloadText(filename: string, text: string) {\n    download(filename, \"data:text/plain;charset=utf-8,\" + text);\n}\n\nexport function downloadJSON(filename: string, data: any) {\n    downloadText(filename, JSON.stringify(data));\n}\n\nexport function downloadBlob(filename: string, blob: Blob) {\n    const url = URL.createObjectURL(blob);\n    download(filename, url);\n    URL.revokeObjectURL(url);\n}\n\nexport const isDataURL = (str: string) => str.match(/^data:\\w+\\/\\w+;base64,.+/);\nexport const getFileExt = (p: string) => p.split(\".\").pop();\nexport const getFileName = (p: string) => p.split(\".\").slice(0, -1).join(\".\");\n\ntype Func = (...args: any[]) => any;\n\nexport function overload2<A extends Func, B extends Func>(\n    fn1: A,\n    fn2: B,\n): A & B {\n    return ((...args) => {\n        const al = args.length;\n        if (al === fn1.length) return fn1(...args);\n        if (al === fn2.length) return fn2(...args);\n    }) as A & B;\n}\n\nexport function overload3<\n    A extends Func,\n    B extends Func,\n    C extends Func,\n>(fn1: A, fn2: B, fn3: C): A & B & C {\n    return ((...args) => {\n        const al = args.length;\n        if (al === fn1.length) return fn1(...args);\n        if (al === fn2.length) return fn2(...args);\n        if (al === fn3.length) return fn3(...args);\n    }) as A & B & C;\n}\n\nexport function overload4<\n    A extends Func,\n    B extends Func,\n    C extends Func,\n    D extends Func,\n>(fn1: A, fn2: B, fn3: C, fn4: D): A & B & C & D {\n    return ((...args) => {\n        const al = args.length;\n        if (al === fn1.length) return fn1(...args);\n        if (al === fn2.length) return fn2(...args);\n        if (al === fn3.length) return fn3(...args);\n        if (al === fn4.length) return fn4(...args);\n    }) as A & B & C & D;\n}\n\nexport const uid = (() => {\n    let id = 0;\n    return () => id++;\n})();\n\nexport const getErrorMessage = (error: unknown) =>\n    (error instanceof Error) ? error.message : String(error);\n\nconst warned = new Set();\n\nexport function warn(msg: string) {\n    if (!warned.has(msg)) {\n        warned.add(msg);\n        console.warn(msg);\n    }\n}\n\nexport function deprecateMsg(oldName: string, newName: string) {\n    warn(`${oldName} is deprecated. Use ${newName} instead.`);\n}\n\nexport function deprecate(\n    oldName: string,\n    newName: string,\n    newFunc: (...args) => any,\n) {\n    return (...args) => {\n        deprecateMsg(oldName, newName);\n        return newFunc(...args);\n    };\n}\n\nexport function benchmark(task: () => void, times: number = 1) {\n    const t1 = performance.now();\n    for (let i = 0; i < times; i++) {\n        task();\n    }\n    const t2 = performance.now();\n    return t2 - t1;\n}\n\nexport function comparePerf(t1: () => void, t2: () => void, times: number = 1) {\n    return benchmark(t2, times) / benchmark(t1, times);\n}\n\nexport class BinaryHeap<T> {\n    _items: T[];\n    _compareFn: (a: T, b: T) => boolean;\n\n    /**\n     * Creates a binary heap with the given compare function\n     * Not passing a compare function will give a min heap\n     */\n    constructor(compareFn = (a: T, b: T) => a < b) {\n        this._compareFn = compareFn;\n        this._items = [];\n    }\n\n    /**\n     * Insert an item into the binary heap\n     */\n    insert(item: T) {\n        this._items.push(item);\n        this.moveUp(this._items.length - 1);\n    }\n\n    /**\n     * Remove the smallest item from the binary heap in case of a min heap\n     * or the greatest item from the binary heap in case of a max heap\n     */\n    remove() {\n        if (this._items.length === 0) {\n            return null;\n        }\n        const item = this._items[0];\n        const lastItem = this._items.pop();\n        if (this._items.length !== 0) {\n            this._items[0] = lastItem as T;\n            this.moveDown(0);\n        }\n        return item;\n    }\n\n    /**\n     * Remove all items\n     */\n    clear() {\n        this._items.splice(0, this._items.length);\n    }\n\n    moveUp(pos: number) {\n        while (pos > 0) {\n            const parent = Math.floor((pos - 1) / 2);\n            if (!this._compareFn(this._items[pos], this._items[parent])) {\n                if (this._items[pos] >= this._items[parent]) {\n                    break;\n                }\n            }\n            this.swap(pos, parent);\n            pos = parent;\n        }\n    }\n\n    moveDown(pos: number) {\n        while (pos < Math.floor(this._items.length / 2)) {\n            let child = 2 * pos + 1;\n            if (\n                child < this._items.length - 1\n                && !this._compareFn(this._items[child], this._items[child + 1])\n            ) {\n                ++child;\n            }\n            if (this._compareFn(this._items[pos], this._items[child])) {\n                break;\n            }\n            this.swap(pos, child);\n            pos = child;\n        }\n    }\n\n    swap(index1: number, index2: number) {\n        [this._items[index1], this._items[index2]] = [\n            this._items[index2],\n            this._items[index1],\n        ];\n    }\n\n    /**\n     * Returns the amount of items\n     */\n    get length() {\n        return this._items.length;\n    }\n}\n\nconst enum EnumRunesCode {\n    HIGH_SURROGATE_START = 0xd800,\n    HIGH_SURROGATE_END = 0xdbff,\n\n    LOW_SURROGATE_START = 0xdc00,\n\n    REGIONAL_INDICATOR_START = 0x1f1e6,\n    REGIONAL_INDICATOR_END = 0x1f1ff,\n\n    FITZPATRICK_MODIFIER_START = 0x1f3fb,\n    FITZPATRICK_MODIFIER_END = 0x1f3ff,\n\n    VARIATION_MODIFIER_START = 0xfe00,\n    VARIATION_MODIFIER_END = 0xfe0f,\n\n    DIACRITICAL_MARKS_START = 0x20d0,\n    DIACRITICAL_MARKS_END = 0x20ff,\n\n    SUBDIVISION_INDICATOR_START = 0x1f3f4,\n    TAGS_START = 0xe0000,\n    TAGS_END = 0xe007f,\n\n    ZWJ = 0x200d,\n}\n\nconst GRAPHEMES = Object.freeze([\n    0x0308, // ( \u25CC\u0308 ) COMBINING DIAERESIS\n    0x0937, // ( \u0937 ) DEVANAGARI LETTER SSA\n    0x093F, // ( \u093F ) DEVANAGARI VOWEL SIGN I\n    0x0BA8, // ( \u0BA8 ) TAMIL LETTER NA\n    0x0BBF, // ( \u0BBF ) TAMIL VOWEL SIGN I\n    0x0BCD, // ( \u25CC\u0BCD) TAMIL SIGN VIRAMA\n    0x0E31, // ( \u25CC\u0E31 ) THAI CHARACTER MAI HAN-AKAT\n    0x0E33, // ( \u0E33 ) THAI CHARACTER SARA AM\n    0x0E40, // ( \u0E40 ) THAI CHARACTER SARA E\n    0x0E49, // ( \u0E40 ) THAI CHARACTER MAI THO\n    0x1100, // ( \u1100 ) HANGUL CHOSEONG KIYEOK\n    0x1161, // ( \u1161 ) HANGUL JUNGSEONG A\n    0x11A8, // ( \u11A8 ) HANGUL JONGSEONG KIYEOK\n]);\n\nenum EnumCodeUnits {\n    unit_1 = 1,\n    unit_2 = 2,\n    unit_4 = 4,\n}\n\nexport function runes(string: string): string[] {\n    if (typeof string !== \"string\") {\n        throw new TypeError(\"string cannot be undefined or null\");\n    }\n    const result: string[] = [];\n    let i = 0;\n    let increment = 0;\n    while (i < string.length) {\n        increment += nextUnits(i + increment, string);\n        if (isGrapheme(string[i + increment])) {\n            increment++;\n        }\n        if (isVariationSelector(string[i + increment])) {\n            increment++;\n        }\n        if (isDiacriticalMark(string[i + increment])) {\n            increment++;\n        }\n        if (isZeroWidthJoiner(string[i + increment])) {\n            increment++;\n            continue;\n        }\n        result.push(string.substring(i, i + increment));\n        i += increment;\n        increment = 0;\n    }\n    return result;\n}\n\n// Decide how many code units make up the current character.\n// BMP characters: 1 code unit\n// Non-BMP characters (represented by surrogate pairs): 2 code units\n// Emoji with skin-tone modifiers: 4 code units (2 code points)\n// Country flags: 4 code units (2 code points)\n// Variations: 2 code units\n// Subdivision flags: 14 code units (7 code points)\nfunction nextUnits(i: number, string: string) {\n    const current = string[i];\n    // If we don't have a value that is part of a surrogate pair, or we're at\n    // the end, only take the value at i\n    if (!isFirstOfSurrogatePair(current) || i === string.length - 1) {\n        return EnumCodeUnits.unit_1;\n    }\n\n    const currentPair = current + string[i + 1];\n    const nextPair = string.substring(i + 2, i + 5);\n\n    // Country flags are comprised of two regional indicator symbols,\n    // each represented by a surrogate pair.\n    // See http://emojipedia.org/flags/\n    // If both pairs are regional indicator symbols, take 4\n    if (isRegionalIndicator(currentPair) && isRegionalIndicator(nextPair)) {\n        return EnumCodeUnits.unit_4;\n    }\n\n    // https://unicode.org/emoji/charts/full-emoji-list.html#subdivision-flag\n    // See https://emojipedia.org/emoji-tag-sequence/\n    // If nextPair is in Tags(https://en.wikipedia.org/wiki/Tags_(Unicode_block)),\n    // then find next closest U+E007F(CANCEL TAG)\n    if (\n        isSubdivisionFlag(currentPair)\n        && isSupplementarySpecialpurposePlane(nextPair)\n    ) {\n        return string.slice(i).indexOf(\n            String.fromCodePoint(EnumRunesCode.TAGS_END),\n        ) + 2;\n    }\n\n    // If the next pair make a Fitzpatrick skin tone\n    // modifier, take 4\n    // See http://emojipedia.org/modifiers/\n    // Technically, only some code points are meant to be\n    // combined with the skin tone modifiers. This function\n    // does not check the current pair to see if it is\n    // one of them.\n    if (isFitzpatrickModifier(nextPair)) {\n        return EnumCodeUnits.unit_4;\n    }\n    return EnumCodeUnits.unit_2;\n}\n\nfunction isFirstOfSurrogatePair(string: string) {\n    return string\n        && betweenInclusive(\n            string[0].charCodeAt(0),\n            EnumRunesCode.HIGH_SURROGATE_START,\n            EnumRunesCode.HIGH_SURROGATE_END,\n        );\n}\n\nfunction isRegionalIndicator(string: string) {\n    return betweenInclusive(\n        codePointFromSurrogatePair(string),\n        EnumRunesCode.REGIONAL_INDICATOR_START,\n        EnumRunesCode.REGIONAL_INDICATOR_END,\n    );\n}\n\nfunction isSubdivisionFlag(string: string) {\n    return betweenInclusive(\n        codePointFromSurrogatePair(string),\n        EnumRunesCode.SUBDIVISION_INDICATOR_START,\n        EnumRunesCode.SUBDIVISION_INDICATOR_START,\n    );\n}\n\nfunction isFitzpatrickModifier(string: string) {\n    return betweenInclusive(\n        codePointFromSurrogatePair(string),\n        EnumRunesCode.FITZPATRICK_MODIFIER_START,\n        EnumRunesCode.FITZPATRICK_MODIFIER_END,\n    );\n}\n\nfunction isVariationSelector(string: string) {\n    return typeof string === \"string\"\n        && betweenInclusive(\n            string.charCodeAt(0),\n            EnumRunesCode.VARIATION_MODIFIER_START,\n            EnumRunesCode.VARIATION_MODIFIER_END,\n        );\n}\n\nfunction isDiacriticalMark(string: string) {\n    return typeof string === \"string\"\n        && betweenInclusive(\n            string.charCodeAt(0),\n            EnumRunesCode.DIACRITICAL_MARKS_START,\n            EnumRunesCode.DIACRITICAL_MARKS_END,\n        );\n}\n\nfunction isSupplementarySpecialpurposePlane(string: string) {\n    const codePoint = string.codePointAt(0);\n    return (typeof string === \"string\" && typeof codePoint === \"number\"\n        && betweenInclusive(\n            codePoint,\n            EnumRunesCode.TAGS_START,\n            EnumRunesCode.TAGS_END,\n        ));\n}\n\nfunction isGrapheme(string: string) {\n    return typeof string === \"string\"\n        && GRAPHEMES.includes(string.charCodeAt(0));\n}\n\nfunction isZeroWidthJoiner(string: string) {\n    return typeof string === \"string\"\n        && string.charCodeAt(0) === EnumRunesCode.ZWJ;\n}\n\nfunction codePointFromSurrogatePair(pair: string) {\n    const highOffset = pair.charCodeAt(0) - EnumRunesCode.HIGH_SURROGATE_START;\n    const lowOffset = pair.charCodeAt(1) - EnumRunesCode.LOW_SURROGATE_START;\n    return (highOffset << 10) + lowOffset + 0x10000;\n}\n\nfunction betweenInclusive(value: number, lower: number, upper: number) {\n    return value >= lower && value <= upper;\n}\n\nexport function substring(string: string, start?: number, width?: number) {\n    const chars = runes(string);\n    if (start === undefined) {\n        return string;\n    }\n    if (start >= chars.length) {\n        return \"\";\n    }\n    const rest = chars.length - start;\n    const stringWidth = width === undefined ? rest : width;\n    let endIndex = start + stringWidth;\n    if (endIndex > (start + rest)) {\n        endIndex = undefined;\n    }\n    return chars.slice(start, endIndex).join(\"\");\n}\n", "{\n  \"Joy-Con L+R (STANDARD GAMEPAD Vendor: 057e Product: 200e)\": {\n    \"buttons\": {\n      \"0\": \"south\",\n      \"1\": \"east\",\n      \"2\": \"west\",\n      \"3\": \"north\",\n      \"4\": \"lshoulder\",\n      \"5\": \"rshoulder\",\n      \"6\": \"ltrigger\",\n      \"7\": \"rtrigger\",\n      \"8\": \"select\",\n      \"9\": \"start\",\n      \"10\": \"lstick\",\n      \"11\": \"rstick\",\n      \"12\": \"dpad-up\",\n      \"13\": \"dpad-down\",\n      \"14\": \"dpad-left\",\n      \"15\": \"dpad-right\",\n      \"16\": \"home\",\n      \"17\": \"capture\"\n    },\n    \"sticks\": {\n      \"left\": { \"x\": 0, \"y\": 1 },\n      \"right\": { \"x\": 2, \"y\": 3 }\n    }\n  },\n  \"Joy-Con (L) (STANDARD GAMEPAD Vendor: 057e Product: 2006)\": {\n    \"buttons\": {\n      \"0\": \"south\",\n      \"1\": \"east\",\n      \"2\": \"west\",\n      \"3\": \"north\",\n      \"4\": \"lshoulder\",\n      \"5\": \"rshoulder\",\n      \"9\": \"select\",\n      \"10\": \"lstick\",\n      \"16\": \"start\"\n    },\n    \"sticks\": {\n      \"left\": { \"x\": 0, \"y\": 1 }\n    }\n  },\n  \"Joy-Con (R) (STANDARD GAMEPAD Vendor: 057e Product: 2007)\": {\n    \"buttons\": {\n      \"0\": \"south\",\n      \"1\": \"east\",\n      \"2\": \"west\",\n      \"3\": \"north\",\n      \"4\": \"lshoulder\",\n      \"5\": \"rshoulder\",\n      \"9\": \"start\",\n      \"10\": \"lstick\",\n      \"16\": \"select\"\n    },\n    \"sticks\": {\n      \"left\": { \"x\": 0, \"y\": 1 }\n    }\n  },\n  \"Pro Controller (STANDARD GAMEPAD Vendor: 057e Product: 2009)\": {\n    \"buttons\": {\n      \"0\": \"south\",\n      \"1\": \"east\",\n      \"2\": \"west\",\n      \"3\": \"north\",\n      \"4\": \"lshoulder\",\n      \"5\": \"rshoulder\",\n      \"6\": \"ltrigger\",\n      \"7\": \"rtrigger\",\n      \"8\": \"select\",\n      \"9\": \"start\",\n      \"10\": \"lstick\",\n      \"11\": \"rstick\",\n      \"12\": \"dpad-up\",\n      \"13\": \"dpad-down\",\n      \"14\": \"dpad-left\",\n      \"15\": \"dpad-right\",\n      \"16\": \"home\",\n      \"17\": \"capture\"\n    },\n    \"sticks\": {\n      \"left\": { \"x\": 0, \"y\": 1 },\n      \"right\": { \"x\": 2, \"y\": 3 }\n    }\n  },\n  \"default\": {\n    \"buttons\": {\n      \"0\": \"south\",\n      \"1\": \"east\",\n      \"2\": \"west\",\n      \"3\": \"north\",\n      \"4\": \"lshoulder\",\n      \"5\": \"rshoulder\",\n      \"6\": \"ltrigger\",\n      \"7\": \"rtrigger\",\n      \"8\": \"select\",\n      \"9\": \"start\",\n      \"10\": \"lstick\",\n      \"11\": \"rstick\",\n      \"12\": \"dpad-up\",\n      \"13\": \"dpad-down\",\n      \"14\": \"dpad-left\",\n      \"15\": \"dpad-right\",\n      \"16\": \"home\"\n    },\n    \"sticks\": {\n      \"left\": { \"x\": 0, \"y\": 1 },\n      \"right\": { \"x\": 2, \"y\": 3 }\n    }\n  }\n}\n", "// everything related to canvas, game loop and input\n\nimport type {\n    Cursor,\n    GamepadButton,\n    GamepadDef,\n    GamepadStick,\n    Key,\n    KGamePad,\n    MouseButton,\n} from \"./types\";\n\nimport { map, Vec2 } from \"./math\";\n\nimport { EventController, EventHandler, overload2 } from \"./utils\";\n\nimport GAMEPAD_MAP from \"./gamepad.json\";\n\nexport class ButtonState<T = string> {\n    pressed: Set<T> = new Set([]);\n    pressedRepeat: Set<T> = new Set([]);\n    released: Set<T> = new Set([]);\n    down: Set<T> = new Set([]);\n    update() {\n        this.pressed.clear();\n        this.released.clear();\n        this.pressedRepeat.clear();\n    }\n    press(btn: T) {\n        this.pressed.add(btn);\n        this.pressedRepeat.add(btn);\n        this.down.add(btn);\n    }\n    pressRepeat(btn: T) {\n        this.pressedRepeat.add(btn);\n    }\n    release(btn: T) {\n        this.down.delete(btn);\n        this.pressed.delete(btn);\n        this.released.add(btn);\n    }\n}\n\nclass GamepadState {\n    buttonState: ButtonState<GamepadButton> = new ButtonState();\n    stickState: Map<GamepadStick, Vec2> = new Map();\n}\n\nclass FPSCounter {\n    private dts: number[] = [];\n    private timer: number = 0;\n    fps: number = 0;\n    tick(dt: number) {\n        this.dts.push(dt);\n        this.timer += dt;\n        if (this.timer >= 1) {\n            this.timer = 0;\n            this.fps = Math.round(\n                1 / (this.dts.reduce((a, b) => a + b) / this.dts.length),\n            );\n            this.dts = [];\n        }\n    }\n}\n\nexport default (opt: {\n    canvas: HTMLCanvasElement;\n    touchToMouse?: boolean;\n    gamepads?: Record<string, GamepadDef>;\n    pixelDensity?: number;\n    maxFPS?: number;\n}) => {\n    if (!opt.canvas) {\n        throw new Error(\"Please provide a canvas\");\n    }\n\n    const state = {\n        canvas: opt.canvas,\n        loopID: null as null | number,\n        stopped: false,\n        dt: 0,\n        time: 0,\n        realTime: 0,\n        fpsCounter: new FPSCounter(),\n        timeScale: 1,\n        skipTime: false,\n        isHidden: false,\n        numFrames: 0,\n        mousePos: new Vec2(0),\n        mouseDeltaPos: new Vec2(0),\n        keyState: new ButtonState<Key>(),\n        mouseState: new ButtonState<MouseButton>(),\n        mergedGamepadState: new GamepadState(),\n        gamepadStates: new Map<number, GamepadState>(),\n        gamepads: [] as KGamePad[],\n        charInputted: [],\n        isMouseMoved: false,\n        lastWidth: opt.canvas.offsetWidth,\n        lastHeight: opt.canvas.offsetHeight,\n        events: new EventHandler<{\n            mouseMove: [];\n            mouseDown: [MouseButton];\n            mousePress: [MouseButton];\n            mouseRelease: [MouseButton];\n            charInput: [string];\n            keyPress: [Key];\n            keyDown: [Key];\n            keyPressRepeat: [Key];\n            keyRelease: [Key];\n            touchStart: [Vec2, Touch];\n            touchMove: [Vec2, Touch];\n            touchEnd: [Vec2, Touch];\n            gamepadButtonDown: [string];\n            gamepadButtonPress: [string];\n            gamepadButtonRelease: [string];\n            gamepadStick: [string, Vec2];\n            gamepadConnect: [KGamePad];\n            gamepadDisconnect: [KGamePad];\n            scroll: [Vec2];\n            hide: [];\n            show: [];\n            resize: [];\n            input: [];\n        }>(),\n    };\n\n    function dt() {\n        return state.dt * state.timeScale;\n    }\n\n    function isHidden() {\n        return state.isHidden;\n    }\n\n    function time() {\n        return state.time;\n    }\n\n    function fps() {\n        return state.fpsCounter.fps;\n    }\n\n    function numFrames() {\n        return state.numFrames;\n    }\n\n    function screenshot(): string {\n        return state.canvas.toDataURL();\n    }\n\n    function setCursor(c: Cursor): void {\n        state.canvas.style.cursor = c;\n    }\n\n    function getCursor(): Cursor {\n        return state.canvas.style.cursor;\n    }\n\n    function setCursorLocked(b: boolean): void {\n        if (b) {\n            try {\n                const res = state.canvas\n                    .requestPointerLock() as unknown as Promise<void>;\n                if (res.catch) {\n                    res.catch((e) => console.error(e));\n                }\n            } catch (e) {\n                console.error(e);\n            }\n        } else {\n            document.exitPointerLock();\n        }\n    }\n\n    function isCursorLocked(): boolean {\n        return !!document.pointerLockElement;\n    }\n\n    // wrappers around full screen functions to work across browsers\n    function enterFullscreen(el: HTMLElement) {\n        if (el.requestFullscreen) el.requestFullscreen();\n        // @ts-ignore\n        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();\n    }\n\n    function exitFullscreen() {\n        if (document.exitFullscreen) document.exitFullscreen();\n        // @ts-ignore\n        else if (document.webkitExitFullScreen) document.webkitExitFullScreen();\n    }\n\n    function getFullscreenElement(): Element | void {\n        return document.fullscreenElement\n            // @ts-ignore\n            || document.webkitFullscreenElement;\n    }\n\n    function setFullscreen(f: boolean = true) {\n        if (f) {\n            enterFullscreen(state.canvas);\n        } else {\n            exitFullscreen();\n        }\n    }\n\n    function isFullscreen(): boolean {\n        return Boolean(getFullscreenElement());\n    }\n\n    function quit() {\n        state.stopped = true;\n        for (const name in canvasEvents) {\n            state.canvas.removeEventListener(name, canvasEvents[name]);\n        }\n        for (const name in docEvents) {\n            document.removeEventListener(name, docEvents[name]);\n        }\n        for (const name in winEvents) {\n            window.removeEventListener(name, winEvents[name]);\n        }\n        resizeObserver.disconnect();\n    }\n\n    function run(action: () => void) {\n        if (state.loopID !== null) {\n            cancelAnimationFrame(state.loopID);\n        }\n\n        let accumulatedDt = 0;\n\n        const frame = (t: number) => {\n            if (state.stopped) return;\n\n            // TODO: allow background actions?\n            if (document.visibilityState !== \"visible\") {\n                state.loopID = requestAnimationFrame(frame);\n                return;\n            }\n\n            const loopTime = t / 1000;\n            const realDt = loopTime - state.realTime;\n            const desiredDt = opt.maxFPS ? 1 / opt.maxFPS : 0;\n\n            state.realTime = loopTime;\n            accumulatedDt += realDt;\n\n            if (accumulatedDt > desiredDt) {\n                if (!state.skipTime) {\n                    state.dt = accumulatedDt;\n                    state.time += dt();\n                    state.fpsCounter.tick(state.dt);\n                }\n                accumulatedDt = 0;\n                state.skipTime = false;\n                state.numFrames++;\n                processInput();\n                action();\n                resetInput();\n            }\n\n            state.loopID = requestAnimationFrame(frame);\n        };\n\n        frame(0);\n    }\n\n    function isTouchscreen() {\n        return (\"ontouchstart\" in window) || navigator.maxTouchPoints > 0;\n    }\n\n    function mousePos(): Vec2 {\n        return state.mousePos.clone();\n    }\n\n    function mouseDeltaPos(): Vec2 {\n        return state.mouseDeltaPos.clone();\n    }\n\n    function isMousePressed(m: MouseButton = \"left\"): boolean {\n        return state.mouseState.pressed.has(m);\n    }\n\n    function isMouseDown(m: MouseButton = \"left\"): boolean {\n        return state.mouseState.down.has(m);\n    }\n\n    function isMouseReleased(m: MouseButton = \"left\"): boolean {\n        return state.mouseState.released.has(m);\n    }\n\n    function isMouseMoved(): boolean {\n        return state.isMouseMoved;\n    }\n\n    function isKeyPressed(k?: Key): boolean {\n        return k === undefined\n            ? state.keyState.pressed.size > 0\n            : state.keyState.pressed.has(k);\n    }\n\n    function isKeyPressedRepeat(k?: Key): boolean {\n        return k === undefined\n            ? state.keyState.pressedRepeat.size > 0\n            : state.keyState.pressedRepeat.has(k);\n    }\n\n    function isKeyDown(k?: Key): boolean {\n        return k === undefined\n            ? state.keyState.down.size > 0\n            : state.keyState.down.has(k);\n    }\n\n    function isKeyReleased(k?: Key): boolean {\n        return k === undefined\n            ? state.keyState.released.size > 0\n            : state.keyState.released.has(k);\n    }\n\n    function isGamepadButtonPressed(btn?: GamepadButton): boolean {\n        return btn === undefined\n            ? state.mergedGamepadState.buttonState.pressed.size > 0\n            : state.mergedGamepadState.buttonState.pressed.has(btn);\n    }\n\n    function isGamepadButtonDown(btn?: GamepadButton): boolean {\n        return btn === undefined\n            ? state.mergedGamepadState.buttonState.down.size > 0\n            : state.mergedGamepadState.buttonState.down.has(btn);\n    }\n\n    function isGamepadButtonReleased(btn?: GamepadButton): boolean {\n        return btn === undefined\n            ? state.mergedGamepadState.buttonState.released.size > 0\n            : state.mergedGamepadState.buttonState.released.has(btn);\n    }\n\n    function onResize(action: () => void): EventController {\n        return state.events.on(\"resize\", action);\n    }\n\n    // input callbacks\n    const onKeyDown = overload2((action: (key: Key) => void) => {\n        return state.events.on(\"keyDown\", action);\n    }, (key: Key, action: (key: Key) => void) => {\n        return state.events.on(\"keyDown\", (k) => k === key && action(key));\n    });\n\n    const onKeyPress = overload2((action: (key: Key) => void) => {\n        return state.events.on(\"keyPress\", action);\n    }, (key: Key, action: (key: Key) => void) => {\n        return state.events.on(\"keyPress\", (k) => k === key && action(key));\n    });\n\n    const onKeyPressRepeat = overload2((action: (key: Key) => void) => {\n        return state.events.on(\"keyPressRepeat\", action);\n    }, (key: Key, action: (key: Key) => void) => {\n        return state.events.on(\n            \"keyPressRepeat\",\n            (k) => k === key && action(key),\n        );\n    });\n\n    const onKeyRelease = overload2((action: (key: Key) => void) => {\n        return state.events.on(\"keyRelease\", action);\n    }, (key: Key, action: (key: Key) => void) => {\n        return state.events.on(\"keyRelease\", (k) => k === key && action(key));\n    });\n\n    const onMouseDown = overload2((action: (m: MouseButton) => void) => {\n        return state.events.on(\"mouseDown\", (m) => action(m));\n    }, (mouse: MouseButton, action: (m: MouseButton) => void) => {\n        return state.events.on(\"mouseDown\", (m) => m === mouse && action(m));\n    });\n\n    const onMousePress = overload2((action: (m: MouseButton) => void) => {\n        return state.events.on(\"mousePress\", (m) => action(m));\n    }, (mouse: MouseButton, action: (m: MouseButton) => void) => {\n        return state.events.on(\"mousePress\", (m) => m === mouse && action(m));\n    });\n\n    const onMouseRelease = overload2((action: (m: MouseButton) => void) => {\n        return state.events.on(\"mouseRelease\", (m) => action(m));\n    }, (mouse: MouseButton, action: (m: MouseButton) => void) => {\n        return state.events.on(\"mouseRelease\", (m) => m === mouse && action(m));\n    });\n\n    function onMouseMove(f: (pos: Vec2, dpos: Vec2) => void): EventController {\n        return state.events.on(\n            \"mouseMove\",\n            () => f(mousePos(), mouseDeltaPos()),\n        );\n    }\n\n    function onCharInput(action: (ch: string) => void): EventController {\n        return state.events.on(\"charInput\", action);\n    }\n\n    function onTouchStart(f: (pos: Vec2, t: Touch) => void): EventController {\n        return state.events.on(\"touchStart\", f);\n    }\n\n    function onTouchMove(f: (pos: Vec2, t: Touch) => void): EventController {\n        return state.events.on(\"touchMove\", f);\n    }\n\n    function onTouchEnd(f: (pos: Vec2, t: Touch) => void): EventController {\n        return state.events.on(\"touchEnd\", f);\n    }\n\n    function onScroll(action: (delta: Vec2) => void): EventController {\n        return state.events.on(\"scroll\", action);\n    }\n\n    function onHide(action: () => void): EventController {\n        return state.events.on(\"hide\", action);\n    }\n\n    function onShow(action: () => void): EventController {\n        return state.events.on(\"show\", action);\n    }\n\n    function onGamepadButtonDown(\n        btn: GamepadButton | ((btn: GamepadButton) => void),\n        action?: (btn: GamepadButton) => void,\n    ): EventController {\n        if (typeof btn === \"function\") {\n            return state.events.on(\"gamepadButtonDown\", btn);\n        } else if (typeof btn === \"string\" && typeof action === \"function\") {\n            return state.events.on(\n                \"gamepadButtonDown\",\n                (b) => b === btn && action(btn),\n            );\n        }\n    }\n\n    function onGamepadButtonPress(\n        btn: GamepadButton | ((btn: GamepadButton) => void),\n        action?: (btn: GamepadButton) => void,\n    ): EventController {\n        if (typeof btn === \"function\") {\n            return state.events.on(\"gamepadButtonPress\", btn);\n        } else if (typeof btn === \"string\" && typeof action === \"function\") {\n            return state.events.on(\n                \"gamepadButtonPress\",\n                (b) => b === btn && action(btn),\n            );\n        }\n    }\n\n    function onGamepadButtonRelease(\n        btn: GamepadButton | ((btn: GamepadButton) => void),\n        action?: (btn: GamepadButton) => void,\n    ): EventController {\n        if (typeof btn === \"function\") {\n            return state.events.on(\"gamepadButtonRelease\", btn);\n        } else if (typeof btn === \"string\" && typeof action === \"function\") {\n            return state.events.on(\n                \"gamepadButtonRelease\",\n                (b) => b === btn && action(btn),\n            );\n        }\n    }\n\n    function onGamepadStick(\n        stick: GamepadStick,\n        action: (value: Vec2) => void,\n    ): EventController {\n        return state.events.on(\n            \"gamepadStick\",\n            (a: string, v: Vec2) => a === stick && action(v),\n        );\n    }\n\n    function onGamepadConnect(action: (gamepad: KGamePad) => void) {\n        state.events.on(\"gamepadConnect\", action);\n    }\n\n    function onGamepadDisconnect(action: (gamepad: KGamePad) => void) {\n        state.events.on(\"gamepadDisconnect\", action);\n    }\n\n    function getGamepadStick(stick: GamepadStick): Vec2 {\n        return state.mergedGamepadState.stickState.get(stick) || new Vec2(0);\n    }\n\n    function charInputted(): string[] {\n        return [...state.charInputted];\n    }\n\n    function getGamepads(): KGamePad[] {\n        return [...state.gamepads];\n    }\n\n    function processInput() {\n        state.events.trigger(\"input\");\n        state.keyState.down.forEach((k) => state.events.trigger(\"keyDown\", k));\n        state.mouseState.down.forEach((k) =>\n            state.events.trigger(\"mouseDown\", k)\n        );\n        processGamepad();\n    }\n\n    function resetInput() {\n        state.keyState.update();\n        state.mouseState.update();\n        state.mergedGamepadState.buttonState.update();\n        state.mergedGamepadState.stickState.forEach((v, k) => {\n            state.mergedGamepadState.stickState.set(k, new Vec2(0));\n        });\n        state.charInputted = [];\n        state.isMouseMoved = false;\n\n        state.gamepadStates.forEach((s) => {\n            s.buttonState.update();\n            s.stickState.forEach((v, k) => {\n                s.stickState.set(k, new Vec2(0));\n            });\n        });\n    }\n\n    function registerGamepad(browserGamepad: Gamepad) {\n        const gamepad = {\n            index: browserGamepad.index,\n            isPressed: (btn: GamepadButton) => {\n                return state.gamepadStates.get(browserGamepad.index).buttonState\n                    .pressed.has(btn);\n            },\n            isDown: (btn: GamepadButton) => {\n                return state.gamepadStates.get(browserGamepad.index).buttonState\n                    .down.has(btn);\n            },\n            isReleased: (btn: GamepadButton) => {\n                return state.gamepadStates.get(browserGamepad.index).buttonState\n                    .released.has(btn);\n            },\n            getStick: (stick: GamepadStick) => {\n                return state.gamepadStates.get(browserGamepad.index).stickState\n                    .get(stick);\n            },\n        };\n\n        state.gamepads.push(gamepad);\n\n        state.gamepadStates.set(browserGamepad.index, {\n            buttonState: new ButtonState(),\n            stickState: new Map([\n                [\"left\", new Vec2(0)],\n                [\"right\", new Vec2(0)],\n            ]),\n        });\n\n        return gamepad;\n    }\n\n    function removeGamepad(gamepad: Gamepad) {\n        state.gamepads = state.gamepads.filter((g) =>\n            g.index !== gamepad.index\n        );\n        state.gamepadStates.delete(gamepad.index);\n    }\n\n    function processGamepad() {\n        for (const browserGamepad of navigator.getGamepads()) {\n            if (\n                browserGamepad && !state.gamepadStates.has(browserGamepad.index)\n            ) {\n                registerGamepad(browserGamepad);\n            }\n        }\n\n        for (const gamepad of state.gamepads) {\n            const browserGamepad = navigator.getGamepads()[gamepad.index];\n            const customMap = opt.gamepads ?? {};\n            const map = customMap[browserGamepad.id]\n                ?? GAMEPAD_MAP[browserGamepad.id] ?? GAMEPAD_MAP[\"default\"];\n            const gamepadState = state.gamepadStates.get(gamepad.index);\n\n            for (let i = 0; i < browserGamepad.buttons.length; i++) {\n                if (browserGamepad.buttons[i].pressed) {\n                    if (!gamepadState.buttonState.down.has(map.buttons[i])) {\n                        state.mergedGamepadState.buttonState.press(\n                            map.buttons[i],\n                        );\n                        gamepadState.buttonState.press(map.buttons[i]);\n                        state.events.trigger(\n                            \"gamepadButtonPress\",\n                            map.buttons[i],\n                        );\n                    }\n                    state.events.trigger(\"gamepadButtonDown\", map.buttons[i]);\n                } else {\n                    if (gamepadState.buttonState.down.has(map.buttons[i])) {\n                        state.mergedGamepadState.buttonState.release(\n                            map.buttons[i],\n                        );\n                        gamepadState.buttonState.release(map.buttons[i]);\n                        state.events.trigger(\n                            \"gamepadButtonRelease\",\n                            map.buttons[i],\n                        );\n                    }\n                }\n            }\n\n            for (const stickName in map.sticks) {\n                const stick = map.sticks[stickName];\n                const value = new Vec2(\n                    browserGamepad.axes[stick.x],\n                    browserGamepad.axes[stick.y],\n                );\n                gamepadState.stickState.set(stickName as GamepadStick, value);\n                state.mergedGamepadState.stickState.set(\n                    stickName as GamepadStick,\n                    value,\n                );\n                state.events.trigger(\"gamepadStick\", stickName, value);\n            }\n        }\n    }\n\n    type EventList<M> = {\n        [event in keyof M]?: (event: M[event]) => void;\n    };\n\n    const canvasEvents: EventList<HTMLElementEventMap> = {};\n    const docEvents: EventList<DocumentEventMap> = {};\n    const winEvents: EventList<WindowEventMap> = {};\n\n    const pd = opt.pixelDensity || window.devicePixelRatio || 1;\n\n    canvasEvents.mousemove = (e) => {\n        const mousePos = new Vec2(e.offsetX, e.offsetY);\n        const mouseDeltaPos = new Vec2(e.movementX, e.movementY);\n        if (isFullscreen()) {\n            const cw = state.canvas.width / pd;\n            const ch = state.canvas.height / pd;\n            const ww = window.innerWidth;\n            const wh = window.innerHeight;\n            const rw = ww / wh;\n            const rc = cw / ch;\n            if (rw > rc) {\n                const ratio = wh / ch;\n                const offset = (ww - (cw * ratio)) / 2;\n                mousePos.x = map(e.offsetX - offset, 0, cw * ratio, 0, cw);\n                mousePos.y = map(e.offsetY, 0, ch * ratio, 0, ch);\n            } else {\n                const ratio = ww / cw;\n                const offset = (wh - (ch * ratio)) / 2;\n                mousePos.x = map(e.offsetX, 0, cw * ratio, 0, cw);\n                mousePos.y = map(e.offsetY - offset, 0, ch * ratio, 0, ch);\n            }\n        }\n        state.events.onOnce(\"input\", () => {\n            state.isMouseMoved = true;\n            state.mousePos = mousePos;\n            state.mouseDeltaPos = mouseDeltaPos;\n            state.events.trigger(\"mouseMove\");\n        });\n    };\n\n    const MOUSE_BUTTONS: MouseButton[] = [\n        \"left\",\n        \"middle\",\n        \"right\",\n        \"back\",\n        \"forward\",\n    ];\n\n    canvasEvents.mousedown = (e) => {\n        state.events.onOnce(\"input\", () => {\n            const m = MOUSE_BUTTONS[e.button];\n            if (!m) return;\n            state.mouseState.press(m);\n            state.events.trigger(\"mousePress\", m);\n        });\n    };\n\n    canvasEvents.mouseup = (e) => {\n        state.events.onOnce(\"input\", () => {\n            const m = MOUSE_BUTTONS[e.button];\n            if (!m) return;\n            state.mouseState.release(m);\n            state.events.trigger(\"mouseRelease\", m);\n        });\n    };\n\n    const PREVENT_DEFAULT_KEYS = new Set([\n        \" \",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"Tab\",\n    ]);\n\n    // translate these key names to a simpler version\n    const KEY_ALIAS = {\n        \"ArrowLeft\": \"left\",\n        \"ArrowRight\": \"right\",\n        \"ArrowUp\": \"up\",\n        \"ArrowDown\": \"down\",\n        \" \": \"space\",\n    };\n\n    canvasEvents.keydown = (e) => {\n        if (PREVENT_DEFAULT_KEYS.has(e.key)) {\n            e.preventDefault();\n        }\n        state.events.onOnce(\"input\", () => {\n            const k = KEY_ALIAS[e.key] || e.key.toLowerCase();\n            if (k.length === 1) {\n                state.events.trigger(\"charInput\", k);\n                state.charInputted.push(k);\n            } else if (k === \"space\") {\n                state.events.trigger(\"charInput\", \" \");\n                state.charInputted.push(\" \");\n            }\n            if (e.repeat) {\n                state.keyState.pressRepeat(k);\n                state.events.trigger(\"keyPressRepeat\", k);\n            } else {\n                state.keyState.press(k);\n                state.events.trigger(\"keyPressRepeat\", k);\n                state.events.trigger(\"keyPress\", k);\n            }\n        });\n    };\n\n    canvasEvents.keyup = (e) => {\n        state.events.onOnce(\"input\", () => {\n            const k = KEY_ALIAS[e.key] || e.key.toLowerCase();\n            state.keyState.release(k);\n            state.events.trigger(\"keyRelease\", k);\n        });\n    };\n\n    // TODO: handle all touches at once instead of sequentially\n    canvasEvents.touchstart = (e) => {\n        // disable long tap context menu\n        e.preventDefault();\n        state.events.onOnce(\"input\", () => {\n            const touches = [...e.changedTouches];\n            const box = state.canvas.getBoundingClientRect();\n            if (opt.touchToMouse !== false) {\n                state.mousePos = new Vec2(\n                    touches[0].clientX - box.x,\n                    touches[0].clientY - box.y,\n                );\n                state.mouseState.press(\"left\");\n                state.events.trigger(\"mousePress\", \"left\");\n            }\n            touches.forEach((t) => {\n                state.events.trigger(\n                    \"touchStart\",\n                    new Vec2(t.clientX - box.x, t.clientY - box.y),\n                    t,\n                );\n            });\n        });\n    };\n\n    canvasEvents.touchmove = (e) => {\n        // disable scrolling\n        e.preventDefault();\n        state.events.onOnce(\"input\", () => {\n            const touches = [...e.changedTouches];\n            const box = state.canvas.getBoundingClientRect();\n            if (opt.touchToMouse !== false) {\n                const lastMousePos = state.mousePos;\n                state.mousePos = new Vec2(\n                    touches[0].clientX - box.x,\n                    touches[0].clientY - box.y,\n                );\n                state.mouseDeltaPos = state.mousePos.sub(lastMousePos);\n                state.events.trigger(\"mouseMove\");\n            }\n            touches.forEach((t) => {\n                state.events.trigger(\n                    \"touchMove\",\n                    new Vec2(t.clientX - box.x, t.clientY - box.y),\n                    t,\n                );\n            });\n        });\n    };\n\n    canvasEvents.touchend = (e) => {\n        state.events.onOnce(\"input\", () => {\n            const touches = [...e.changedTouches];\n            const box = state.canvas.getBoundingClientRect();\n            if (opt.touchToMouse !== false) {\n                state.mousePos = new Vec2(\n                    touches[0].clientX - box.x,\n                    touches[0].clientY - box.y,\n                );\n                state.mouseDeltaPos = new Vec2(0, 0);\n                state.mouseState.release(\"left\");\n                state.events.trigger(\"mouseRelease\", \"left\");\n            }\n            touches.forEach((t) => {\n                state.events.trigger(\n                    \"touchEnd\",\n                    new Vec2(t.clientX - box.x, t.clientY - box.y),\n                    t,\n                );\n            });\n        });\n    };\n\n    canvasEvents.touchcancel = (e) => {\n        state.events.onOnce(\"input\", () => {\n            const touches = [...e.changedTouches];\n            const box = state.canvas.getBoundingClientRect();\n            if (opt.touchToMouse !== false) {\n                state.mousePos = new Vec2(\n                    touches[0].clientX - box.x,\n                    touches[0].clientY - box.y,\n                );\n                state.mouseState.release(\"left\");\n                state.events.trigger(\"mouseRelease\", \"left\");\n            }\n            touches.forEach((t) => {\n                state.events.trigger(\n                    \"touchEnd\",\n                    new Vec2(t.clientX - box.x, t.clientY - box.y),\n                    t,\n                );\n            });\n        });\n    };\n\n    // TODO: option to not prevent default?\n    canvasEvents.wheel = (e) => {\n        e.preventDefault();\n        state.events.onOnce(\"input\", () => {\n            state.events.trigger(\"scroll\", new Vec2(e.deltaX, e.deltaY));\n        });\n    };\n\n    canvasEvents.contextmenu = (e) => e.preventDefault();\n\n    docEvents.visibilitychange = () => {\n        if (document.visibilityState === \"visible\") {\n            // prevent a surge of dt when switch back after the tab being hidden for a while\n            state.skipTime = true;\n            state.isHidden = false;\n            state.events.trigger(\"show\");\n        } else {\n            state.isHidden = true;\n            state.events.trigger(\"hide\");\n        }\n    };\n\n    winEvents.gamepadconnected = (e) => {\n        const kbGamepad = registerGamepad(e.gamepad);\n        state.events.onOnce(\"input\", () => {\n            state.events.trigger(\"gamepadConnect\", kbGamepad);\n        });\n    };\n\n    winEvents.gamepaddisconnected = (e) => {\n        const kbGamepad =\n            getGamepads().filter((g) => g.index === e.gamepad.index)[0];\n        removeGamepad(e.gamepad);\n        state.events.onOnce(\"input\", () => {\n            state.events.trigger(\"gamepadDisconnect\", kbGamepad);\n        });\n    };\n\n    for (const name in canvasEvents) {\n        state.canvas.addEventListener(name, canvasEvents[name]);\n    }\n\n    for (const name in docEvents) {\n        document.addEventListener(name, docEvents[name]);\n    }\n\n    for (const name in winEvents) {\n        window.addEventListener(name, winEvents[name]);\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n            if (entry.target !== state.canvas) continue;\n            if (\n                state.lastWidth === state.canvas.offsetWidth\n                && state.lastHeight === state.canvas.offsetHeight\n            ) return;\n            state.lastWidth = state.canvas.offsetWidth;\n            state.lastHeight = state.canvas.offsetHeight;\n            state.events.onOnce(\"input\", () => {\n                state.events.trigger(\"resize\");\n            });\n        }\n    });\n\n    resizeObserver.observe(state.canvas);\n\n    return {\n        dt,\n        time,\n        run,\n        canvas: state.canvas,\n        fps,\n        numFrames,\n        quit,\n        isHidden,\n        setFullscreen,\n        isFullscreen,\n        setCursor,\n        screenshot,\n        getGamepads,\n        getCursor,\n        setCursorLocked,\n        isCursorLocked,\n        isTouchscreen,\n        mousePos,\n        mouseDeltaPos,\n        isKeyDown,\n        isKeyPressed,\n        isKeyPressedRepeat,\n        isKeyReleased,\n        isMouseDown,\n        isMousePressed,\n        isMouseReleased,\n        isMouseMoved,\n        isGamepadButtonPressed,\n        isGamepadButtonDown,\n        isGamepadButtonReleased,\n        getGamepadStick,\n        charInputted,\n        onResize,\n        onKeyDown,\n        onKeyPress,\n        onKeyPressRepeat,\n        onKeyRelease,\n        onMouseDown,\n        onMousePress,\n        onMouseRelease,\n        onMouseMove,\n        onCharInput,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        onScroll,\n        onHide,\n        onShow,\n        onGamepadButtonDown,\n        onGamepadButtonPress,\n        onGamepadButtonRelease,\n        onGamepadStick,\n        onGamepadConnect,\n        onGamepadDisconnect,\n        events: state.events,\n    };\n};\n", "import type { ImageSource, TexFilter, TextureOpt, Uniform } from \"./types\";\n\nimport { Color, Mat4, Vec2 } from \"./math\";\n\nimport { deepEq } from \"./utils\";\n\nexport type GfxCtx = ReturnType<typeof initGfx>;\n\nexport class Texture {\n    ctx: GfxCtx;\n    src: null | ImageSource = null;\n    glTex: WebGLTexture;\n    width: number;\n    height: number;\n\n    constructor(ctx: GfxCtx, w: number, h: number, opt: TextureOpt = {}) {\n        this.ctx = ctx;\n        const gl = ctx.gl;\n        this.glTex = ctx.gl.createTexture();\n        ctx.onDestroy(() => this.free());\n\n        this.width = w;\n        this.height = h;\n\n        // TODO: no default\n        const filter = {\n            \"linear\": gl.LINEAR,\n            \"nearest\": gl.NEAREST,\n        }[opt.filter ?? ctx.opts.texFilter] ?? gl.NEAREST;\n\n        const wrap = {\n            \"repeat\": gl.REPEAT,\n            \"clampToEadge\": gl.CLAMP_TO_EDGE,\n        }[opt.wrap] ?? gl.CLAMP_TO_EDGE;\n\n        this.bind();\n\n        if (w && h) {\n            gl.texImage2D(\n                gl.TEXTURE_2D,\n                0,\n                gl.RGBA,\n                w,\n                h,\n                0,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                null,\n            );\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\n        this.unbind();\n    }\n\n    static fromImage(\n        ctx: GfxCtx,\n        img: ImageSource,\n        opt: TextureOpt = {},\n    ): Texture {\n        const tex = new Texture(ctx, img.width, img.height, opt);\n        tex.update(img);\n        tex.src = img;\n        return tex;\n    }\n\n    update(img: ImageSource, x = 0, y = 0) {\n        const gl = this.ctx.gl;\n        this.bind();\n        gl.texSubImage2D(\n            gl.TEXTURE_2D,\n            0,\n            x,\n            y,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            img,\n        );\n        this.unbind();\n    }\n\n    bind() {\n        this.ctx.pushTexture2D(this.glTex);\n    }\n\n    unbind() {\n        this.ctx.popTexture2D();\n    }\n\n    free() {\n        this.ctx.gl.deleteTexture(this.glTex);\n    }\n}\n\nexport class FrameBuffer {\n    ctx: GfxCtx;\n    tex: Texture;\n    glFramebuffer: WebGLFramebuffer;\n    glRenderbuffer: WebGLRenderbuffer;\n\n    constructor(ctx: GfxCtx, w: number, h: number, opt: TextureOpt = {}) {\n        this.ctx = ctx;\n        const gl = ctx.gl;\n        ctx.onDestroy(() => this.free());\n        this.tex = new Texture(ctx, w, h, opt);\n        this.glFramebuffer = gl.createFramebuffer();\n        this.glRenderbuffer = gl.createRenderbuffer();\n        this.bind();\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            this.tex.glTex,\n            0,\n        );\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            this.glRenderbuffer,\n        );\n        this.unbind();\n    }\n\n    get width() {\n        return this.tex.width;\n    }\n\n    get height() {\n        return this.tex.height;\n    }\n\n    toImageData() {\n        const gl = this.ctx.gl;\n        const data = new Uint8ClampedArray(this.width * this.height * 4);\n        this.bind();\n        gl.readPixels(\n            0,\n            0,\n            this.width,\n            this.height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            data,\n        );\n        this.unbind();\n        // flip vertically\n        const bytesPerRow = this.width * 4;\n        const temp = new Uint8Array(bytesPerRow);\n        for (let y = 0; y < (this.height / 2 | 0); y++) {\n            const topOffset = y * bytesPerRow;\n            const bottomOffset = (this.height - y - 1) * bytesPerRow;\n            temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n            data.copyWithin(\n                topOffset,\n                bottomOffset,\n                bottomOffset + bytesPerRow,\n            );\n            data.set(temp, bottomOffset);\n        }\n        return new ImageData(data, this.width, this.height);\n    }\n\n    toDataURL() {\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        canvas.width = this.width;\n        canvas.height = this.height;\n        ctx.putImageData(this.toImageData(), 0, 0);\n        return canvas.toDataURL();\n    }\n\n    clear() {\n        const gl = this.ctx.gl;\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    draw(action: () => void) {\n        this.bind();\n        action();\n        this.unbind();\n    }\n\n    bind() {\n        this.ctx.pushFramebuffer(this.glFramebuffer);\n        this.ctx.pushRenderbuffer(this.glRenderbuffer);\n        this.ctx.pushViewport({ x: 0, y: 0, w: this.width, h: this.height });\n    }\n\n    unbind() {\n        this.ctx.popFramebuffer();\n        this.ctx.popRenderbuffer();\n        this.ctx.popViewport();\n    }\n\n    free() {\n        const gl = this.ctx.gl;\n        gl.deleteFramebuffer(this.glFramebuffer);\n        gl.deleteRenderbuffer(this.glRenderbuffer);\n        this.tex.free();\n    }\n}\n\nexport class Shader {\n    ctx: GfxCtx;\n    glProgram: WebGLProgram;\n\n    constructor(ctx: GfxCtx, vert: string, frag: string, attribs: string[]) {\n        this.ctx = ctx;\n        ctx.onDestroy(() => this.free());\n\n        const gl = ctx.gl;\n        const vertShader = gl.createShader(gl.VERTEX_SHADER);\n        const fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n        gl.shaderSource(vertShader, vert);\n        gl.shaderSource(fragShader, frag);\n        gl.compileShader(vertShader);\n        gl.compileShader(fragShader);\n\n        const prog = gl.createProgram();\n        this.glProgram = prog;\n\n        gl.attachShader(prog, vertShader);\n        gl.attachShader(prog, fragShader);\n\n        attribs.forEach((attrib, i) => gl.bindAttribLocation(prog, i, attrib));\n\n        gl.linkProgram(prog);\n\n        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n            const vertError = gl.getShaderInfoLog(vertShader);\n            if (vertError) throw new Error(\"VERTEX SHADER \" + vertError);\n            const fragError = gl.getShaderInfoLog(fragShader);\n            if (fragError) throw new Error(\"FRAGMENT SHADER \" + fragError);\n        }\n\n        gl.deleteShader(vertShader);\n        gl.deleteShader(fragShader);\n    }\n\n    bind() {\n        this.ctx.pushProgram(this.glProgram);\n    }\n\n    unbind() {\n        this.ctx.popProgram();\n    }\n\n    send(uniform: Uniform) {\n        const gl = this.ctx.gl;\n        for (const name in uniform) {\n            const val = uniform[name];\n            const loc = gl.getUniformLocation(this.glProgram, name);\n            if (typeof val === \"number\") {\n                gl.uniform1f(loc, val);\n            } else if (val instanceof Mat4) {\n                gl.uniformMatrix4fv(loc, false, new Float32Array(val.m));\n            } else if (val instanceof Color) {\n                gl.uniform3f(loc, val.r, val.g, val.b);\n            } else if (val instanceof Vec2) {\n                gl.uniform2f(loc, val.x, val.y);\n            } else if (Array.isArray(val)) {\n                const first = val[0];\n                if (typeof first === \"number\") {\n                    gl.uniform1fv(loc, val as number[]);\n                } else if (first instanceof Vec2) {\n                    gl.uniform2fv(loc, val.map(v => [v.x, v.y]).flat());\n                } else if (first instanceof Color) {\n                    gl.uniform3fv(loc, val.map(v => [v.r, v.g, v.b]).flat());\n                }\n            } else {\n                throw new Error(\"Unsupported uniform data type\");\n            }\n        }\n    }\n\n    free() {\n        this.ctx.gl.deleteProgram(this.glProgram);\n    }\n}\n\nexport type VertexFormat = {\n    name: string;\n    size: number;\n}[];\n\nexport class BatchRenderer {\n    ctx: GfxCtx;\n\n    glVBuf: WebGLBuffer;\n    glIBuf: WebGLBuffer;\n    vqueue: number[] = [];\n    iqueue: number[] = [];\n    stride: number;\n    maxVertices: number;\n    maxIndices: number;\n\n    vertexFormat: VertexFormat;\n    numDraws: number = 0;\n\n    curPrimitive: GLenum | null = null;\n    curTex: Texture | null = null;\n    curShader: Shader | null = null;\n    curUniform: Uniform = {};\n\n    constructor(\n        ctx: GfxCtx,\n        format: VertexFormat,\n        maxVertices: number,\n        maxIndices: number,\n    ) {\n        const gl = ctx.gl;\n\n        this.vertexFormat = format;\n        this.ctx = ctx;\n        this.stride = format.reduce((sum, f) => sum + f.size, 0);\n        this.maxVertices = maxVertices;\n        this.maxIndices = maxIndices;\n\n        this.glVBuf = gl.createBuffer();\n        ctx.pushArrayBuffer(this.glVBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, maxVertices * 4, gl.DYNAMIC_DRAW);\n        ctx.popArrayBuffer();\n\n        this.glIBuf = gl.createBuffer();\n        ctx.pushElementArrayBuffer(this.glIBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, maxIndices * 4, gl.DYNAMIC_DRAW);\n        ctx.popElementArrayBuffer();\n    }\n\n    push(\n        primitive: GLenum,\n        verts: number[],\n        indices: number[],\n        shader: Shader,\n        tex: Texture | null = null,\n        uniform: Uniform = {},\n    ) {\n        if (\n            primitive !== this.curPrimitive\n            || tex !== this.curTex\n            || shader !== this.curShader\n            || !deepEq(this.curUniform, uniform)\n            || this.vqueue.length + verts.length * this.stride\n                > this.maxVertices\n            || this.iqueue.length + indices.length > this.maxIndices\n        ) {\n            this.flush();\n        }\n        const indexOffset = this.vqueue.length / this.stride;\n        for (const v of verts) {\n            this.vqueue.push(v);\n        }\n        for (const i of indices) {\n            this.iqueue.push(i + indexOffset);\n        }\n        this.curPrimitive = primitive;\n        this.curShader = shader;\n        this.curTex = tex;\n        this.curUniform = uniform;\n    }\n\n    flush() {\n        if (\n            !this.curPrimitive\n            || !this.curShader\n            || this.vqueue.length === 0\n            || this.iqueue.length === 0\n        ) {\n            return;\n        }\n\n        const gl = this.ctx.gl;\n\n        this.ctx.pushArrayBuffer(this.glVBuf);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(this.vqueue));\n        this.ctx.pushElementArrayBuffer(this.glIBuf);\n        gl.bufferSubData(\n            gl.ELEMENT_ARRAY_BUFFER,\n            0,\n            new Uint16Array(this.iqueue),\n        );\n        this.ctx.setVertexFormat(this.vertexFormat);\n        this.curShader.bind();\n        this.curShader.send(this.curUniform);\n        this.curTex?.bind();\n        gl.drawElements(\n            this.curPrimitive,\n            this.iqueue.length,\n            gl.UNSIGNED_SHORT,\n            0,\n        );\n        this.curTex?.unbind();\n        this.curShader.unbind();\n\n        this.ctx.popArrayBuffer();\n        this.ctx.popElementArrayBuffer();\n\n        this.vqueue = [];\n        this.iqueue = [];\n        this.numDraws++;\n    }\n\n    free() {\n        const gl = this.ctx.gl;\n        gl.deleteBuffer(this.glVBuf);\n        gl.deleteBuffer(this.glIBuf);\n    }\n}\n\nexport class Mesh {\n    ctx: GfxCtx;\n    glVBuf: WebGLBuffer;\n    glIBuf: WebGLBuffer;\n    vertexFormat: VertexFormat;\n    count: number;\n\n    constructor(\n        ctx: GfxCtx,\n        format: VertexFormat,\n        verts: number[],\n        indices: number[],\n    ) {\n        const gl = ctx.gl;\n\n        this.vertexFormat = format;\n        this.ctx = ctx;\n\n        this.glVBuf = gl.createBuffer();\n        ctx.pushArrayBuffer(this.glVBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);\n        ctx.popArrayBuffer();\n\n        this.glIBuf = gl.createBuffer();\n        ctx.pushElementArrayBuffer(this.glIBuf);\n        gl.bufferData(\n            gl.ELEMENT_ARRAY_BUFFER,\n            new Uint16Array(indices),\n            gl.STATIC_DRAW,\n        );\n        ctx.popElementArrayBuffer();\n\n        this.count = indices.length;\n    }\n\n    draw(primitive?: GLenum) {\n        const gl = this.ctx.gl;\n        this.ctx.pushArrayBuffer(this.glVBuf);\n        this.ctx.pushElementArrayBuffer(this.glIBuf);\n        this.ctx.setVertexFormat(this.vertexFormat);\n        gl.drawElements(\n            primitive ?? gl.TRIANGLES,\n            this.count,\n            gl.UNSIGNED_SHORT,\n            0,\n        );\n        this.ctx.popArrayBuffer();\n        this.ctx.popElementArrayBuffer();\n    }\n\n    free() {\n        const gl = this.ctx.gl;\n        gl.deleteBuffer(this.glVBuf);\n        gl.deleteBuffer(this.glIBuf);\n    }\n}\n\nfunction genStack<T>(setFunc: (item: T) => void) {\n    const stack: T[] = [];\n    // TODO: don't do anything if pushed item is the same as the one on top?\n    const push = (item: T) => {\n        stack.push(item);\n        setFunc(item);\n    };\n    const pop = () => {\n        stack.pop();\n        setFunc(cur() ?? null);\n    };\n    const cur = () => stack[stack.length - 1];\n    return [push, pop, cur] as const;\n}\n\nexport default function initGfx(gl: WebGLRenderingContext, opts: {\n    texFilter?: TexFilter;\n} = {}) {\n    const gc: Array<() => void> = [];\n\n    function onDestroy(action) {\n        gc.push(action);\n    }\n\n    function destroy() {\n        gc.forEach((action) => action());\n        gl.getExtension(\"WEBGL_lose_context\").loseContext();\n    }\n\n    let curVertexFormat = null;\n\n    function setVertexFormat(fmt: VertexFormat) {\n        if (deepEq(fmt, curVertexFormat)) return;\n        curVertexFormat = fmt;\n        const stride = fmt.reduce((sum, f) => sum + f.size, 0);\n        fmt.reduce((offset, f, i) => {\n            gl.vertexAttribPointer(\n                i,\n                f.size,\n                gl.FLOAT,\n                false,\n                stride * 4,\n                offset,\n            );\n            gl.enableVertexAttribArray(i);\n            return offset + f.size * 4;\n        }, 0);\n    }\n\n    const [pushTexture2D, popTexture2D] = genStack<WebGLTexture>((t) =>\n        gl.bindTexture(gl.TEXTURE_2D, t)\n    );\n\n    const [pushArrayBuffer, popArrayBuffer] = genStack<WebGLBuffer>((b) =>\n        gl.bindBuffer(gl.ARRAY_BUFFER, b)\n    );\n\n    const [pushElementArrayBuffer, popElementArrayBuffer] = genStack<\n        WebGLBuffer\n    >((b) => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b));\n\n    const [pushFramebuffer, popFramebuffer] = genStack<WebGLFramebuffer>((b) =>\n        gl.bindFramebuffer(gl.FRAMEBUFFER, b)\n    );\n\n    const [pushRenderbuffer, popRenderbuffer] = genStack<WebGLRenderbuffer>((\n        b,\n    ) => gl.bindRenderbuffer(gl.RENDERBUFFER, b));\n\n    const [pushViewport, popViewport] = genStack<\n        { x: number; y: number; w: number; h: number }\n    >(({ x, y, w, h }) => {\n        gl.viewport(x, y, w, h);\n    });\n\n    const [pushProgram, popProgram] = genStack<WebGLProgram>((p) =>\n        gl.useProgram(p)\n    );\n\n    pushViewport({\n        x: 0,\n        y: 0,\n        w: gl.drawingBufferWidth,\n        h: gl.drawingBufferHeight,\n    });\n\n    return {\n        gl,\n        opts,\n        onDestroy,\n        destroy,\n        pushTexture2D,\n        popTexture2D,\n        pushArrayBuffer,\n        popArrayBuffer,\n        pushElementArrayBuffer,\n        popElementArrayBuffer,\n        pushFramebuffer,\n        popFramebuffer,\n        pushRenderbuffer,\n        popRenderbuffer,\n        pushViewport,\n        popViewport,\n        pushProgram,\n        popProgram,\n        setVertexFormat,\n    };\n}\n", "import { Event } from \"./utils\";\n\nexport class Asset<D> {\n    loaded: boolean = false;\n    data: D | null = null;\n    error: Error | null = null;\n    private onLoadEvents: Event<[D]> = new Event();\n    private onErrorEvents: Event<[Error]> = new Event();\n    private onFinishEvents: Event<[]> = new Event();\n    constructor(loader: Promise<D>) {\n        loader.then((data) => {\n            this.loaded = true;\n            this.data = data;\n            this.onLoadEvents.trigger(data);\n        }).catch((err) => {\n            this.error = err;\n            if (this.onErrorEvents.numListeners() > 0) {\n                this.onErrorEvents.trigger(err);\n            } else {\n                throw err;\n            }\n        }).finally(() => {\n            this.onFinishEvents.trigger();\n            this.loaded = true;\n        });\n    }\n    static loaded<D>(data: D): Asset<D> {\n        const asset = new Asset(Promise.resolve(data)) as Asset<D>;\n        asset.data = data;\n        asset.loaded = true;\n        return asset;\n    }\n    onLoad(action: (data: D) => void) {\n        if (this.loaded && this.data) {\n            action(this.data);\n        } else {\n            this.onLoadEvents.add(action);\n        }\n        return this;\n    }\n    onError(action: (err: Error) => void) {\n        if (this.loaded && this.error) {\n            action(this.error);\n        } else {\n            this.onErrorEvents.add(action);\n        }\n        return this;\n    }\n    onFinish(action: () => void) {\n        if (this.loaded) {\n            action();\n        } else {\n            this.onFinishEvents.add(action);\n        }\n        return this;\n    }\n    then(action: (data: D) => void): Asset<D> {\n        return this.onLoad(action);\n    }\n    catch(action: (err: Error) => void): Asset<D> {\n        return this.onError(action);\n    }\n    finally(action: () => void): Asset<D> {\n        return this.onFinish(action);\n    }\n}\n\nexport class AssetBucket<D> {\n    assets: Map<string, Asset<D>> = new Map();\n    lastUID: number = 0;\n    add(name: string | null, loader: Promise<D>): Asset<D> {\n        // if user don't provide a name we use a generated one\n        const id = name ?? (this.lastUID++ + \"\");\n        const asset = new Asset(loader);\n        this.assets.set(id, asset);\n        return asset;\n    }\n    addLoaded(name: string | null, data: D): Asset<D> {\n        const id = name ?? (this.lastUID++ + \"\");\n        const asset = Asset.loaded(data);\n        this.assets.set(id, asset);\n        return asset;\n    }\n    get(handle: string): Asset<D> | void {\n        return this.assets.get(handle);\n    }\n    progress(): number {\n        if (this.assets.size === 0) {\n            return 1;\n        }\n        let loaded = 0;\n        this.assets.forEach((asset) => {\n            if (asset.loaded) {\n                loaded++;\n            }\n        });\n        return loaded / this.assets.size;\n    }\n}\n\nexport function fetchURL(url: string) {\n    return fetch(url)\n        .then((res) => {\n            if (!res.ok) throw new Error(`Failed to fetch \"${url}\"`);\n            return res;\n        });\n}\n\nexport function fetchJSON(path: string) {\n    return fetchURL(path).then((res) => res.json());\n}\n\nexport function fetchText(path: string) {\n    return fetchURL(path).then((res) => res.text());\n}\n\nexport function fetchArrayBuffer(path: string) {\n    return fetchURL(path).then((res) => res.arrayBuffer());\n}\n\n// wrapper around image loader to get a Promise\nexport function loadImg(src: string): Promise<HTMLImageElement> {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.src = src;\n    return new Promise<HTMLImageElement>((resolve, reject) => {\n        img.onload = () => resolve(img);\n        img.onerror = () =>\n            reject(new Error(`Failed to load image from \"${src}\"`));\n    });\n}\n", "// some default charsets for loading bitmap fonts\nexport const ASCII_CHARS =\n    \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\nexport const DEF_ANCHOR = \"topleft\";\nexport const BG_GRID_SIZE = 64;\nexport const DEF_FONT = \"monospace\";\nexport const DBG_FONT = \"monospace\";\nexport const DEF_TEXT_SIZE = 36;\nexport const DEF_TEXT_CACHE_SIZE = 64;\nexport const MAX_TEXT_CACHE_SIZE = 256;\nexport const FONT_ATLAS_WIDTH = 2048;\nexport const FONT_ATLAS_HEIGHT = 2048;\nexport const SPRITE_ATLAS_WIDTH = 2048;\nexport const SPRITE_ATLAS_HEIGHT = 2048;\n// 0.1 pixel padding to texture coordinates to prevent artifact\nexport const UV_PAD = 0.1;\nexport const DEF_HASH_GRID_SIZE = 64;\nexport const DEF_FONT_FILTER = \"linear\";\nexport const LOG_MAX = 8;\nexport const LOG_TIME = 4;\nexport const VERTEX_FORMAT = [\n    { name: \"a_pos\", size: 2 },\n    { name: \"a_uv\", size: 2 },\n    { name: \"a_color\", size: 4 },\n];\nconst STRIDE = VERTEX_FORMAT.reduce((sum, f) => sum + f.size, 0);\nconst MAX_BATCHED_QUAD = 2048;\nexport const MAX_BATCHED_VERTS = MAX_BATCHED_QUAD * 4 * STRIDE;\nexport const MAX_BATCHED_INDICES = MAX_BATCHED_QUAD * 6;\n// vertex shader template, replace {{user}} with user vertex shader code\nexport const VERT_TEMPLATE = `\nattribute vec2 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvec4 def_vert() {\n\treturn vec4(a_pos, 0.0, 1.0);\n}\n\n{{user}}\n\nvoid main() {\n\tvec4 pos = vert(a_pos, a_uv, a_color);\n\tv_pos = a_pos;\n\tv_uv = a_uv;\n\tv_color = a_color;\n\tgl_Position = pos;\n}\n`;\n// fragment shader template, replace {{user}} with user fragment shader code\nexport const FRAG_TEMPLATE = `\nprecision mediump float;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nuniform sampler2D u_tex;\n\nvec4 def_frag() {\n\treturn v_color * texture2D(u_tex, v_uv);\n}\n\n{{user}}\n\nvoid main() {\n\tgl_FragColor = frag(v_pos, v_uv, v_color, u_tex);\n\tif (gl_FragColor.a == 0.0) {\n\t\tdiscard;\n\t}\n}\n`;\n// default {{user}} vertex shader code\nexport const DEF_VERT = `\nvec4 vert(vec2 pos, vec2 uv, vec4 color) {\n\treturn def_vert();\n}\n`;\n// default {{user}} fragment shader code\nexport const DEF_FRAG = `\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\treturn def_frag();\n}\n`;\nexport const COMP_DESC = new Set([\"id\", \"require\"]);\nexport const COMP_EVENTS = new Set([\n    \"add\",\n    \"update\",\n    \"draw\",\n    \"destroy\",\n    \"inspect\",\n    \"drawInspect\",\n]);\n// TODO: escape\n// eslint-disable-next-line\nexport const TEXT_STYLE_RE = /\\[(?<style>\\w+)\\](?<text>.*?)\\[\\/\\k<style>\\]/g;\nexport const DEF_OFFSCREEN_DIS = 200;\n// maximum y velocity with body()\nexport const DEF_JUMP_FORCE = 640;\nexport const MAX_VEL = 65536;\n", "// https://easings.net/\nconst c1 = 1.70158;\nconst c2 = c1 * 1.525;\nconst c3 = c1 + 1;\nconst c4 = (2 * Math.PI) / 3;\nconst c5 = (2 * Math.PI) / 4.5;\n\nconst easings = {\n    linear: (x) => x,\n    easeInSine: (x) => 1 - Math.cos((x * Math.PI) / 2),\n    easeOutSine: (x) => Math.sin((x * Math.PI) / 2),\n    easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,\n    easeInQuad: (x) => x * x,\n    easeOutQuad: (x) => 1 - (1 - x) * (1 - x),\n    easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,\n    easeInCubic: (x) => x * x * x,\n    easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),\n    easeInOutCubic: (x) =>\n        x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,\n    easeInQuart: (x) => x * x * x * x,\n    easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),\n    easeInOutQuart: (x) =>\n        x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,\n    easeInQuint: (x) => x * x * x * x * x,\n    easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),\n    easeInOutQuint: (x) =>\n        x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,\n    easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),\n    easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),\n    easeInOutExpo: (x) => {\n        return x === 0\n            ? 0\n            : x === 1\n            ? 1\n            : x < 0.5\n            ? Math.pow(2, 20 * x - 10) / 2\n            : (2 - Math.pow(2, -20 * x + 10)) / 2;\n    },\n    easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),\n    easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),\n    easeInOutCirc: (x) => {\n        return x < 0.5\n            ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2\n            : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n    },\n    easeInBack: (x) => c3 * x * x * x - c1 * x * x,\n    easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),\n    easeInOutBack: (x) => {\n        return x < 0.5\n            ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n            : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n    },\n    easeInElastic: (x) => {\n        return x === 0\n            ? 0\n            : x === 1\n            ? 1\n            : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);\n    },\n    easeOutElastic: (x) => {\n        return x === 0\n            ? 0\n            : x === 1\n            ? 1\n            : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n    },\n    easeInOutElastic: (x) => {\n        return x === 0\n            ? 0\n            : x === 1\n            ? 1\n            : x < 0.5\n            ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2\n            : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2\n                + 1;\n    },\n    easeInBounce: (x) => 1 - easings.easeOutBounce(1 - x),\n    easeOutBounce: (x) => {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (x < 1 / d1) {\n            return n1 * x * x;\n        } else if (x < 2 / d1) {\n            return n1 * (x -= 1.5 / d1) * x + 0.75;\n        } else if (x < 2.5 / d1) {\n            return n1 * (x -= 2.25 / d1) * x + 0.9375;\n        } else {\n            return n1 * (x -= 2.625 / d1) * x + 0.984375;\n        }\n    },\n    easeInOutBounce: (x) => {\n        return x < 0.5\n            ? (1 - easings.easeOutBounce(1 - 2 * x)) / 2\n            : (1 + easings.easeOutBounce(2 * x - 1)) / 2;\n    },\n};\n\nexport default easings;\n", "import type { ImageSource } from \"./types\";\n\nimport { type GfxCtx, Texture } from \"./gfx\";\n\nimport { Quad, Vec2 } from \"./math\";\n\nexport default class TexPacker {\n    private textures: Texture[] = [];\n    private bigTextures: Texture[] = [];\n    private canvas: HTMLCanvasElement;\n    private c2d: CanvasRenderingContext2D;\n    private x: number = 0;\n    private y: number = 0;\n    private curHeight: number = 0;\n    private gfx: GfxCtx;\n    constructor(gfx: GfxCtx, w: number, h: number) {\n        this.gfx = gfx;\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        this.textures = [Texture.fromImage(gfx, this.canvas)];\n        this.bigTextures = [];\n        this.c2d = this.canvas.getContext(\"2d\");\n    }\n    add(img: ImageSource): [Texture, Quad] {\n        if (img.width > this.canvas.width || img.height > this.canvas.height) {\n            const tex = Texture.fromImage(this.gfx, img);\n            this.bigTextures.push(tex);\n            return [tex, new Quad(0, 0, 1, 1)];\n        }\n        // next row\n        if (this.x + img.width > this.canvas.width) {\n            this.x = 0;\n            this.y += this.curHeight;\n            this.curHeight = 0;\n        }\n        // next texture\n        if (this.y + img.height > this.canvas.height) {\n            this.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.textures.push(Texture.fromImage(this.gfx, this.canvas));\n            this.x = 0;\n            this.y = 0;\n            this.curHeight = 0;\n        }\n        const curTex = this.textures[this.textures.length - 1];\n        const pos = new Vec2(this.x, this.y);\n        this.x += img.width;\n        if (img.height > this.curHeight) {\n            this.curHeight = img.height;\n        }\n        if (img instanceof ImageData) {\n            this.c2d.putImageData(img, pos.x, pos.y);\n        } else {\n            this.c2d.drawImage(img, pos.x, pos.y);\n        }\n        curTex.update(this.canvas);\n        return [\n            curTex,\n            new Quad(\n                pos.x / this.canvas.width,\n                pos.y / this.canvas.height,\n                img.width / this.canvas.width,\n                img.height / this.canvas.height,\n            ),\n        ];\n    }\n    free() {\n        for (const tex of this.textures) {\n            tex.free();\n        }\n        for (const tex of this.bigTextures) {\n            tex.free();\n        }\n    }\n}\n", "import { getKaboomContext } from \"@/kaboom\";\nimport { Rect, Vec2 } from \"@/math\";\nimport type {\n    AnchorComp,\n    CircleComp,\n    CircleCompOpt,\n    GameObj,\n    KaboomCtx,\n} from \"@/types\";\n\nfunction getRenderProps(obj: GameObj<any>) {\n    return {\n        color: obj.color,\n        opacity: obj.opacity,\n        anchor: obj.anchor,\n        outline: obj.outline,\n        shader: obj.shader,\n        uniform: obj.uniform,\n    };\n}\n\nexport function circle(\n    this: KaboomCtx,\n    radius: number,\n    opt: CircleCompOpt = {},\n): CircleComp {\n    const k = getKaboomContext(this);\n\n    return {\n        id: \"circle\",\n        radius: radius,\n        draw(this: GameObj<CircleComp>) {\n            k.drawCircle(Object.assign(getRenderProps(this), {\n                radius: this.radius,\n                fill: opt.fill,\n            }));\n        },\n        renderArea(this: GameObj<AnchorComp | CircleComp>) {\n            return new Rect(\n                new Vec2(this.anchor ? 0 : -this.radius),\n                this.radius * 2,\n                this.radius * 2,\n            );\n        },\n        inspect() {\n            return `${Math.ceil(this.radius)}`;\n        },\n    };\n}\n", "import type { FrameBuffer } from \"@/gfx\";\nimport type { GameObj } from \"@/types\";\n\nexport function drawon(c: FrameBuffer) {\n    return {\n        add(this: GameObj) {\n            this.canvas = c;\n        },\n    };\n}\n", "import { getKaboomContext } from \"@/kaboom\";\nimport type { Comp, GameObj, OpacityComp } from \"@/types\";\n\nexport function fadeIn(time: number = 1): Comp {\n    const k = getKaboomContext(this);\n\n    let finalOpacity: number;\n    let t = 0;\n    let done = false;\n\n    return {\n        require: [\"opacity\"],\n        add(this: GameObj<OpacityComp>) {\n            finalOpacity = this.opacity;\n            this.opacity = 0;\n        },\n        update(this: GameObj<OpacityComp>) {\n            if (done) return;\n            t += k.dt();\n            this.opacity = k.map(t, 0, time, 0, finalOpacity);\n\n            if (t >= time) {\n                this.opacity = finalOpacity;\n                done = true;\n            }\n        },\n    };\n}\n", "import type { Mask, MaskComp } from \"@/types\";\n\nexport function mask(m: Mask = \"intersect\"): MaskComp {\n    return {\n        id: \"mask\",\n        mask: m,\n    };\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport type { OpacityComp, TweenController } from \"@/types\";\n\nexport function opacity(a: number): OpacityComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    return {\n        id: \"opacity\",\n        opacity: a ?? 1,\n        inspect() {\n            return `${internal.toFixed(this.opacity, 1)}`;\n        },\n        fadeIn(time = 1, easeFunc = k.easings.linear): TweenController {\n            return k.tween(\n                0,\n                this.opacity,\n                time,\n                (a) => this.opacity = a,\n                easeFunc,\n            );\n        },\n        fadeOut(time = 1, easeFunc = k.easings.linear): TweenController {\n            return k.tween(\n                this.opacity,\n                0,\n                time,\n                (a) => this.opacity = a,\n                easeFunc,\n            );\n        },\n    };\n}\n", "import { Color, rgb } from \"@/math\";\nimport type { OutlineComp } from \"@/types\";\n\nexport function outline(\n    width: number = 1,\n    color: Color = rgb(0, 0, 0),\n): OutlineComp {\n    return {\n        id: \"outline\",\n        outline: {\n            width,\n            color,\n        },\n    };\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Polygon } from \"@/math\";\nimport type { GameObj, PolygonComp, PolygonCompOpt, Vec2 } from \"@/types\";\n\nexport function polygon(pts: Vec2[], opt: PolygonCompOpt = {}): PolygonComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    if (pts.length < 3) {\n        throw new Error(\n            `Polygon's need more than two points, ${pts.length} points provided`,\n        );\n    }\n    return {\n        id: \"polygon\",\n        pts,\n        colors: opt.colors,\n        uv: opt.uv,\n        tex: opt.tex,\n        radius: opt.radius,\n        draw(this: GameObj<PolygonComp>) {\n            k.drawPolygon(Object.assign(internal.getRenderProps(this), {\n                pts: this.pts,\n                colors: this.colors,\n                uv: this.uv,\n                tex: this.tex,\n                radius: this.radius,\n                fill: opt.fill,\n            }));\n        },\n        renderArea(this: GameObj<PolygonComp>) {\n            return new Polygon(this.pts);\n        },\n        inspect() {\n            return this.pts.map(p => `[${p.x},${p.y}]`).join(\",\");\n        },\n    };\n}\n", "import { getKaboomContext } from \"@/kaboom\";\nimport type { Vec2 } from \"@/math\";\nimport type { RaycastResult } from \"@/types\";\n\nexport function raycast(origin: Vec2, direction: Vec2, exclude?: string[]) {\n    const k = getKaboomContext(this);\n    let minHit: RaycastResult;\n\n    const shapes = k.get(\"area\");\n\n    shapes.forEach(s => {\n        if (exclude && exclude.some(tag => s.is(tag))) return;\n        const shape = s.worldArea();\n        const hit = shape.raycast(origin, direction);\n        if (hit) {\n            if (minHit) {\n                if (hit.fraction < minHit.fraction) {\n                    minHit = hit;\n                    minHit.object = s;\n                }\n            } else {\n                minHit = hit;\n                minHit.object = s;\n            }\n        }\n    });\n    return minHit;\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Rect, vec2 } from \"@/math\";\nimport type { GameObj, RectComp, RectCompOpt } from \"@/types\";\n\nexport function rect(w: number, h: number, opt: RectCompOpt = {}): RectComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    return {\n        id: \"rect\",\n        width: w,\n        height: h,\n        radius: opt.radius || 0,\n        draw(this: GameObj<RectComp>) {\n            k.drawRect(Object.assign(internal.getRenderProps(this), {\n                width: this.width,\n                height: this.height,\n                radius: this.radius,\n                fill: opt.fill,\n            }));\n        },\n        renderArea() {\n            return new Rect(vec2(0), this.width, this.height);\n        },\n        inspect() {\n            return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;\n        },\n    };\n}\n", "import type { ShaderComp, Uniform } from \"@/types\";\n\nexport function shader(\n    id: string,\n    uniform?: Uniform | (() => Uniform),\n): ShaderComp {\n    return {\n        id: \"shader\",\n        shader: id,\n        ...(typeof uniform === \"function\"\n            ? {\n                uniform: uniform(),\n                update() {\n                    this.uniform = uniform();\n                },\n            }\n            : {\n                uniform: uniform,\n            }),\n        inspect() {\n            return `shader: ${id}`;\n        },\n    };\n}\n", "// TODO: accept canvas\n\nimport type { Texture } from \"@/gfx\";\nimport { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Quad, quad, Vec2, vec2 } from \"@/math\";\nimport type {\n    Asset,\n    GameObj,\n    SpriteAnimPlayOpt,\n    SpriteComp,\n    SpriteCompOpt,\n    SpriteCurAnim,\n    SpriteData,\n} from \"@/types\";\nimport { Event, EventController } from \"@/utils\";\n\n// TODO: clean\nexport function sprite(\n    src: string | SpriteData | Asset<SpriteData>,\n    opt: SpriteCompOpt = {},\n): SpriteComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(this);\n\n    let spriteData: SpriteData | null = null;\n    let curAnim: SpriteCurAnim | null = null;\n    // 1  - from small index to large index\n    // -1 - reverse\n    let curAnimDir: -1 | 1 | null = null;\n    const spriteLoadedEvent = new Event<[SpriteData]>();\n\n    if (!src) {\n        throw new Error(\n            \"Please pass the resource name or data to sprite()\",\n        );\n    }\n\n    const calcTexScale = (\n        tex: Texture,\n        q: Quad,\n        w?: number,\n        h?: number,\n    ): Vec2 => {\n        const scale = vec2(1, 1);\n        if (w && h) {\n            scale.x = w / (tex.width * q.w);\n            scale.y = h / (tex.height * q.h);\n        } else if (w) {\n            scale.x = w / (tex.width * q.w);\n            scale.y = scale.x;\n        } else if (h) {\n            scale.y = h / (tex.height * q.h);\n            scale.x = scale.y;\n        }\n        return scale;\n    };\n\n    return {\n        id: \"sprite\",\n        // TODO: allow update\n        width: 0,\n        height: 0,\n        frame: opt.frame || 0,\n        quad: opt.quad || new Quad(0, 0, 1, 1),\n        animSpeed: opt.animSpeed ?? 1,\n        flipX: opt.flipX ?? false,\n        flipY: opt.flipY ?? false,\n\n        draw(this: GameObj<SpriteComp>) {\n            if (!spriteData) return;\n\n            const q = spriteData.frames[this.frame ?? 0];\n\n            if (!q) {\n                throw new Error(`Frame not found: ${this.frame ?? 0}`);\n            }\n\n            if (spriteData.slice9) {\n                // TODO: tile\n                // TODO: use scale or width / height, or both?\n                const { left, right, top, bottom } = spriteData.slice9;\n                const tw = spriteData.tex.width * q.w;\n                const th = spriteData.tex.height * q.h;\n                const iw = this.width - left - right;\n                const ih = this.height - top - bottom;\n                const w1 = left / tw;\n                const w3 = right / tw;\n                const w2 = 1 - w1 - w3;\n                const h1 = top / th;\n                const h3 = bottom / th;\n                const h2 = 1 - h1 - h3;\n                const quads = [\n                    // uv\n                    quad(0, 0, w1, h1),\n                    quad(w1, 0, w2, h1),\n                    quad(w1 + w2, 0, w3, h1),\n                    quad(0, h1, w1, h2),\n                    quad(w1, h1, w2, h2),\n                    quad(w1 + w2, h1, w3, h2),\n                    quad(0, h1 + h2, w1, h3),\n                    quad(w1, h1 + h2, w2, h3),\n                    quad(w1 + w2, h1 + h2, w3, h3),\n                    // transform\n                    quad(0, 0, left, top),\n                    quad(left, 0, iw, top),\n                    quad(left + iw, 0, right, top),\n                    quad(0, top, left, ih),\n                    quad(left, top, iw, ih),\n                    quad(left + iw, top, right, ih),\n                    quad(0, top + ih, left, bottom),\n                    quad(left, top + ih, iw, bottom),\n                    quad(left + iw, top + ih, right, bottom),\n                ];\n                for (let i = 0; i < 9; i++) {\n                    const uv = quads[i];\n                    const transform = quads[i + 9];\n                    internal.drawTexture(\n                        Object.assign(internal.getRenderProps(this), {\n                            pos: transform.pos(),\n                            tex: spriteData.tex,\n                            quad: q.scale(uv),\n                            flipX: this.flipX,\n                            flipY: this.flipY,\n                            tiled: opt.tiled,\n                            width: transform.w,\n                            height: transform.h,\n                        }),\n                    );\n                }\n            } else {\n                internal.drawTexture(\n                    Object.assign(internal.getRenderProps(this), {\n                        tex: spriteData.tex,\n                        quad: q.scale(this.quad ?? new Quad(0, 0, 1, 1)),\n                        flipX: this.flipX,\n                        flipY: this.flipY,\n                        tiled: opt.tiled,\n                        width: this.width,\n                        height: this.height,\n                    }),\n                );\n            }\n        },\n\n        add(this: GameObj<SpriteComp>) {\n            const setSpriteData = (spr) => {\n                let q = spr.frames[0].clone();\n\n                if (opt.quad) {\n                    q = q.scale(opt.quad);\n                }\n\n                const scale = calcTexScale(\n                    spr.tex,\n                    q,\n                    opt.width,\n                    opt.height,\n                );\n\n                this.width = spr.tex.width * q.w * scale.x;\n                this.height = spr.tex.height * q.h * scale.y;\n\n                if (opt.anim) {\n                    this.play(opt.anim);\n                }\n\n                spriteData = spr;\n                spriteLoadedEvent.trigger(spriteData);\n            };\n\n            const spr = internal.resolveSprite(src);\n\n            if (spr) {\n                spr.onLoad(setSpriteData);\n            } else {\n                k.onLoad(() => setSpriteData(internal.resolveSprite(src).data));\n            }\n        },\n\n        update(this: GameObj<SpriteComp>) {\n            if (!curAnim) {\n                return;\n            }\n\n            const anim = spriteData.anims[curAnim.name];\n\n            if (typeof anim === \"number\") {\n                this.frame = anim;\n                return;\n            }\n\n            if (anim.speed === 0) {\n                throw new Error(\"Sprite anim speed cannot be 0\");\n            }\n\n            curAnim.timer += k.dt() * this.animSpeed;\n\n            if (curAnim.timer >= (1 / curAnim.speed)) {\n                curAnim.timer = 0;\n                this.frame += curAnimDir;\n\n                if (\n                    this.frame < Math.min(anim.from, anim.to)\n                    || this.frame > Math.max(anim.from, anim.to)\n                ) {\n                    if (curAnim.loop) {\n                        if (curAnim.pingpong) {\n                            this.frame -= curAnimDir;\n                            curAnimDir *= -1;\n                            this.frame += curAnimDir;\n                        } else {\n                            this.frame = anim.from;\n                        }\n                    } else {\n                        if (curAnim.pingpong) {\n                            const isForward = curAnimDir\n                                === Math.sign(anim.to - anim.from);\n                            if (isForward) {\n                                this.frame = anim.to;\n                                curAnimDir *= -1;\n                                this.frame += curAnimDir;\n                            } else {\n                                this.frame = anim.from;\n                                curAnim.onEnd();\n                                this.stop();\n                            }\n                        } else {\n                            this.frame = anim.to;\n                            curAnim.onEnd();\n                            this.stop();\n                        }\n                    }\n                }\n            }\n        },\n\n        play(\n            this: GameObj<SpriteComp>,\n            name: string,\n            opt: SpriteAnimPlayOpt = {},\n        ) {\n            if (!spriteData) {\n                spriteLoadedEvent.add(() => this.play(name, opt));\n                return;\n            }\n\n            const anim = spriteData.anims[name];\n\n            if (anim === undefined) {\n                throw new Error(`Anim not found: ${name}`);\n            }\n\n            if (curAnim) {\n                this.stop();\n            }\n\n            curAnim = typeof anim === \"number\"\n                ? {\n                    name: name,\n                    timer: 0,\n                    loop: false,\n                    pingpong: false,\n                    speed: 0,\n                    onEnd: () => {},\n                }\n                : {\n                    name: name,\n                    timer: 0,\n                    loop: opt.loop ?? anim.loop ?? false,\n                    pingpong: opt.pingpong ?? anim.pingpong ?? false,\n                    speed: opt.speed ?? anim.speed ?? 10,\n                    onEnd: opt.onEnd ?? (() => {}),\n                };\n\n            curAnimDir = typeof anim === \"number\"\n                ? null\n                : anim.from < anim.to\n                ? 1\n                : -1;\n\n            this.frame = typeof anim === \"number\"\n                ? anim\n                : anim.from;\n\n            this.trigger(\"animStart\", name);\n        },\n\n        stop(this: GameObj<SpriteComp>) {\n            if (!curAnim) {\n                return;\n            }\n            const prevAnim = curAnim.name;\n            curAnim = null;\n            this.trigger(\"animEnd\", prevAnim);\n        },\n\n        numFrames() {\n            return spriteData?.frames.length ?? 0;\n        },\n\n        curAnim() {\n            return curAnim?.name;\n        },\n\n        onAnimEnd(\n            this: GameObj<SpriteComp>,\n            action: (name: string) => void,\n        ): EventController {\n            return this.on(\"animEnd\", action);\n        },\n\n        onAnimStart(\n            this: GameObj<SpriteComp>,\n            action: (name: string) => void,\n        ): EventController {\n            return this.on(\"animStart\", action);\n        },\n\n        renderArea() {\n            return new k.Rect(vec2(0), this.width, this.height);\n        },\n\n        inspect() {\n            if (typeof src === \"string\") {\n                return `\"${src}\"`;\n            }\n        },\n    };\n}\n", "import { DEF_TEXT_SIZE } from \"@/constants\";\nimport { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Rect, vec2 } from \"@/math\";\nimport type { GameObj, TextComp, TextCompOpt } from \"@/types\";\n\nexport function text(t: string, opt: TextCompOpt = {}): TextComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    function update(obj: GameObj<TextComp | any>) {\n        const ftext = k.formatText(Object.assign(internal.getRenderProps(obj), {\n            text: obj.text + \"\",\n            size: obj.textSize,\n            font: obj.font,\n            width: opt.width && obj.width,\n            align: obj.align,\n            letterSpacing: obj.letterSpacing,\n            lineSpacing: obj.lineSpacing,\n            // TODO: shouldn't run when object / ancestor is paused\n            transform: obj.textTransform,\n            styles: obj.textStyles,\n        }));\n\n        if (!opt.width) {\n            obj.width = ftext.width / (obj.scale?.x || 1);\n        }\n\n        obj.height = ftext.height / (obj.scale?.y || 1);\n\n        return ftext;\n    }\n\n    const obj = {\n        id: \"text\",\n        set text(nt) {\n            t = nt;\n            // @ts-ignore\n            update(this);\n        },\n        get text() {\n            return t;\n        },\n        textSize: opt.size ?? DEF_TEXT_SIZE,\n        font: opt.font,\n        width: opt.width ?? 0,\n        height: 0,\n        align: opt.align,\n        lineSpacing: opt.lineSpacing,\n        letterSpacing: opt.letterSpacing,\n        textTransform: opt.transform,\n        textStyles: opt.styles,\n\n        add(this: GameObj<TextComp>) {\n            k.onLoad(() => update(this));\n        },\n\n        draw(this: GameObj<TextComp>) {\n            k.drawFormattedText(update(this));\n        },\n\n        renderArea() {\n            return new Rect(vec2(0), this.width, this.height);\n        },\n    };\n\n    // @ts-ignore\n    update(obj);\n\n    return obj;\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Rect, vec2 } from \"@/math\";\nimport type { GameObj, UVQuadComp } from \"@/types\";\n\nexport function uvquad(w: number, h: number): UVQuadComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    return {\n        id: \"rect\",\n        width: w,\n        height: h,\n        draw(this: GameObj<UVQuadComp>) {\n            k.drawUVQuad(Object.assign(internal.getRenderProps(this), {\n                width: this.width,\n                height: this.height,\n            }));\n        },\n        renderArea() {\n            return new Rect(vec2(0), this.width, this.height);\n        },\n        inspect() {\n            return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;\n        },\n    };\n}\n", "import type { Vec2 } from \"@/math\";\nimport type {\n    AgentComp,\n    AgentCompOpt,\n    GameObj,\n    PosComp,\n    TileComp,\n} from \"@/types\";\nimport type { EventController } from \"@/utils\";\n\nexport function agent(opts: AgentCompOpt = {}): AgentComp {\n    let target: Vec2 | null = null;\n    let path: Vec2[] | null = null;\n    let index: number | null = null;\n    let navMapChangedEvent: EventController | null = null;\n    return {\n        id: \"agent\",\n        require: [\"pos\", \"tile\"],\n        agentSpeed: opts.speed ?? 100,\n        allowDiagonals: opts.allowDiagonals ?? true,\n        getDistanceToTarget(this: GameObj<AgentComp | PosComp>) {\n            return target ? this.pos.dist(target) : 0;\n        },\n        getNextLocation() {\n            return path && index ? path[index] : null;\n        },\n        getPath() {\n            return path ? path.slice() : null;\n        },\n        getTarget() {\n            return target;\n        },\n        isNavigationFinished() {\n            return path ? index === null : true;\n        },\n        isTargetReachable() {\n            return path !== null;\n        },\n        isTargetReached(this: GameObj<AgentComp | PosComp>) {\n            return target ? this.pos.eq(target) : true;\n        },\n        setTarget(this: GameObj<AgentComp | TileComp | PosComp>, p: Vec2) {\n            target = p;\n            path = this.getLevel().getPath(this.pos, target, {\n                allowDiagonals: this.allowDiagonals,\n            });\n            index = path ? 0 : null;\n            if (path) {\n                if (!navMapChangedEvent) {\n                    navMapChangedEvent = this.getLevel()\n                        .onNavigationMapChanged(() => {\n                            if (path && index !== null) {\n                                path = this.getLevel().getPath(\n                                    this.pos,\n                                    target,\n                                    {\n                                        allowDiagonals: this.allowDiagonals,\n                                    },\n                                );\n                                index = path ? 0 : null;\n                                if (path) {\n                                    this.trigger(\n                                        \"navigation-next\",\n                                        this,\n                                        path[index],\n                                    );\n                                } else {\n                                    this.trigger(\"navigation-ended\", this);\n                                }\n                            }\n                        });\n                    this.onDestroy(() => navMapChangedEvent.cancel());\n                }\n                this.trigger(\"navigation-started\", this);\n                this.trigger(\"navigation-next\", this, path[index]);\n            } else {\n                this.trigger(\"navigation-ended\", this);\n            }\n        },\n        update(this: GameObj<AgentComp | PosComp>) {\n            if (path && index !== null) {\n                if (this.pos.sdist(path[index]) < 2) {\n                    if (index === path.length - 1) {\n                        this.pos = target.clone();\n                        index = null;\n                        this.trigger(\"navigation-ended\", this);\n                        this.trigger(\"target-reached\", this);\n                        return;\n                    } else {\n                        index++;\n                        this.trigger(\"navigation-next\", this, path[index]);\n                    }\n                }\n                this.moveTo(path[index], this.agentSpeed);\n            }\n        },\n        onNavigationStarted(this: GameObj<AgentComp>, cb: () => void) {\n            return this.on(\"navigation-started\", cb);\n        },\n        onNavigationNext(this: GameObj<AgentComp>, cb: () => void) {\n            return this.on(\"navigation-next\", cb);\n        },\n        onNavigationEnded(this: GameObj<AgentComp>, cb: () => void) {\n            return this.on(\"navigation-ended\", cb);\n        },\n        onTargetReached(this: GameObj<AgentComp>, cb: () => void) {\n            return this.on(\"target-reached\", cb);\n        },\n        inspect() {\n            return JSON.stringify({\n                target: JSON.stringify(target),\n                path: JSON.stringify(path),\n            });\n        },\n    };\n}\n", "/**\n * Initialize kaboom context. The starting point of all kaboom games.\n *\n * @example\n * ```js\n * // Start kaboom with default options (will create a fullscreen canvas under <body>)\n * kaboom()\n *\n * // Init with some options (check out #KaboomOpt for full options list)\n * kaboom({\n *     width: 320,\n *     height: 240,\n *     font: \"sans-serif\",\n *     canvas: document.querySelector(\"#mycanvas\"),\n *     background: [ 0, 0, 255, ],\n * })\n *\n * // All kaboom functions are imported to global after calling kaboom()\n * add()\n * onUpdate()\n * onKeyPress()\n * vec2()\n *\n * // If you want to prevent kaboom from importing all functions to global and use a context handle for all kaboom functions\n * const k = kaboom({ global: false })\n *\n * k.add(...)\n * k.onUpdate(...)\n * k.onKeyPress(...)\n * k.vec2(...)\n * ```\n *\n * @group Start\n */\ndeclare function kaboom<T extends PluginList<unknown> = [undefined]>(\n    options?: KaboomOpt<T>,\n): T extends [undefined] ? KaboomCtx : KaboomCtx & MergePlugins<T>;\n\nexport type InternalCtx = {\n    kaboomCtx: KaboomCtx;\n    app: any;\n    game: any;\n    isFixed: (obj: GameObj) => boolean;\n    toFixed: (n: number, f: number) => number;\n    getViewportScale: () => number;\n    getRenderProps: (obj: GameObj) => {\n        color: Color;\n        opacity: number;\n        anchor: Anchor;\n        outline: Outline;\n        shader: Shader;\n        uniform: Uniform;\n    };\n    resolveSprite: (\n        src: DrawSpriteOpt[\"sprite\"],\n    ) => Asset<SpriteData> | null;\n    drawTexture: (opt: DrawTextureOpt) => void;\n    calcTransform: (obj: GameObj) => Mat4;\n};\n\n/**\n * Context handle that contains every kaboom function.\n *\n * @group Start\n */\nexport interface KaboomCtx {\n    /**\n     * The internal context object.\n     *\n     * @private\n     */\n    _k: InternalCtx;\n    /**\n\t * Assemble a game object from a list of components, and add it to the game\n\t *\n\t * @returns The added game object that contains all properties and methods each component offers.\n\t *\n\t * @example\n\t * ```js\n\t * const player = add([\n\t *     // List of components, each offers a set of functionalities\n\t *     sprite(\"mark\"),\n\t *     pos(100, 200),\n\t *     area(),\n\t *     body(),\n\t *     health(8),\n\t *     // Plain strings are tags, a quicker way to let us define behaviors for a group\n\t *     \"player\",\n\t *     \"friendly\",\n\t *     // Components are just plain objects, you can pass an object literal as a component.\n\t *     {\n\t *         dir: LEFT,\n\t *         dead: false,\n\t *         speed: 240,\n\t *     },\n\t * ])\n\t *\n\t * // .jump is provided by body()\n\t * player.jump()\n\n\t * // .moveTo is provided by pos()\n\t * player.moveTo(300, 200)\n\t *\n\t * // .onUpdate() is on every game object, it registers an event that runs every frame\n\t * player.onUpdate(() => {\n\t *     // .move() is provided by pos()\n\t *     player.move(player.dir.scale(player.speed))\n\t * })\n\t *\n\t * // .onCollide is provided by area()\n\t * player.onCollide(\"tree\", () => {\n\t *     destroy(player)\n\t * })\n\t * ```\n     *\n     * @group Game Obj\n\t */\n    add<T>(comps?: CompList<T> | GameObj<T>): GameObj<T>;\n    /**\n\t * Create a game object like add(), but not adding to the scene.\n\t *\n\t * @since v3000.1\n\t *\n\t * @example\n\t * ```js\n\t * const label = make([\n\t *     text(\"oh hi\"),\n\t * ])\n\n\t * add([\n\t *     rect(label.width, label.height),\n\t *     color(0, 0, 255),\n\t *     children(label),\n\t * ])\n\t * ```\n     *\n     * @group Game Obj\n\t */\n    make<T>(comps?: CompList<T>): GameObj<T>;\n    /**\n     * Remove and re-add the game obj, without triggering add / destroy events.\n     * @example\n     * ```js\n     * // Common way to use this is to have one sprite overlap another sprite, and use readd() to have the bottom sprite on top of the other.\n     *\n     * // Create two sprites.\n     * const greenBean = add([\n     * sprite(\"bean\"),\n     * pos(200,140),\n     * color(255, 255, 255),\n     * area(),\n     * ])\n     *\n     * // This bean will overlap the green bean.\n     * const purpleBean = add([\n     * sprite(\"bean\"),\n     * pos(230,140),\n     * color(255, 0, 255),\n     * area(),\n     * ])\n     *\n     * // Example 1: simply call readd() on the target you want on top.\n     * readd(greenBean)\n     *\n     * // Example 2: using onClick() or other functions with readd().\n     * // If you comment out the first example, and use this readd() with a function like onClick(), you\n     * can keep switching which sprite is above the other ( click on edge of face ).\n     *\n     * purpleBean.onClick(() => {\n     * \t\treadd(greenBean)\n     * })\n     *\n     * greenBean.onClick(() => {\n     * \t\treadd(purpleBean)\n     * })\n     * ```\n     *\n     * @group Game Obj\n     */\n    readd(obj: GameObj): void;\n    /**\n     * Get a list of all game objs with certain tag.\n     *\n     * @example\n     * ```js\n     * // get a list of all game objs with tag \"bomb\"\n     * const allBombs = get(\"bomb\")\n     *\n     * // To get all objects use \"*\"\n     * const allObjs = get(\"*\")\n     *\n     * // Recursively get all children and descendents\n     * const allObjs = get(\"*\", { recursive: true })\n     * ```\n     *\n     * @group Game Obj\n     */\n    get(tag: Tag | Tag[], opts?: GetOpt): GameObj[];\n    /**\n     * Remove the game obj.\n     *\n     * @example\n     * ```js\n     * // every time bean collides with anything with tag \"fruit\", remove it\n     * bean.onCollide(\"fruit\", (fruit) => {\n     *     destroy(fruit)\n     * })\n     * ```\n     *\n     * @group Game Obj\n     */\n    destroy(obj: GameObj): void;\n    /**\n     * Remove all game objs with certain tag.\n     *\n     * @example\n     * ```js\n     * // destroy all objects with tag \"bomb\" when you click one\n     * onClick(\"bomb\", () => {\n     *     destroyAll(\"bomb\")\n     * })\n     * ```\n     *\n     * @group Game Obj\n     */\n    destroyAll(tag: Tag): void;\n    /**\n     * Position\n     *\n     * @example\n     * ```js\n     * // This game object will draw a \"bean\" sprite at (100, 200)\n     * add([\n     *     pos(100, 200),\n     *     sprite(\"bean\"),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    pos(x: number, y: number): PosComp;\n    pos(xy: number): PosComp;\n    pos(p: Vec2): PosComp;\n    pos(): PosComp;\n    /**\n     * Scale.\n     *\n     * @group Components\n     */\n    scale(x: number, y: number): ScaleComp;\n    scale(xy: number): ScaleComp;\n    scale(s: Vec2): ScaleComp;\n    /**\n     * Scale the game obj.\n     *\n     * @example\n     * ```js\n     * // scale uniformly with one value\n     * add([\n     *     sprite(\"bean\"),\n     * \t   scale(3),\n     * ])\n     * // scale with x & y values. In this case, scales more horizontally.\n     * add([\n     *     sprite(\"bean\"),\n     * \t   scale(3, 1),\n     * ])\n     *  // scale with vec2(x,y).\n     * bean.scale = vec2(2,4)\n     *\n     * ```\n     *\n     * @group Components\n     */\n    scale(): ScaleComp;\n    /**\n     * Rotation (in degrees).\n     *\n     * @group Components\n     */\n    rotate(a: number): RotateComp;\n    /**\n     * Sets color (rgb 0-255).\n     *\n     * @example\n     * ```js\n     * // blue frog\n     * add([\n     *     sprite(\"bean\"),\n     *     color(0, 0, 255)\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    color(r: number, g: number, b: number): ColorComp;\n    color(c: Color): ColorComp;\n    color(rgb: [number, number, number]): ColorComp;\n    color(c: string): ColorComp;\n    color(): ColorComp;\n    /**\n     * Sets opacity (0.0 - 1.0).\n     *\n     * @group Components\n     */\n    opacity(o?: number): OpacityComp;\n    /**\n     * Render as a sprite.\n     *\n     * @example\n     * ```js\n     * // minimal setup\n     * add([\n     *     sprite(\"bean\"),\n     * ])\n     *\n     * // with options\n     * const bean = add([\n     *     sprite(\"bean\", {\n     *         // start with animation \"idle\"\n     *         anim: \"idle\",\n     *     }),\n     * ])\n     *\n     * // play / stop an anim\n     * bean.play(\"jump\")\n     * bean.stop()\n     *\n     * // manually setting a frame\n     * bean.frame = 3\n     * ```\n     *\n     * @group Components\n     */\n    sprite(spr: string | SpriteData, options?: SpriteCompOpt): SpriteComp;\n    /**\n     * Render as text.\n     *\n     * @example\n     * ```js\n     * // a simple score counter\n     * const score = add([\n     *     text(\"Score: 0\"),\n     *     pos(24, 24),\n     *     { value: 0 },\n     * ])\n     *\n     * player.onCollide(\"coin\", () => {\n     *     score.value += 1\n     *     score.text = \"Score:\" + score.value\n     * })\n     *\n     * // with options\n     * add([\n     *     pos(24, 24),\n     *     text(\"ohhi\", {\n     *         size: 48, // 48 pixels tall\n     *         width: 320, // it'll wrap to next line when width exceeds this value\n     *         font: \"sans-serif\", // specify any font you loaded or browser built-in\n     *     }),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    text(txt: string, options?: TextCompOpt): TextComp;\n    /**\n     * Render as a polygon.\n     *\n     * @since v3001.0\n     *\n     * @example\n     * ```js\n     * // Make a square the hard way\n     * add([\n     *     pos(80, 120),\n     *     polygon([vec2(0,0), vec2(50,0), vec2(50,50), vec2(0,50)]),\n     *     outline(4),\n     *     area(),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    polygon(pts: Vec2[], opt?: PolygonCompOpt): PolygonComp;\n    /**\n     * Render as a rectangle.\n     *\n     * @example\n     * ```js\n     * const obstacle = add([\n     *     pos(80, 120),\n     *     rect(20, 40),\n     *     outline(4),\n     *     area(),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    rect(w: number, h: number, opt?: RectCompOpt): RectComp;\n    /**\n     * Render as a circle.\n     *\n     * @example\n     * ```js\n     * add([\n     *     pos(80, 120),\n     *     circle(16),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    circle(radius: number): CircleComp;\n    /**\n     * Render as a UV quad.\n     *\n     * @example\n     * ```js\n     * add([\n     *     uvquad(width(), height()),\n     *     shader(\"spiral\"),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    uvquad(w: number, h: number): UVQuadComp;\n    /**\n     * Generates collider area from shape and enables collision detection.\n     *\n     * @example\n     * ```js\n     * // Automatically generate area information from the shape of render\n     * const player = add([\n     *     sprite(\"bean\"),\n     *     area(),\n     * ])\n     *\n     * // Die if player collides with another game obj with tag \"tree\"\n     * player.onCollide(\"tree\", () => {\n     *     destroy(player)\n     *     go(\"lose\")\n     * })\n     *\n     * // Check for collision manually every frame instead of registering an event\n     * player.onUpdate(() => {\n     *     if (player.isColliding(bomb)) {\n     *         score += 1\n     *     }\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    area(): AreaComp;\n    /**\n     * Define collider area and enables collision detection.\n     *\n     * @example\n     * ```js\n     * add([\n     *     sprite(\"flower\"),\n     *     // Scale to 0.6 of the generated area\n     *     area({ scale: 0.6 }),\n     *     // If we want the area scale to be calculated from the center\n     *     anchor(\"center\"),\n     * ])\n     *\n     * add([\n     *     sprite(\"bean\"),\n     *     // Define area with custom shape\n     *     area({ shape: new Polygon([vec2(0), vec2(100), vec2(-100, 100)]) }),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    area(options: AreaCompOpt): AreaComp;\n    /**\n     * Anchor point for render (default \"topleft\").\n     *\n     * @example\n     * ```js\n     * // set anchor to \"center\" so it'll rotate from center\n     * add([\n     *     rect(40, 10),\n     *     rotate(45),\n     *     anchor(\"center\"),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    anchor(o: Anchor | Vec2): AnchorComp;\n    /**\n     * Determines the draw order for objects on the same layer. Object will be drawn on top if z value is bigger.\n     *\n     * @group Components\n     */\n    z(z: number): ZComp;\n    /**\n     * Give obj an outline.\n     *\n     * @group Components\n     */\n    outline(width?: number, color?: Color): OutlineComp;\n    /**\n     * Physical body that responds to gravity. Requires \"area\" and \"pos\" comp. This also makes the object \"solid\".\n     *\n     * @example\n     * ```js\n     * // bean jumpy\n     * const bean = add([\n     *     sprite(\"bean\"),\n     *     // body() requires \"pos\" and \"area\" component\n     *     pos(),\n     *     area(),\n     *     body(),\n     * ])\n     *\n     * // when bean is grounded, press space to jump\n     * // check out #BodyComp for more methods\n     * onKeyPress(\"space\", () => {\n     *     if (bean.isGrounded()) {\n     *         bean.jump()\n     *     }\n     * })\n     *\n     * // run something when bean falls and hits a ground\n     * bean.onGround(() => {\n     *     debug.log(\"oh no!\")\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    body(options?: BodyCompOpt): BodyComp;\n    /**\n     * Enables double jump. Requires \"body\" component.\n     *\n     * @since v3000.0\n     * @group Components\n     */\n    doubleJump(numJumps?: number): DoubleJumpComp;\n    /**\n     * Move towards a direction infinitely, and destroys when it leaves game view. Requires \"pos\" component.\n     *\n     * @example\n     * ```js\n     * // enemy throwing feces at player\n     * const projectile = add([\n     *     sprite(\"feces\"),\n     *     pos(enemy.pos),\n     *     area(),\n     *     move(player.pos.angle(enemy.pos), 1200),\n     *     offscreen({ destroy: true }),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    move(direction: number | Vec2, speed: number): EmptyComp;\n    /**\n     * Control the behavior of object when it goes out of view.\n     *\n     * @since v2000.2\n     *\n     * @example\n     * ```js\n     * add([\n     *     pos(player.pos),\n     *     sprite(\"bullet\"),\n     *     offscreen({ destroy: true }),\n     *     \"projectile\",\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    offscreen(opt?: OffScreenCompOpt): OffScreenComp;\n    /**\n     * Follow another game obj's position.\n     *\n     * @group Components\n     */\n    follow(obj: GameObj | null, offset?: Vec2): FollowComp;\n    /**\n     * Custom shader.\n     *\n     * @group Components\n     */\n    shader(id: string, uniform?: Uniform | (() => Uniform)): ShaderComp;\n    /**\n     * Enable timer related functions like wait(), loop(), tween() on the game object.\n     *\n     * @example\n     * ```js\n     * const obj = add([\n     *     timer(),\n     * ])\n     *\n     * obj.wait(2, () => { ... })\n     * obj.loop(0.5, () => { ... })\n     * obj.tween(obj.pos, mousePos(), 0.5, (p) => obj.pos = p, easings.easeOutElastic)\n     * ```\n     *\n     * @group Components\n     */\n    timer(): TimerComp;\n    /**\n     * Make object unaffected by camera or parent object transforms, and render at last.\n     *\n     * @example\n     * ```js\n     * // this will be be fixed on top left and not affected by camera\n     * const score = add([\n     *     text(0),\n     *     pos(12, 12),\n     *     fixed(),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    fixed(): FixedComp;\n    /**\n     * Don't get destroyed on scene switch.\n     *\n     * @example\n     * ```js\n     * player.onCollide(\"bomb\", () => {\n     *     // spawn an explosion and switch scene, but don't destroy the explosion game obj on scene switch\n     *     add([\n     *         sprite(\"explosion\", { anim: \"burst\", }),\n     *         stay(),\n     *         lifespan(1),\n     *     ])\n     *     go(\"lose\", score)\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    stay(scenesToStay?: string[]): StayComp;\n    /**\n     * Handles health related logic and events.\n     *\n     * @example\n     * ```js\n     * const player = add([\n     *     health(3),\n     * ])\n     *\n     * player.onCollide(\"bad\", (bad) => {\n     *     player.hurt(1)\n     *     bad.hurt(1)\n     * })\n     *\n     * player.onCollide(\"apple\", () => {\n     *     player.heal(1)\n     * })\n     *\n     * player.on(\"hurt\", () => {\n     *     play(\"ouch\")\n     * })\n     *\n     * // triggers when hp reaches 0\n     * player.on(\"death\", () => {\n     *     destroy(player)\n     *     go(\"lose\")\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    health(hp: number, maxHP?: number): HealthComp;\n    /**\n     * Destroy the game obj after certain amount of time\n     *\n     * @example\n     * ```js\n     * // spawn an explosion, destroy after 1 seconds, start fading away after 0.5 second\n     * add([\n     *     sprite(\"explosion\", { anim: \"burst\", }),\n     *     lifespan(1, { fade: 0.5 }),\n     * ])\n     * ```\n     *\n     * @group Components\n     */\n    lifespan(time: number, options?: LifespanCompOpt): EmptyComp;\n    /**\n     * Finite state machine.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * const enemy = add([\n     *     pos(80, 100),\n     *     sprite(\"robot\"),\n     *     state(\"idle\", [\"idle\", \"attack\", \"move\"]),\n     * ])\n     *\n     * // this callback will run once when enters \"attack\" state\n     * enemy.onStateEnter(\"attack\", () => {\n     *     // enter \"idle\" state when the attack animation ends\n     *     enemy.play(\"attackAnim\", {\n     *         // any additional arguments will be passed into the onStateEnter() callback\n     *         onEnd: () => enemy.enterState(\"idle\", rand(1, 3)),\n     *     })\n     *     checkHit(enemy, player)\n     * })\n     *\n     * // this will run once when enters \"idle\" state\n     * enemy.onStateEnter(\"idle\", (time) => {\n     *     enemy.play(\"idleAnim\")\n     *     wait(time, () => enemy.enterState(\"move\"))\n     * })\n     *\n     * // this will run every frame when current state is \"move\"\n     * enemy.onStateUpdate(\"move\", () => {\n     *     enemy.follow(player)\n     *     if (enemy.pos.dist(player.pos) < 16) {\n     *         enemy.enterState(\"attack\")\n     *     }\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    state(\n        initialState: string,\n        stateList?: string[],\n    ): StateComp;\n    /**\n     * state() with pre-defined transitions.\n     *\n     * @since v2000.2\n     *\n     * @example\n     * ```js\n     * const enemy = add([\n     *     pos(80, 100),\n     *     sprite(\"robot\"),\n     *     state(\"idle\", [\"idle\", \"attack\", \"move\"], {\n     *         \"idle\": \"attack\",\n     *         \"attack\": \"move\",\n     *         \"move\": [ \"idle\", \"attack\" ],\n     *     }),\n     * ])\n     *\n     * // this callback will only run once when enter \"attack\" state from \"idle\"\n     * enemy.onStateTransition(\"idle\", \"attack\", () => {\n     *     checkHit(enemy, player)\n     * })\n     * ```\n     *\n     * @group Components\n     */\n    state(\n        initialState: string,\n        stateList: string[],\n        transitions: Record<string, string | string[]>,\n    ): StateComp;\n    /**\n     * Fade object in.\n     *\n     * Uses opacity for finding what to fade into and to set opacity during fade animation.\n     *\n     * @since v3000.0\n     * @group Components\n     * @deprecated since v3001.0\n     */\n    fadeIn(time: number): Comp;\n    /**\n     * Mask all children object render.\n     *\n     * @since v3001.0\n     * @group Components\n     */\n    mask(maskType?: Mask): MaskComp;\n    drawon(canvas: FrameBuffer): Comp;\n    /**\n     * A tile on a tile map.\n     *\n     * @since v3000.0\n     * @group Components\n     */\n    tile(opt: TileCompOpt): TileComp;\n    /**\n     * An agent which can finds it way on a tilemap.\n     *\n     * @since v3000.0\n     * @group Components\n     */\n    agent(opt?: AgentCompOpt): AgentComp;\n    /**\n     * @group Components\n     */\n    raycast(origin: Vec2, direction: Vec2, exclude?: string[]): RaycastResult;\n    /**\n     * Register an event on all game objs with certain tag.\n     *\n     * @example\n     * ```js\n     * // a custom event defined by body() comp\n     * // every time an obj with tag \"bomb\" hits the floor, destroy it and addKaboom()\n     * on(\"ground\", \"bomb\", (bomb) => {\n     *     destroy(bomb)\n     *     addKaboom(bomb.pos)\n     * })\n     *\n     * // a custom event can be defined manually\n     * // by passing a name and a callback function\n     * on(\"talk\", (message, posX, posY) => {\n     *     add([\n     *      text(message),\n     *      pos(posX, posY - 100)\n     *     ])\n     * })\n     * onKeyPress(\"space\", () => {\n     *    // the trigger method on game objs can be used to trigger a custom event\n     *    npc.trigger(\"talk\", \"Hello World!\", npc.pos.x, npc.pos.y)\n     * })\n     *\n     * ```\n     * @group Events\n     */\n    on(\n        event: string,\n        tag: Tag,\n        action: (obj: GameObj, ...args: any) => void,\n    ): EventController;\n    /**\n     * Register an event that runs every frame (~60 times per second) for all game objs with certain tag.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // move every \"tree\" 120 pixels per second to the left, destroy it when it leaves screen\n     * // there'll be nothing to run if there's no \"tree\" obj in the scene\n     * onUpdate(\"tree\", (tree) => {\n     *     tree.move(-120, 0)\n     *     if (tree.pos.x < 0) {\n     *         destroy(tree)\n     *     }\n     * })\n     * ```\n     * @group Events\n     */\n    onUpdate(tag: Tag, action: (obj: GameObj) => void): EventController;\n    /**\n     * Register an event that runs every frame (~60 times per second).\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // This will run every frame\n     * onUpdate(() => {\n     *     debug.log(\"ohhi\")\n     * })\n     * ```\n     * @group Events\n     */\n    onUpdate(action: () => void): EventController;\n    /**\n     * Register an event that runs every frame (~60 times per second) for all game objs with certain tag (this is the same as onUpdate but all draw events are run after update events, drawXXX() functions only work in this phase).\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onDraw(tag: Tag, action: (obj: GameObj) => void): EventController;\n    /**\n     * Register an event that runs every frame (~60 times per second) (this is the same as onUpdate but all draw events are run after update events, drawXXX() functions only work in this phase).\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * onDraw(() => {\n     *     drawLine({\n     *         p1: vec2(0),\n     *         p2: mousePos(),\n     *         color: rgb(0, 0, 255),\n     *     })\n     * })\n     * ```\n     * @group Events\n     */\n    onDraw(action: () => void): EventController;\n    /**\n     * @group Events\n     */\n    onAdd(tag: Tag, action: (obj: GameObj) => void): EventController;\n    /**\n     * @group Events\n     */\n    onAdd(action: (obj: GameObj) => void): EventController;\n    /**\n     * @group Events\n     */\n    onDestroy(tag: Tag, action: (obj: GameObj) => void): EventController;\n    /**\n     * @group Events\n     */\n    onDestroy(action: (obj: GameObj) => void): EventController;\n    /**\n     * Register an event that runs when all assets finished loading.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * const bean = add([\n     *     sprite(\"bean\"),\n     * ])\n     *\n     * // certain assets related data are only available when the game finishes loading\n     * onLoad(() => {\n     *     debug.log(bean.width)\n     * })\n     * ```\n     * @group Events\n     */\n    onLoad(action: () => void): void;\n    /**\n     * Register an event that runs every frame when assets are initially loading. Can be used to draw a custom loading screen.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onLoading(action: (progress: number) => void): void;\n    /**\n     * Register a custom error handler. Can be used to draw a custom error screen.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onError(action: (err: Error) => void): void;\n    /**\n     * Register an event that runs when the canvas resizes.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onResize(action: () => void): void;\n    /**\n     * Cleanup function to run when quit() is called.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onCleanup(action: () => void): void;\n    /**\n     * Register an event that runs when a gamepad is connected.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadConnect(action: (gamepad: KGamePad) => void): void;\n    /**\n     * Register an event that runs when a gamepad is disconnected.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadDisconnect(action: (gamepad: KGamePad) => void): void;\n    /**\n     * Register an event that runs once when 2 game objs with certain tags collides (required to have area() component).\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * onCollide(\"sun\", \"earth\", () => {\n     *     addExplosion()\n     * })\n     * ```\n     * @group Events\n     */\n    onCollide(\n        t1: Tag,\n        t2: Tag,\n        action: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController;\n    /**\n     * Register an event that runs every frame when 2 game objs with certain tags collides (required to have area() component).\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * onCollideUpdate(\"sun\", \"earth\", () => {\n     *     runWorldEndTimer()\n     * })\n     * ```\n     *\n     * @group Events\n     */\n    onCollideUpdate(\n        t1: Tag,\n        t2: Tag,\n        action: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController;\n    /**\n     * Register an event that runs once frame when 2 game objs with certain tags stops colliding (required to have area() component).\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * onCollideEnd(\"bean\", \"earth\", () => {\n     *     worldEnd()\n     * })\n     * ```\n     *\n     * @group Events\n     */\n    onCollideEnd(\n        t1: Tag,\n        t2: Tag,\n        action: (a: GameObj, b: GameObj, col?: Collision) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when game objs with certain tags are clicked (required to have the area() component).\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // click on any \"chest\" to open\n     * onClick(\"chest\", (chest) => chest.open())\n     * ```\n     *\n     * @group Events\n     */\n    onClick(tag: Tag, action: (a: GameObj) => void): EventController;\n    /**\n     * Register an event that runs when users clicks.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // click on anywhere to go to \"game\" scene\n     * onClick(() => go(\"game\"))\n     * ```\n     *\n     * @group Events\n     */\n    onClick(action: () => void): EventController;\n    /**\n     * Register an event that runs once when game objs with certain tags are hovered (required to have area() component).\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onHover(tag: Tag, action: (a: GameObj) => void): EventController;\n    /**\n     * Register an event that runs every frame when game objs with certain tags are hovered (required to have area() component).\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onHoverUpdate(tag: Tag, onHover: (a: GameObj) => void): EventController;\n    /**\n     * Register an event that runs once when game objs with certain tags are unhovered (required to have area() component).\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onHoverEnd(tag: Tag, action: (a: GameObj) => void): EventController;\n    /**\n     * Register an event that runs every frame when a key is held down.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // move left by SPEED pixels per frame every frame when left arrow key is being held down\n     * onKeyDown(\"left\", () => {\n     *     bean.move(-SPEED, 0)\n     * })\n     * ```\n     * @group Events\n     */\n    onKeyDown(key: Key, action: (key: Key) => void): EventController;\n    /**\n     * Register an event that runs every frame when any key is held down.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onKeyDown(action: (key: Key) => void): EventController;\n    /**\n     * Register an event that runs when user presses certain key.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // .jump() once when \"space\" is just being pressed\n     * onKeyPress(\"space\", () => {\n     *     bean.jump()\n     * })\n     * ```\n     * @group Events\n     */\n    onKeyPress(key: Key, action: (key: Key) => void): EventController;\n    /**\n     * Register an event that runs when user presses any key.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // Call restart() when player presses any key\n     * onKeyPress(() => {\n     *     restart()\n     * })\n     * ```\n     * @group Events\n     */\n    onKeyPress(action: (key: Key) => void): EventController;\n    /**\n     * Register an event that runs when user presses certain key (also fires repeatedly when they key is being held down).\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // delete last character when \"backspace\" is being pressed and held\n     * onKeyPressRepeat(\"backspace\", () => {\n     *     input.text = input.text.substring(0, input.text.length - 1)\n     * })\n     * ```\n     * @group Events\n     */\n    onKeyPressRepeat(k: Key, action: (k: Key) => void): EventController;\n    onKeyPressRepeat(action: (k: Key) => void): EventController;\n    /**\n     * Register an event that runs when user releases certain key.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onKeyRelease(k: Key, action: (k: Key) => void): EventController;\n    onKeyRelease(action: (k: Key) => void): EventController;\n    /**\n     * Register an event that runs when user inputs text.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // type into input\n     * onCharInput((ch) => {\n     *     input.text += ch\n     * })\n     * ```\n     * @group Events\n     */\n    onCharInput(action: (ch: string) => void): EventController;\n    /**\n     * Register an event that runs every frame when a mouse button is being held down.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onMouseDown(action: (m: MouseButton) => void): EventController;\n    onMouseDown(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when user clicks mouse.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onMousePress(action: (m: MouseButton) => void): EventController;\n    onMousePress(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when user releases mouse.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onMouseRelease(action: (m: MouseButton) => void): EventController;\n    onMouseRelease(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs whenever user move the mouse.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onMouseMove(action: (pos: Vec2, delta: Vec2) => void): EventController;\n    /**\n     * Register an event that runs when a touch starts.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onTouchStart(action: (pos: Vec2, t: Touch) => void): EventController;\n    /**\n     * Register an event that runs whenever touch moves.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onTouchMove(action: (pos: Vec2, t: Touch) => void): EventController;\n    /**\n     * Register an event that runs when a touch ends.\n     *\n     * @since v2000.1\n     * @group Events\n     */\n    onTouchEnd(action: (pos: Vec2, t: Touch) => void): EventController;\n    /**\n     * Register an event that runs when mouse wheel scrolled.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onScroll(action: (delta: Vec2) => void): EventController;\n    /**\n     * Register an event that runs when tab is hidden.\n     *\n     * @since v3001.0\n     * @group Events\n     */\n    onHide(action: () => void): EventController;\n    /**\n     * Register an event that runs when tab is shown.\n     *\n     * @since v3001.0\n     * @group Events\n     */\n    onShow(action: () => void): EventController;\n    /**\n     * Register an event that runs every frame when certain gamepad button is held down.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonDown(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs every frame when any gamepad button is held down.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonDown(\n        action: (btn: GamepadButton) => GamepadButton,\n    ): EventController;\n    /**\n     * Register an event that runs when user presses certain gamepad button.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonPress(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when user presses any gamepad button.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonPress(\n        action: (btn: GamepadButton) => GamepadButton,\n    ): EventController;\n    /**\n     * Register an event that runs when user releases any gamepad button.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonRelease(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when user releases certain gamepad button.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadButtonRelease(\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when the gamepad axis exists.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onGamepadStick(\n        stick: GamepadStick,\n        action: (value: Vec2) => void,\n    ): EventController;\n    /**\n     * Register an event that runs when current scene ends.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    onSceneLeave(action: (newScene?: string) => void): EventController;\n    /**\n    /**\n     * Gets the name of the current scene.\n     *\n     * @since v3001.0\n     * @group Scene\n     */\n    getSceneName(): string;\n    /**\n     * Sets the root for all subsequent resource urls.\n     *\n     * @example\n     * ```js\n     * loadRoot(\"https://myassets.com/\")\n     * loadSprite(\"bean\", \"sprites/bean.png\") // will resolve to \"https://myassets.com/sprites/bean.png\"\n     * ```\n     *\n     * @group Assets\n     */\n    loadRoot(path?: string): string;\n    /**\n     * Load a sprite into asset manager, with name and resource url and optional config.\n     *\n     * @example\n     * ```js\n     * // due to browser policies you'll need a static file server to load local files\n     * loadSprite(\"bean\", \"bean.png\")\n     * loadSprite(\"apple\", \"https://kaboomjs.com/sprites/apple.png\")\n     *\n     * // slice a spritesheet and add anims manually\n     * loadSprite(\"bean\", \"bean.png\", {\n     *     sliceX: 4,\n     *     sliceY: 1,\n     *     anims: {\n     *         run: {\n     *             from: 0,\n     *             to: 3,\n     *         },\n     *         jump: {\n     *             from: 3,\n     *             to: 3,\n     *         },\n     *     },\n     * })\n     * ```\n     *\n     * @group Assets\n     */\n    loadSprite(\n        name: string | null,\n        src: LoadSpriteSrc | LoadSpriteSrc[],\n        options?: LoadSpriteOpt,\n    ): Asset<SpriteData>;\n    /**\n     * Load sprites from a sprite atlas.\n     *\n     * @example\n     * ```js\n     * // See #SpriteAtlasData type for format spec\n     * loadSpriteAtlas(\"sprites/dungeon.png\", {\n     *     \"hero\": {\n     *         x: 128,\n     *         y: 68,\n     *         width: 144,\n     *         height: 28,\n     *         sliceX: 9,\n     *         anims: {\n     *             idle: { from: 0, to: 3 },\n     *             run: { from: 4, to: 7 },\n     *             hit: 8,\n     *         },\n     *     },\n     * })\n     *\n     * const player = add([\n     *     sprite(\"hero\"),\n     * ])\n     *\n     * player.play(\"run\")\n     * ```\n     *\n     * @group Assets\n     */\n    loadSpriteAtlas(\n        src: LoadSpriteSrc,\n        data: SpriteAtlasData,\n    ): Asset<Record<string, SpriteData>>;\n    /**\n     * Load sprites from a sprite atlas with URL.\n     *\n     * @example\n     * ```js\n     * // Load from json file, see #SpriteAtlasData type for format spec\n     * loadSpriteAtlas(\"sprites/dungeon.png\", \"sprites/dungeon.json\")\n     *\n     * const player = add([\n     *     sprite(\"hero\"),\n     * ])\n     *\n     * player.play(\"run\")\n     * ```\n     *\n     * @group Assets\n     */\n    loadSpriteAtlas(\n        src: LoadSpriteSrc,\n        url: string,\n    ): Asset<Record<string, SpriteData>>;\n    /**\n     * Load a sprite with aseprite spritesheet json (should use \"array\" in the export options).\n     *\n     * @example\n     * ```js\n     * loadAseprite(\"car\", \"sprites/car.png\", \"sprites/car.json\")\n     * ```\n     *\n     * @group Assets\n     */\n    loadAseprite(\n        name: string | null,\n        imgSrc: LoadSpriteSrc,\n        jsonSrc: string | AsepriteData,\n    ): Asset<SpriteData>;\n    /**\n     * @group Assets\n     */\n    loadPedit(name: string | null, src: string): Asset<SpriteData>;\n    /**\n     * Load default sprite \"bean\".\n     *\n     * @example\n     * ```js\n     * loadBean()\n     *\n     * // use it right away\n     * add([\n     *     sprite(\"bean\"),\n     * ])\n     * ```\n     *\n     * @group Assets\n     */\n    loadBean(name?: string): Asset<SpriteData>;\n    /**\n     * Load custom JSON data from url.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    loadJSON(name: string | null, url: string): Asset<any>;\n    /**\n     * Load a sound into asset manager, with name and resource url.\n     *\n     * @example\n     * ```js\n     * loadSound(\"shoot\", \"/sounds/horse.ogg\")\n     * loadSound(\"shoot\", \"/sounds/squeeze.mp3\")\n     * loadSound(\"shoot\", \"/sounds/shoot.wav\")\n     * ```\n     *\n     * @group Assets\n     */\n    loadSound(\n        name: string | null,\n        src: string | ArrayBuffer,\n    ): Asset<SoundData>;\n    /**\n     * Like loadSound(), but the audio is streamed and won't block loading. Use this for big audio files like background music.\n     *\n     * @example\n     * ```js\n     * loadMusic(\"shoot\", \"/music/bossfight.mp3\")\n     * ```\n     * @group Assets\n     */\n    loadMusic(\n        name: string | null,\n        url: string,\n    ): void;\n    /**\n     * Load a font (any format supported by the browser, e.g. ttf, otf, woff).\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * // load a font from a .ttf file\n     * loadFont(\"frogblock\", \"fonts/frogblock.ttf\")\n     * ```\n     * @group Assets\n     */\n    loadFont(\n        name: string,\n        src: string | BinaryData,\n        opt?: LoadFontOpt,\n    ): Asset<FontData>;\n    /**\n     * Load a bitmap font into asset manager, with name and resource url and infomation on the layout of the bitmap.\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * // load a bitmap font called \"04b03\", with bitmap \"fonts/04b03.png\"\n     * // each character on bitmap has a size of (6, 8), and contains default ASCII_CHARS\n     * loadBitmapFont(\"04b03\", \"fonts/04b03.png\", 6, 8)\n     *\n     * // load a font with custom characters\n     * loadBitmapFont(\"myfont\", \"myfont.png\", 6, 8, { chars: \"\u263A\u263B\u2665\u2666\u2663\u2660\" })\n     * ```\n     *\n     * @group Assets\n     */\n    loadBitmapFont(\n        name: string | null,\n        src: string,\n        gridWidth: number,\n        gridHeight: number,\n        options?: LoadBitmapFontOpt,\n    ): Asset<BitmapFontData>;\n    /**\n     * Load a shader with vertex and fragment code.\n     *\n     * @example\n     * ```js\n     * // default shaders and custom shader format\n     * loadShader(\"outline\",\n     * `vec4 vert(vec2 pos, vec2 uv, vec4 color) {\n     *     // predefined functions to get the default value by kaboom\n     *     return def_vert();\n     * }`,\n     * `vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n     *     // turn everything blue-ish\n     *     return def_frag() * vec4(0, 0, 1, 1);\n     * }`, false)\n     * ```\n     *\n     * @group Assets\n     */\n    loadShader(\n        name: string | null,\n        vert?: string,\n        frag?: string,\n    ): Asset<ShaderData>;\n    /**\n     * Load a shader with vertex and fragment code file url.\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * // load only a fragment shader from URL\n     * loadShader(\"outline\", null, \"/shaders/outline.glsl\", true)\n     * ```\n     *\n     * @group Assets\n     */\n    loadShaderURL(\n        name: string | null,\n        vert?: string,\n        frag?: string,\n    ): Asset<ShaderData>;\n    /**\n     * Add a new loader to wait for before starting the game.\n     *\n     * @example\n     * ```js\n     * load(new Promise((resolve, reject) => {\n     *     // anything you want to do that stalls the game in loading state\n     *     resolve(\"ok\")\n     * }))\n     * ```\n     *\n     * @group Assets\n     */\n    load<T>(l: Promise<T>): Asset<T>;\n    /**\n     * Get the global asset loading progress (0.0 - 1.0).\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    loadProgress(): number;\n    /**\n     * Get SpriteData from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getSprite(name: string): Asset<SpriteData> | void;\n    /**\n     * Get SoundData from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getSound(name: string): Asset<SoundData> | void;\n    /**\n     * Get FontData from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getFont(name: string): Asset<FontData> | void;\n    /**\n     * Get BitmapFontData from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getBitmapFont(name: string): Asset<BitmapFontData> | void;\n    /**\n     * Get ShaderData from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getShader(name: string): Asset<ShaderData> | void;\n    /**\n     * Get custom data from name.\n     *\n     * @since v3000.0\n     * @group Assets\n     */\n    getAsset(name: string): Asset<any> | void;\n    /**\n     * The asset data.\n     * @group Assets\n     */\n    Asset: typeof Asset;\n    /**\n     * The sprite data.\n     * @group Assets\n     */\n    SpriteData: typeof SpriteData;\n    /**\n     * @group Assets\n     */\n    SoundData: typeof SoundData;\n    /**\n     * Get the width of game.\n     *\n     * @group Info\n     */\n    width(): number;\n    /**\n     * Get the height of game.\n     *\n     * @group Info\n     */\n    height(): number;\n    /**\n     * Get the center point of view.\n     *\n     * @example\n     * ```js\n     * // add bean to the center of the screen\n     * add([\n     *     sprite(\"bean\"),\n     *     pos(center()),\n     *     // ...\n     * ])\n     * ```\n     *\n     * @group Info\n     */\n    center(): Vec2;\n    /**\n     * Get the delta time since last frame.\n     *\n     * @example\n     * ```js\n     * // rotate bean 100 deg per second\n     * bean.onUpdate(() => {\n     *     bean.angle += 100 * dt()\n     * })\n     * ```\n     *\n     * @group Info\n     */\n    dt(): number;\n    /**\n     * Get the total time since beginning.\n     *\n     * @group Info\n     */\n    time(): number;\n    /**\n     * If the game canvas is currently focused.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isFocused(): boolean;\n    /**\n     * Is currently on a touch screen device.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    isTouchscreen(): boolean;\n    /**\n     * Get current mouse position (without camera transform).\n     *\n     * @group Info\n     */\n    mousePos(): Vec2;\n    /**\n     * How much mouse moved last frame.\n     *\n     * @group Info\n     */\n    mouseDeltaPos(): Vec2;\n    /**\n     * If certain key is currently down.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // equivalent to the calling bean.move() in an onKeyDown(\"left\")\n     * onUpdate(() => {\n     *     if (isKeyDown(\"left\")) {\n     *         bean.move(-SPEED, 0)\n     *     }\n     * })\n     * ```\n     * @group Info\n     */\n    isKeyDown(k?: Key): boolean;\n    /**\n     * If certain key is just pressed last frame.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isKeyPressed(k?: Key): boolean;\n    /**\n     * If certain key is just pressed last frame (also fires repeatedly when the key is being held down).\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isKeyPressedRepeat(k?: Key): boolean;\n    /**\n     * If certain key is just released last frame.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isKeyReleased(k?: Key): boolean;\n    /**\n     * If a mouse button is currently down.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isMouseDown(button?: MouseButton): boolean;\n    /**\n     * If a mouse button is just clicked last frame.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isMousePressed(button?: MouseButton): boolean;\n    /**\n     * If a mouse button is just released last frame.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isMouseReleased(button?: MouseButton): boolean;\n    /**\n     * If mouse moved last frame.\n     *\n     * @since v2000.1\n     * @group Info\n     */\n    isMouseMoved(): boolean;\n    /**\n     * If a gamepad button is just pressed last frame\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    isGamepadButtonPressed(btn?: GamepadButton): boolean;\n    /**\n     * If a gamepad button is currently held down.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    isGamepadButtonDown(btn?: GamepadButton): boolean;\n    /**\n     * If a gamepad button is just released last frame.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    isGamepadButtonReleased(btn?: GamepadButton): boolean;\n    /**\n     * Get stick axis values from a gamepad.\n     *\n     * @since v3001.0\n     * @group Info\n     */\n    getGamepadStick(stick: GamepadStick): Vec2;\n    /**\n     * List of characters inputted since last frame.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    charInputted(): string[];\n    /**\n     * Camera shake.\n     *\n     * @example\n     * ```js\n     * // shake intensively when bean collides with a \"bomb\"\n     * bean.onCollide(\"bomb\", () => {\n     *     shake(120)\n     * })\n     * ```\n     *\n     * @group Info\n     */\n    shake(intensity: number): void;\n    /**\n     * Get / set camera position.\n     *\n     * @example\n     * ```js\n     * // camera follows player\n     * player.onUpdate(() => {\n     *     camPos(player.pos)\n     * })\n     * ```\n     *\n     * @group Info\n     */\n    camPos(pos: Vec2): Vec2;\n    camPos(x: number, y: number): Vec2;\n    camPos(): Vec2;\n    /**\n     * Get / set camera scale.\n     *\n     * @group Info\n     */\n    camScale(scale: Vec2): Vec2;\n    camScale(x: number, y: number): Vec2;\n    camScale(): Vec2;\n    /**\n     * Get / set camera rotation.\n     *\n     * @group Info\n     */\n    camRot(angle?: number): number;\n    /**\n     * Transform a point from world position to screen position.\n     *\n     * @group Info\n     */\n    toScreen(p: Vec2): Vec2;\n    /**\n     * Transform a point from screen position to world position.\n     *\n     * @group Info\n     */\n    toWorld(p: Vec2): Vec2;\n    /**\n     * Set gravity.\n     *\n     * @group Info\n     */\n    setGravity(g: number): void;\n    /**\n     * Get gravity.\n     *\n     * @group Info\n     */\n    getGravity(): number;\n    /**\n     * Set gravity direction.\n     */\n    setGravityDirection(d: Vec2): void;\n    /**\n     * Get gravity direction.\n     */\n    getGravityDirection(): Vec2;\n    /**\n     * Set background color.\n     *\n     * @group Info\n     */\n    setBackground(color: Color, alpha?: number): void;\n    setBackground(r: number, g: number, b: number, alpha?: number): void;\n    /**\n     * Get background color.\n     *\n     * @group Info\n     */\n    getBackground(): Color;\n    /**\n     * Get connected gamepads.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    getGamepads(): KGamePad[];\n    /**\n     * Set cursor style (check Cursor type for possible values). Cursor will be reset to \"default\" every frame so use this in an per-frame action.\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * button.onHover((c) => {\n     *     setCursor(\"pointer\")\n     * })\n     * ```\n     *\n     * @group Info\n     */\n    setCursor(style: Cursor): void;\n    /**\n     * Get current cursor style.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    getCursor(): Cursor;\n    /**\n     * Lock / unlock cursor. Note that you cannot lock cursor within 1 second after user unlocking the cursor with the default unlock gesture (typically the esc key) due to browser policy.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    setCursorLocked(locked: boolean): void;\n    /**\n     * Get if cursor is currently locked.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    isCursorLocked(): boolean;\n    /**\n     * Enter / exit fullscreen mode. (note: mouse position is not working in fullscreen mode at the moment)\n     *\n     * @example\n     * ```js\n     * // toggle fullscreen mode on \"f\"\n     * onKeyPress(\"f\", (c) => {\n     *     setFullscreen(!isFullscreen())\n     * })\n     * ```\n     * @group Info\n     */\n    setFullscreen(f?: boolean): void;\n    /**\n     * If currently in fullscreen mode.\n     *\n     * @group Info\n     */\n    isFullscreen(): boolean;\n    /**\n     * Run the callback after n seconds.\n     *\n     * @section Timer\n     *\n     * @example\n     * ```js\n     * // 3 seconds until explosion! Runnn!\n     * wait(3, () => {\n     *     explode()\n     * })\n     *\n     * // wait() returns a PromiseLike that can be used with await\n     * await wait(1)\n     * ```\n     * @group Timer\n     */\n    wait(n: number, action?: () => void): TimerController;\n    /**\n     * Run the callback every n seconds.\n     *\n     * @example\n     * ```js\n     * // spawn a butterfly at random position every 1 second\n     * loop(1, () => {\n     *     add([\n     *         sprite(\"butterfly\"),\n     *         pos(rand(vec2(width(), height()))),\n     *         area(),\n     *         \"friend\",\n     *     ])\n     * })\n     * ```\n     * @group Timer\n     */\n    loop(t: number, action: () => void): EventController;\n    /**\n     * Play a piece of audio.\n     *\n     * @section Audio\n     *\n     * @returns A control handle.\n     *\n     * @example\n     * ```js\n     * // play a one off sound\n     * play(\"wooosh\")\n     *\n     * // play a looping soundtrack (check out AudioPlayOpt for more options)\n     * const music = play(\"OverworldlyFoe\", {\n     *     volume: 0.8,\n     *     loop: true\n     * })\n     *\n     * // using the handle to control (check out AudioPlay for more controls / info)\n     * music.paused = true\n     * music.speed = 1.2\n     * ```\n     *\n     * @group Audio\n     */\n    play(\n        src:\n            | string\n            | SoundData\n            | Asset<SoundData>\n            | MusicData\n            | Asset<MusicData>,\n        options?: AudioPlayOpt,\n    ): AudioPlay;\n    /**\n     * Yep. Plays a burp sound.\n     *\n     * @group Audio\n     */\n    burp(options?: AudioPlayOpt): AudioPlay;\n    /**\n     * Sets global volume.\n     *\n     * @example\n     * ```js\n     * // makes everything quieter\n     * volume(0.5)\n     * ```\n     *\n     * @group Audio\n     */\n    volume(v?: number): number;\n    /**\n     * Get the underlying browser AudioContext.\n     *\n     * @group Audio\n     */\n    audioCtx: AudioContext;\n    /**\n     * Get a random number between 0 - 1.\n     *\n     * @group Math\n     */\n    rand(): number;\n    /**\n     * Get a random value between 0 and the given value.\n     *\n     * @example\n     * ```js\n     * // a random number between 0 - 8\n     * rand(8)\n     *\n     * // a random point on screen\n     * rand(vec2(width(), height()))\n     *\n     * // a random color\n     * rand(rgb(255, 255, 255))\n     * ```\n     *\n     * @group Math\n     */\n    rand<T = RNGValue>(n: T): T;\n    /**\n     * Get a random value between the given bound.\n     *\n     * @example\n     * ```js\n     * rand(50, 100)\n     * rand(vec2(20), vec2(100))\n     *\n     * // spawn something on the right side of the screen but with random y value within screen height\n     * add([\n     *     pos(width(), rand(0, height())),\n     * ])\n     * ```\n     *\n     * @group Math\n     */\n    rand<T = RNGValue>(a: T, b: T): T;\n    /**\n     * rand() but floored to integer.\n     *\n     * @example\n     * ```js\n     * randi(10) // returns 0 to 9\n     * ```\n     *\n     * @group Math\n     */\n    randi(n: number): number;\n    /**\n     * rand() but floored to integer.\n     *\n     * @example\n     * ```js\n     * randi(0, 3) // returns 0, 1, or 2\n     * ```\n     *\n     * @group Math\n     */\n    randi(a: number, b: number): number;\n    /**\n     * rand() but floored to integer.\n     *\n     * @example\n     * ```js\n     * randi() // returns either 0 or 1\n     * ```\n     *\n     * @group Math\n     */\n    randi(): number;\n    /**\n     * Get / set the random number generator seed.\n     *\n     * @example\n     * ```js\n     * randSeed(Date.now())\n     * ```\n     *\n     * @group Math\n     */\n    randSeed(seed?: number): number;\n    /**\n     * Create a 2d vector.\n     *\n     * @example\n     * ```js\n     * // { x: 0, y: 0 }\n     * vec2()\n     *\n     * // { x: 10, y: 10 }\n     * vec2(10)\n     *\n     * // { x: 100, y: 80 }\n     * vec2(100, 80)\n     *\n     * // move to 150 degrees direction with by length 10\n     * player.pos = pos.add(Vec2.fromAngle(150).scale(10))\n     * ```\n     *\n     * @group Math\n     */\n    vec2(x: number, y: number): Vec2;\n    vec2(p: Vec2): Vec2;\n    vec2(xy: number): Vec2;\n    vec2(): Vec2;\n    /**\n     * Create a color from RGB values (0 - 255).\n     *\n     * @example\n     * ```js\n     * // update the color of the sky to light blue\n     * sky.color = rgb(0, 128, 255)\n     * ```\n     *\n     * @group Math\n     */\n    rgb(r: number, g: number, b: number): Color;\n    /**\n     * Create a color from hex string.\n     *\n     * @since v3001.0\n     *\n     * @example\n     * ```js\n     * sky.color = rgb(\"#ef6360\")\n     *\n     * @group Math\n     */\n    rgb(hex: string): Color;\n    /**\n     * Same as rgb(255, 255, 255).\n     *\n     * @group Math\n     */\n    rgb(): Color;\n    /**\n     * Convert HSL color (all values in 0.0 - 1.0 range) to RGB color.\n     *\n     * @since v2000.1\n     *\n     * @example\n     * ```js\n     * // animate rainbow color\n     * onUpdate(\"rainbow\", (obj) => {\n     *     obj.color = hsl2rgb(wave(0, 1, time()), 0.6, 0.6)\n     * })\n     * ```\n     *\n     * @group Math\n     */\n    hsl2rgb(hue: number, saturation: number, lightness: number): Color;\n    /**\n     * Rectangle area (0.0 - 1.0).\n     *\n     * @group Math\n     */\n    quad(x: number, y: number, w: number, h: number): Quad;\n    /**\n     * Choose a random item from a list.\n     *\n     * @example\n     * ```js\n     * // decide the best fruit randomly\n     * const bestFruit = choose([\"apple\", \"banana\", \"pear\", \"watermelon\"])\n     * ```\n     *\n     * @group Math\n     */\n    choose<T>(lst: T[]): T;\n    /**\n     * Choose multiple random items from a list.\n     *\n     * @since v3001.0\n     * @group Math\n     */\n    chooseMultiple<T>(lst: T[], count: number): T[];\n    /**\n     * Shuffle an array.\n     *\n     * @since v3001.0\n     * @group Math\n     */\n    shuffle<T>(lst: T[]): T[];\n    /**\n     * rand(1) <= p\n     *\n     * @example\n     * ```js\n     * // every frame all objs with tag \"unlucky\" have 50% chance die\n     * onUpdate(\"unlucky\", (o) => {\n     *     if (chance(0.5)) {\n     *         destroy(o)\n     *     }\n     * })\n     * ```\n     *\n     * @group Math\n     */\n    chance(p: number): boolean;\n    /**\n     * Linear interpolation.\n     *\n     * @group Math\n     */\n    lerp<V extends LerpValue>(from: V, to: V, t: number): V;\n    /**\n     * Tweeeeeeeening!\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * // tween bean to mouse position\n     * tween(bean.pos, mousePos(), 1, (p) => bean.pos = p, easings.easeOutBounce)\n     *\n     * // tween() returns a then-able that can be used with await\n     * await tween(bean.opacity, 1, 0.5, (val) => bean.opacity = val, easings.easeOutQuad)\n     * ```\n     *\n     * @group Math\n     */\n    tween<V extends LerpValue>(\n        from: V,\n        to: V,\n        duration: number,\n        setValue: (value: V) => void,\n        easeFunc?: (t: number) => number,\n    ): TweenController;\n    /**\n     * A collection of easing functions for tweening.\n     *\n     * @since v3000.0\n     * @group Math\n     */\n    easings: Record<EaseFuncs, EaseFunc>;\n    /**\n     * Map a value from one range to another range.\n     *\n     * @group Math\n     */\n    map(\n        v: number,\n        l1: number,\n        h1: number,\n        l2: number,\n        h2: number,\n    ): number;\n    /**\n     * Map a value from one range to another range, and clamp to the dest range.\n     *\n     * @group Math\n     */\n    mapc(\n        v: number,\n        l1: number,\n        h1: number,\n        l2: number,\n        h2: number,\n    ): number;\n    /**\n     * Interpolate between 2 values (Optionally takes a custom periodic function, which default to Math.sin).\n     *\n     * @example\n     * ```js\n     * // bounce color between 2 values as time goes on\n     * onUpdate(\"colorful\", (c) => {\n     *     c.color.r = wave(0, 255, time())\n     *     c.color.g = wave(0, 255, time() + 1)\n     *     c.color.b = wave(0, 255, time() + 2)\n     * })\n     * ```\n     *\n     * @group Math\n     */\n    wave(\n        lo: number,\n        hi: number,\n        t: number,\n        func?: (x: number) => number,\n    ): number;\n    /**\n     * Convert degrees to radians.\n     *\n     * @group Math\n     */\n    deg2rad(deg: number): number;\n    /**\n     * Convert radians to degrees.\n     *\n     * @group Math\n     */\n    rad2deg(rad: number): number;\n    /**\n     * Return a value clamped to an inclusive range of min and max.\n     *\n     * @group Math\n     */\n    clamp(n: number, min: number, max: number): number;\n    /**\n     * Evaluate the Bezier at the given t\n     *\n     * @group Math\n     */\n    evaluateBezier(pt1: Vec2, pt2: Vec2, pt3: Vec2, pt4: Vec2, t: number): Vec2;\n    /**\n     * Check if a line and a point intersect.\n     *\n     * @group Math\n     */\n    testLinePoint(l: Line, pt: Vec2): boolean;\n    /**\n     * Check if 2 lines intersects, if yes returns the intersection point.\n     *\n     * @group Math\n     */\n    testLineLine(l1: Line, l2: Line): Vec2 | null;\n    /**\n     * Check if a line and a circle intersect.\n     *\n     * @group Math\n     */\n    testLineCircle(l: Line, circle: Circle): boolean;\n    /**\n     * Check if 2 rectangle overlaps.\n     *\n     * @group Math\n     */\n    testRectRect(r1: Rect, r2: Rect): boolean;\n    /**\n     * Check if a line and a rectangle overlaps.\n     *\n     * @group Math\n     */\n    testRectLine(r: Rect, l: Line): boolean;\n    /**\n     * Check if a point is inside a rectangle.\n     *\n     * @group Math\n     */\n    testRectPoint(r: Rect, pt: Point): boolean;\n    /**\n     * Check if a circle and polygon intersect linewise.\n     * @group Math\n     */\n    /**\n     * @group Math\n     */\n    testCirclePolygon(c: Circle, p: Polygon): boolean;\n    /**\n     * @group Math\n     */\n    isConvex(pts: Vec2[]): boolean;\n    /**\n     * @group Math\n     */\n    triangulate(pts: Vec2[]): Vec2[][];\n    /**\n     * @group Math\n     */\n    Line: typeof Line;\n    /**\n     * @group Math\n     */\n    Rect: typeof Rect;\n    /**\n     * @group Math\n     */\n    Circle: typeof Circle;\n    /**\n     * @group Math\n     */\n    Ellipse: typeof Ellipse;\n    /**\n     * @group Math\n     */\n    Polygon: typeof Polygon;\n    /**\n     * @group Math\n     */\n    Vec2: typeof Vec2;\n    /**\n     * @group Math\n     */\n    Color: typeof Color;\n    /**\n     * @group Math\n     */\n    Mat4: typeof Mat4;\n    /**\n     * @group Math\n     */\n    Quad: typeof Quad;\n    /**\n     * @group Math\n     */\n    RNG: typeof RNG;\n    /**\n     * Define a scene.\n     *\n     * @group Scene\n     */\n    scene(id: SceneName, def: SceneDef): void;\n    /**\n     * Go to a scene, passing all rest args to scene callback.\n     *\n     * @group Scene\n     */\n    go(id: SceneName, ...args: any): void;\n    /**\n     * Construct a level based on symbols.\n     *\n     * @group Level\n     *\n     * @example\n     * ```js\n     * addLevel([\n     *     \"                          $\",\n     *     \"                          $\",\n     *     \"           $$         =   $\",\n     *     \"  %      ====         =   $\",\n     *     \"                      =    \",\n     *     \"       ^^      = >    =   &\",\n     *     \"===========================\",\n     * ], {\n     *     // define the size of tile block\n     *     tileWidth: 32,\n     *     tileHeight: 32,\n     *     // define what each symbol means, by a function returning a component list (what will be passed to add())\n     *     tiles: {\n     *         \"=\": () => [\n     *             sprite(\"floor\"),\n     *             area(),\n     *             solid(),\n     *         ],\n     *         \"$\": () => [\n     *             sprite(\"coin\"),\n     *             area(),\n     *             pos(0, -9),\n     *         ],\n     *         \"^\": () => [\n     *             sprite(\"spike\"),\n     *             area(),\n     *             \"danger\",\n     *         ],\n     *     }\n     * })\n     * ```\n     */\n    addLevel(map: string[], options: LevelOpt): GameObj;\n    /**\n     * Get data from local storage, if not present can set to a default value.\n     *\n     * @group Data\n     */\n    getData<T>(key: string, def?: T): T;\n    /**\n     * Set data from local storage.\n     *\n     * @group Data\n     */\n    setData(key: string, data: any): void;\n    /**\n     * Draw a sprite.\n     *\n     * @example\n     * ```js\n     * drawSprite({\n     *     sprite: \"bean\",\n     *     pos: vec2(100, 200),\n     *     frame: 3,\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawSprite(options: DrawSpriteOpt): void;\n    /**\n     * Draw a piece of text.\n     *\n     * @example\n     * ```js\n     * drawText({\n     *     text: \"oh hi\",\n     *     size: 48,\n     *     font: \"sans-serif\",\n     *     width: 120,\n     *     pos: vec2(100, 200),\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawText(options: DrawTextOpt): void;\n    /**\n     * Draw a rectangle.\n     *\n     * @example\n     * ```js\n     * drawRect({\n     *     width: 120,\n     *     height: 240,\n     *     pos: vec2(20, 20),\n     *     color: YELLOW,\n     *     outline: { color: BLACK, width: 4 },\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawRect(options: DrawRectOpt): void;\n    /**\n     * Draw a line.\n     *\n     * @example\n     * ```js\n     * drawLine({\n     *     p1: vec2(0),\n     *     p2: mousePos(),\n     *     width: 4,\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     * @group Draw\n     */\n    drawLine(options: DrawLineOpt): void;\n    /**\n     * Draw lines.\n     *\n     * @example\n     * ```js\n     * drawLines({\n     *     pts: [ vec2(0), vec2(0, height()), mousePos() ],\n     *     width: 4,\n     *     pos: vec2(100, 200),\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawLines(options: DrawLinesOpt): void;\n    /**\n     * Draw a curve.\n     *\n     * @example\n     * ```js\n     * drawCurve(t => evaluateBezier(a, b, c, d, t)\n     * {\n     *     width: 2,\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawCurve(curve: (t: number) => Vec2, opt: DrawCurveOpt): void;\n    /**\n     * Draw a cubic Bezier curve.\n     *\n     * @example\n     * ```js\n     * drawBezier({\n     *     pt1: vec2(100, 100),\n     *     pt2: vec2(200, 100),\n     *     pt3: vec2(200, 200),\n     *     pt4: vec2(100, 200),\n     *     width: 2,\n     *     color: GREEN\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawBezier(opt: DrawBezierOpt): void;\n    /**\n     * Draw a triangle.\n     *\n     * @example\n     * ```js\n     * drawTriangle({\n     *     p1: vec2(0),\n     *     p2: vec2(0, height()),\n     *     p3: mousePos(),\n     *     pos: vec2(100, 200),\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawTriangle(options: DrawTriangleOpt): void;\n    /**\n     * Draw a circle.\n     *\n     * @example\n     * ```js\n     * drawCircle({\n     *     pos: vec2(100, 200),\n     *     radius: 120,\n     *     color: rgb(255, 255, 0),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawCircle(options: DrawCircleOpt): void;\n    /**\n     * Draw an ellipse.\n     *\n     * @example\n     * ```js\n     * drawEllipse({\n     *     pos: vec2(100, 200),\n     *     radiusX: 120,\n     *     radiusY: 120,\n     *     color: rgb(255, 255, 0),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawEllipse(options: DrawEllipseOpt): void;\n    /**\n     * Draw a convex polygon from a list of vertices.\n     *\n     * @example\n     * ```js\n     * drawPolygon({\n     *     pts: [\n     *         vec2(-12),\n     *         vec2(0, 16),\n     *         vec2(12, 4),\n     *         vec2(0, -2),\n     *         vec2(-8),\n     *     ],\n     *     pos: vec2(100, 200),\n     *     color: rgb(0, 0, 255),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    drawPolygon(options: DrawPolygonOpt): void;\n    /**\n     * Draw a rectangle with UV data.\n     *\n     * @group Draw\n     */\n    drawUVQuad(options: DrawUVQuadOpt): void;\n    /**\n     * Draw a piece of formatted text from formatText().\n     *\n     * @since v2000.2\n     *\n     * @example\n     * ```js\n     * // text background\n     * const txt = formatText({\n     *     text: \"oh hi\",\n     * })\n     *\n     * drawRect({\n     *     width: txt.width,\n     *     height: txt.height,\n     * })\n     *\n     * drawFormattedText(txt)\n     * ```\n     *\n     * @group Draw\n     */\n    drawFormattedText(text: FormattedText): void;\n    /**\n     * Whatever drawn in content will only be drawn if it's also drawn in mask (mask will not be rendered).\n     *\n     * @since v3000.0\n     * @group Draw\n     */\n    drawMasked(content: () => void, mask: () => void): void;\n    /**\n     * Subtract whatever drawn in content by whatever drawn in mask (mask will not be rendered).\n     *\n     * @since v3000.0\n     * @group Draw\n     */\n    drawSubtracted(content: () => void, mask: () => void): void;\n    /**\n     * Push current transform matrix to the transform stack.\n     *\n     * @example\n     * ```js\n     * pushTransform()\n     *\n     * // these transforms will affect every render until popTransform()\n     * pushTranslate(120, 200)\n     * pushRotate(time() * 120)\n     * pushScale(6)\n     *\n     * drawSprite(\"bean\")\n     * drawCircle(vec2(0), 120)\n     *\n     * // restore the transformation stack to when last pushed\n     * popTransform()\n     * ```\n     *\n     * @group Draw\n     */\n    pushTransform(): void;\n    /**\n     * Pop the topmost transform matrix from the transform stack.\n     *\n     * @group Draw\n     */\n    popTransform(): void;\n    /**\n     * Translate all subsequent draws.\n     *\n     * @example\n     * ```js\n     * pushTranslate(100, 100)\n     *\n     * // this will be drawn at (120, 120)\n     * drawText({\n     *     text: \"oh hi\",\n     *     pos: vec2(20, 20),\n     * })\n     * ```\n     *\n     * @group Draw\n     */\n    pushTranslate(x: number, y: number): void;\n    pushTranslate(p: Vec2): void;\n    /**\n     * Scale all subsequent draws.\n     *\n     * @group Draw\n     */\n    pushScale(x: number, y: number): void;\n    pushScale(s: number): void;\n    pushScale(s: Vec2): void;\n    /**\n     * Rotate all subsequent draws.\n     *\n     * @group Draw\n     */\n    pushRotate(angle: number): void;\n    /**\n     * Apply a transform matrix, ignore all prior transforms.\n     *\n     * @since v3000.0\n     * @group Draw\n     */\n    pushMatrix(mat: Mat4): void;\n    /**\n     * Apply a post process effect from a shader name.\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * loadShader(\"invert\", null, `\n     * vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n     *     vec4 c = def_frag();\n     *     return vec4(1.0 - c.r, 1.0 - c.g, 1.0 - c.b, c.a);\n     * }\n     * `)\n     *\n     * usePostEffect(\"invert\")\n     * ```\n     *\n     * @group Draw\n     */\n    usePostEffect(name: string, uniform?: Uniform | (() => Uniform)): void;\n    /**\n     * Format a piece of text without drawing (for getting dimensions, etc).\n     *\n     * @since v2000.2\n     *\n     * @example\n     * ```js\n     * // text background\n     * const txt = formatText({\n     *     text: \"oh hi\",\n     * })\n     *\n     * drawRect({\n     *     width: txt.width,\n     *     height: txt.height,\n     * })\n     *\n     * drawFormattedText(txt)\n     * ```\n     *\n     * @group Draw\n     */\n    formatText(options: DrawTextOpt): FormattedText;\n    /**\n     * Create a canvas to draw stuff offscreen.\n     *\n     * @since v3001.0\n     * @group Draw\n     */\n    makeCanvas(w: number, h: number): Canvas;\n    /**\n     * @section Debug\n     *\n     * @example\n     * ```js\n     * // pause the whole game\n     * debug.paused = true\n     *\n     * // enter inspect mode\n     * debug.inspect = true\n     * ```\n     * @group Draw\n     */\n    debug: Debug;\n    /**\n     * Import a plugin.\n     *\n     * @group Plugins\n     */\n    plug<T extends Record<string, any>>(plugin: KaboomPlugin<T>): KaboomCtx & T;\n    /**\n     * Take a screenshot and get the dataurl of the image.\n     *\n     * @returns The dataURL of the image.\n     * @group Data\n     */\n    screenshot(): string;\n    /**\n     * Trigger a file download from a url.\n     *\n     * @since v3000.0\n     * @group Data\n     */\n    download(filename: string, dataurl: string): void;\n    /**\n     * Trigger a text file download.\n     *\n     * @since v3000.0\n     * @group Data\n     */\n    downloadText(filename: string, text: string): void;\n    /**\n     * Trigger a json download from a .\n     *\n     * @since v3000.0\n     * @group Data\n     */\n    downloadJSON(filename: string, data: any): void;\n    /**\n     * Trigger a file download from a blob.\n     *\n     * @since v3000.0\n     * @group Data\n     */\n    downloadBlob(filename: string, blob: Blob): void;\n    /**\n     * Start recording the canvas into a video. If framerate is not specified, a new frame will be captured each time the canvas changes.\n     *\n     * @returns A control handle.\n     *\n     * @since v2000.1\n     * @group Data\n     */\n    record(frameRate?: number): Recording;\n    /**\n     * Add an explosion\n     *\n     * @group Misc\n     */\n    addKaboom(pos: Vec2, opt?: BoomOpt): GameObj;\n    /**\n     * All chars in ASCII.\n     *\n     * @group Misc\n     */\n    ASCII_CHARS: string;\n    /**\n     * Left directional vector vec2(-1, 0).\n     *\n     * @group Misc\n     */\n    LEFT: Vec2;\n    /**\n     * Right directional vector vec2(1, 0).\n     *\n     * @group Misc\n     */\n    RIGHT: Vec2;\n    /**\n     * Up directional vector vec2(0, -1).\n     *\n     * @group Misc\n     */\n    UP: Vec2;\n    /**\n     * Down directional vector vec2(0, 1).\n     *\n     * @group Misc\n     */\n    DOWN: Vec2;\n    /**\n     * Red color.\n     *\n     * @group Misc\n     */\n    RED: Color;\n    /**\n     * Green color.\n     *\n     * @group Misc\n     */\n    GREEN: Color;\n    /**\n     * Blue color.\n     *\n     * @group Misc\n     */\n    BLUE: Color;\n    /**\n     * Yellow color.\n     *\n     * @group Misc\n     */\n    YELLOW: Color;\n    /**\n     * Cyan color.\n     *\n     * @group Misc\n     */\n    MAGENTA: Color;\n    /**\n     * Cyan color.\n     *\n     * @group Misc\n     */\n    CYAN: Color;\n    /**\n     * White color.\n     *\n     * @group Misc\n     */\n    WHITE: Color;\n    /**\n     * Black color.\n     *\n     * @group Misc\n     */\n    BLACK: Color;\n    /**\n     * The canvas DOM kaboom is currently using.\n     *\n     * @group Misc\n     */\n    canvas: HTMLCanvasElement;\n    /**\n     * End everything.\n     *\n     * @group Start\n     */\n    quit: () => void;\n    /**\n     * EventHandler for one single event.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    Event: typeof Event;\n    /**\n     * EventHandler for multiple events.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    EventHandler: typeof EventHandler;\n    /**\n     * The object that can pause or cancel an event.\n     *\n     * @since v3000.0\n     * @group Events\n     */\n    EventController: typeof EventController;\n    /**\n     * Current Kaboom library version.\n     *\n     * @since v3000.0\n     * @group Info\n     */\n    VERSION: string;\n}\n\nexport type Tag = string;\n\n// TODO: understand this\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends\n    ((k: infer I) => void) ? I : never;\ntype Defined<T> = T extends any\n    ? Pick<T, { [K in keyof T]-?: T[K] extends undefined ? never : K }[keyof T]>\n    : never;\ntype Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\nexport type MergeObj<T> = Expand<UnionToIntersection<Defined<T>>>;\nexport type MergeComps<T> = Omit<MergeObj<T>, keyof Comp>;\nexport type MergePlugins<T extends PluginList<any>> = MergeObj<\n    ReturnType<T[number]>\n>;\n\nexport type CompList<T> = Array<T | Tag>;\nexport type PluginList<T> = Array<T | KaboomPlugin<any>>;\n\n/**\n * A key.\n *\n * @group Input\n */\nexport type Key =\n    | \"f1\"\n    | \"f2\"\n    | \"f3\"\n    | \"f4\"\n    | \"f5\"\n    | \"f6\"\n    | \"f7\"\n    | \"f8\"\n    | \"f9\"\n    | \"f10\"\n    | \"f11\"\n    | \"f12\"\n    | \"`\"\n    | \"1\"\n    | \"2\"\n    | \"3\"\n    | \"4\"\n    | \"5\"\n    | \"6\"\n    | \"7\"\n    | \"8\"\n    | \"9\"\n    | \"0\"\n    | \"-\"\n    | \"=\"\n    | \"q\"\n    | \"w\"\n    | \"e\"\n    | \"r\"\n    | \"t\"\n    | \"y\"\n    | \"u\"\n    | \"i\"\n    | \"o\"\n    | \"p\"\n    | \"[\"\n    | \"]\"\n    | \"\\\\\"\n    | \"a\"\n    | \"s\"\n    | \"d\"\n    | \"f\"\n    | \"g\"\n    | \"h\"\n    | \"j\"\n    | \"k\"\n    | \"l\"\n    | \";\"\n    | \"'\"\n    | \"z\"\n    | \"x\"\n    | \"c\"\n    | \"v\"\n    | \"b\"\n    | \"n\"\n    | \"m\"\n    | \",\"\n    | \".\"\n    | \"/\"\n    | \"escape\"\n    | \"backspace\"\n    | \"enter\"\n    | \"tab\"\n    | \"control\"\n    | \"alt\"\n    | \"meta\"\n    | \"space\"\n    | \" \"\n    | \"left\"\n    | \"right\"\n    | \"up\"\n    | \"down\"\n    | \"shift\";\n\n/**\n * @group Input\n */\nexport type MouseButton =\n    | \"left\"\n    | \"right\"\n    | \"middle\"\n    | \"back\"\n    | \"forward\";\n\n/**\n * @group Input\n */\nexport type GamepadButton =\n    | \"north\"\n    | \"east\"\n    | \"south\"\n    | \"west\"\n    | \"ltrigger\"\n    | \"rtrigger\"\n    | \"lshoulder\"\n    | \"rshoulder\"\n    | \"select\"\n    | \"start\"\n    | \"lstick\"\n    | \"rstick\"\n    | \"dpad-up\"\n    | \"dpad-right\"\n    | \"dpad-down\"\n    | \"dpad-left\"\n    | \"home\"\n    | \"capture\";\n\n/**\n * @group Input\n */\nexport type GamepadStick = \"left\" | \"right\";\n\nexport type GamepadDef = {\n    buttons: Record<string, GamepadButton>;\n    sticks: Partial<Record<GamepadStick, { x: number; y: number }>>;\n};\n\n/** A Kaboom's gamepad */\nexport type KGamePad = {\n    /** The order of the gamepad in the gamepad list. */\n    index: number;\n    /** If certain button is pressed. */\n    isPressed(b: GamepadButton): boolean;\n    /** If certain button is held down. */\n    isDown(b: GamepadButton): boolean;\n    /** If certain button is released. */\n    isReleased(b: GamepadButton): boolean;\n    /** Get the value of a stick. */\n    getStick(stick: GamepadStick): Vec2;\n};\n\n/**\n * Inspect info for a game object.\n */\nexport type GameObjInspect = Record<Tag, string | null>;\n\n/**\n * Kaboom configurations.\n *\n * @group Start\n */\nexport interface KaboomOpt<T extends PluginList<any> = any> {\n    /**\n     * Width of game.\n     */\n    width?: number;\n    /**\n     * Height of game.\n     */\n    height?: number;\n    /**\n     * Pixel scale / size.\n     */\n    scale?: number;\n    /**\n     * If stretch canvas to container when width and height is specified\n     */\n    stretch?: boolean;\n    /**\n     * When stretching if keep aspect ratio and leave black bars on remaining spaces.\n     */\n    letterbox?: boolean;\n    /**\n     * If register debug buttons (default true)\n     */\n    debug?: boolean;\n    /**\n     * key that toggles debug mode\n     */\n    debugKey?: Key;\n    /**\n     * Default font (defaults to \"monospace\").\n     */\n    font?: string;\n    /**\n     * Device pixel scale (defaults to window.devicePixelRatio, high pixel density will hurt performance).\n     *\n     * @since v3000.0\n     */\n    pixelDensity?: number;\n    /**\n     * Disable antialias and enable sharp pixel display.\n     */\n    crisp?: boolean;\n    /**\n     * The canvas DOM element to use. If empty will create one.\n     */\n    canvas?: HTMLCanvasElement;\n    /**\n     * The container DOM element to insert the canvas if created. Defaults to document.body.\n     */\n    root?: HTMLElement;\n    /**\n     * Background color. E.g. [ 0, 0, 255 ] for solid blue background, or [ 0, 0, 0, 0 ] for transparent background. Accepts RGB value array or string hex codes.\n     */\n    background?: number[] | string;\n    /**\n     * Default texture filter.\n     */\n    texFilter?: TexFilter;\n    /**\n     * How many log messages can there be on one screen (default 8).\n     */\n    logMax?: number;\n    /**\n     * How many seconds log messages stay on screen (default 4).\n     *\n     * @since v3000.1\n     */\n    logTime?: number;\n    /**\n     * Size of the spatial hash grid for collision detection (default 64).\n     *\n     * @since v3000.0\n     */\n    hashGridSize?: number;\n    /**\n     * If translate touch events as mouse clicks (default true).\n     */\n    touchToMouse?: boolean;\n    /**\n     * If kaboom should render a default loading screen when assets are not fully ready (default true).\n     *\n     * @since v3000.0\n     */\n    loadingScreen?: boolean;\n    /**\n     * If pause audio when tab is not active (default false).\n     *\n     * @since v3000.0\n     */\n    backgroundAudio?: boolean;\n    /**\n     * Custom gamepad definitions (see gamepad.json for reference of the format).\n     *\n     * @since v3000.0\n     */\n    gamepads?: Record<string, GamepadDef>;\n    /**\n     * Limit framerate to an amount per second.\n     *\n     * @since v3000.0\n     */\n    maxFPS?: number;\n    /**\n     * If focus on the canvas on start (default true).\n     *\n     * @since v3001.0\n     */\n    focus?: boolean;\n    /**\n     * If import all kaboom functions to global (default true).\n     */\n    global?: boolean;\n    /**\n     * List of plugins to import.\n     */\n    plugins?: T;\n    /**\n     * Enter burp mode.\n     */\n    burp?: boolean;\n}\n\nexport type KaboomPlugin<T> = (\n    k: KaboomCtx,\n) => T | ((...args: any) => (k: KaboomCtx) => T);\n\n/**\n * Base interface of all game objects.\n *\n * @group Game Obj\n */\nexport interface GameObjRaw {\n    /**\n     * Add a child.\n     *\n     * @since v3000.0\n     */\n    add<T>(comps?: CompList<T> | GameObj<T>): GameObj<T>;\n    /**\n     * Remove and re-add the game obj, without triggering add / destroy events.\n     */\n    readd<T>(obj: GameObj<T>): GameObj<T>;\n    /**\n     * Remove a child.\n     *\n     * @since v3000.0\n     */\n    remove(obj: GameObj): void;\n    /**\n     * Remove all children with a certain tag.\n     *\n     * @since v3000.0\n     */\n    removeAll(tag: Tag): void;\n    /**\n     * Remove all children.\n     *\n     * @since v3000.0\n     */\n    removeAll(): void;\n    /**\n     * Get a list of all game objs with certain tag.\n     *\n     * @since v3000.0\n     */\n    get(tag: Tag | Tag[], opts?: GetOpt): GameObj[];\n    /**\n     * Get the parent game obj, if have any.\n     *\n     * @since v3000.0\n     */\n    parent: GameObj | null;\n    /**\n     * Get all children game objects.\n     *\n     * @since v3000.0\n     */\n    children: GameObj[];\n    /**\n     * Update this game object and all children game objects.\n     *\n     * @since v3000.0\n     */\n    update(): void;\n    /**\n     * Draw this game object and all children game objects.\n     *\n     * @since v3000.0\n     */\n    draw(): void;\n    /**\n     * Draw debug info in inspect mode\n     *\n     * @since v3000.0\n     */\n    drawInspect: () => void;\n    clearEvents: () => void;\n    /**\n     * If there's certain tag(s) on the game obj.\n     */\n    is(tag: Tag | Tag[]): boolean;\n    // TODO: update the GameObj type info\n    /**\n     * Add a component or tag.\n     */\n    use(comp: Comp | Tag): void;\n    // TODO: update the GameObj type info\n    /**\n     * Remove a tag or a component with its id.\n     */\n    unuse(comp: Tag): void;\n    /**\n     * Register an event.\n     */\n    on(event: string, action: (...args: any) => void): EventController;\n    /**\n     * Trigger an event.\n     */\n    trigger(event: string, ...args: any): void;\n    /**\n     * Remove the game obj from scene.\n     */\n    destroy(): void;\n    /**\n     * Get state for a specific comp.\n     */\n    c(id: Tag): Comp | undefined;\n    /**\n     * Gather debug info of all comps.\n     */\n    inspect(): GameObjInspect;\n    /**\n     * Register an event that runs when the game obj is added to the scene.\n     */\n    onAdd(action: () => void): EventController;\n    /**\n     * Register an event that runs every frame as long as the game obj exists.\n     *\n     * @since v2000.1\n     */\n    onUpdate(action: () => void): EventController;\n    /**\n     * Register an event that runs every frame as long as the game obj exists (this is the same as `onUpdate()`, but all draw events are run after all update events).\n     *\n     * @since v2000.1\n     */\n    onDraw(action: () => void): EventController;\n    /**\n     * Register an event that runs when the game obj is destroyed.\n     *\n     * @since v2000.1\n     */\n    onDestroy(action: () => void): EventController;\n    /**\n     * If game obj is attached to the scene graph.\n     */\n    exists(): boolean;\n    /**\n     * Check if is an ancestor (recursive parent) of another game object\n     *\n     * @since v3000.0\n     */\n    isAncestorOf(obj: GameObj): boolean;\n    /**\n     * Calculated transform matrix of a game object.\n     *\n     * @since v3000.0\n     */\n    transform: Mat4;\n    /**\n     * If draw the game obj (run \"draw\" event or not).\n     */\n    hidden: boolean;\n    /**\n     * If update the game obj (run \"update\" event or not).\n     */\n    paused: boolean;\n    /**\n     * A unique number ID for each game object.\n     */\n    id: GameObjID | null;\n    /**\n     * The canvas to draw this game object on\n     *\n     * @since v3001.0\n     */\n    canvas: FrameBuffer | null;\n    onKeyDown(key: Key, action: (key: Key) => void): EventController;\n    onKeyDown(action: (key: Key) => void): EventController;\n    onKeyPress(key: Key, action: (key: Key) => void): EventController;\n    onKeyPress(action: (key: Key) => void): EventController;\n    onKeyPressRepeat(k: Key, action: (k: Key) => void): EventController;\n    onKeyPressRepeat(action: (k: Key) => void): EventController;\n    onKeyRelease(k: Key, action: (k: Key) => void): EventController;\n    onKeyRelease(action: (k: Key) => void): EventController;\n    onCharInput(action: (ch: string) => void): EventController;\n    onMouseDown(action: (m: MouseButton) => void): EventController;\n    onMouseDown(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    onMousePress(action: (m: MouseButton) => void): EventController;\n    onMousePress(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    onMouseRelease(action: (m: MouseButton) => void): EventController;\n    onMouseRelease(\n        button: MouseButton,\n        action: (m: MouseButton) => void,\n    ): EventController;\n    onMouseMove(action: (pos: Vec2, delta: Vec2) => void): EventController;\n    onTouchStart(action: (pos: Vec2, t: Touch) => void): EventController;\n    onTouchMove(action: (pos: Vec2, t: Touch) => void): EventController;\n    onTouchEnd(action: (pos: Vec2, t: Touch) => void): EventController;\n    onScroll(action: (delta: Vec2) => void): EventController;\n    onGamepadButtonDown(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    onGamepadButtonDown(\n        action: (btn: GamepadButton) => GamepadButton,\n    ): EventController;\n    onGamepadButtonPress(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    onGamepadButtonPress(\n        action: (btn: GamepadButton) => GamepadButton,\n    ): EventController;\n    onGamepadButtonRelease(\n        btn: GamepadButton,\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    onGamepadButtonRelease(\n        action: (btn: GamepadButton) => void,\n    ): EventController;\n    onGamepadStick(\n        stick: GamepadStick,\n        action: (value: Vec2) => void,\n    ): EventController;\n}\n\n/**\n * The basic unit of object in Kaboom. The player, a butterfly, a tree, or even a piece of text.\n *\n * @group Game Obj\n */\nexport type GameObj<T = any> = GameObjRaw & MergeComps<T>;\n\nexport type SceneName = string;\nexport type SceneDef = (...args: any) => void;\n\nexport type GetOpt = {\n    /**\n     * Recursively get all children and their descendents.\n     */\n    recursive?: boolean;\n    /**\n     * Live update the returned list every time object is added / removed.\n     */\n    liveUpdate?: boolean;\n};\n\n/**\n * Screen recording control handle.\n */\nexport interface Recording {\n    /**\n     * Pause the recording.\n     */\n    pause(): void;\n    /**\n     * Resume the recording.\n     */\n    resume(): void;\n    /**\n     * Stop the recording and get the video data as mp4 Blob.\n     *\n     * @since v3000.0\n     */\n    stop(): Promise<Blob>;\n    /**\n     * Stop the recording and downloads the file as mp4. Trying to resume later will lead to error.\n     */\n    download(filename?: string): void;\n}\n\n/**\n * Frame-based animation configuration.\n */\nexport type SpriteAnim = number | {\n    /**\n     * The starting frame.\n     */\n    from: number;\n    /**\n     * The end frame.\n     */\n    to: number;\n    /**\n     * If this anim should be played in loop.\n     */\n    loop?: boolean;\n    /**\n     * When looping should it move back instead of go to start frame again.\n     */\n    pingpong?: boolean;\n    /**\n     * This anim's speed in frames per second.\n     */\n    speed?: number;\n};\n\n/**\n * Sprite animation configuration when playing.\n */\nexport interface SpriteAnimPlayOpt {\n    /**\n     * If this anim should be played in loop.\n     */\n    loop?: boolean;\n    /**\n     * When looping should it move back instead of go to start frame again.\n     */\n    pingpong?: boolean;\n    /**\n     * This anim's speed in frames per second.\n     */\n    speed?: number;\n    /**\n     * Runs when this animation ends.\n     */\n    onEnd?: () => void;\n}\n\nexport interface PeditFile {\n    width: number;\n    height: number;\n    frames: string[];\n    anims: SpriteAnims;\n}\n\n/**\n * A dict of name <-> animation.\n */\nexport type SpriteAnims = Record<string, SpriteAnim>;\n\n// TODO: support frameWidth and frameHeight as alternative to slice\n/**\n * Sprite loading configuration.\n */\nexport interface LoadSpriteOpt {\n    /**\n     * If the defined area contains multiple sprites, how many frames are in the area hozizontally.\n     */\n    sliceX?: number;\n    /**\n     * If the defined area contains multiple sprites, how many frames are in the area vertically.\n     */\n    sliceY?: number;\n    /**\n     * 9 slice sprite for proportional scaling.\n     *\n     * @since v3000.0\n     */\n    slice9?: NineSlice;\n    /**\n     * Individual frames.\n     *\n     * @since v3000.0\n     */\n    frames?: Quad[];\n    /**\n     * Animation configuration.\n     */\n    anims?: SpriteAnims;\n}\n\nexport type NineSlice = {\n    /**\n     * The width of the 9-slice's left column.\n     */\n    left: number;\n    /**\n     * The width of the 9-slice's right column.\n     */\n    right: number;\n    /**\n     * The height of the 9-slice's top row.\n     */\n    top: number;\n    /**\n     * The height of the 9-slice's bottom row.\n     */\n    bottom: number;\n};\n\nexport type SpriteAtlasData = Record<string, SpriteAtlasEntry>;\n\n/**\n * A sprite in a sprite atlas.\n */\nexport type SpriteAtlasEntry = LoadSpriteOpt & {\n    /**\n     * X position of the top left corner.\n     */\n    x: number;\n    /**\n     * Y position of the top left corner.\n     */\n    y: number;\n    /**\n     * Sprite area width.\n     */\n    width: number;\n    /**\n     * Sprite area height.\n     */\n    height: number;\n};\n\n// TODO: use PromiseLike or extend Promise?\nexport declare class Asset<D> {\n    loaded: boolean;\n    data: D | null;\n    error: Error | null;\n    constructor(loader: Promise<D>);\n    static loaded<D>(data: D): Asset<D>;\n    onLoad(action: (data: D) => void): Asset<D>;\n    onError(action: (err: Error) => void): Asset<D>;\n    onFinish(action: () => void): Asset<D>;\n    then(action: (data: D) => void): Asset<D>;\n    catch(action: (err: Error) => void): Asset<D>;\n    finally(action: () => void): Asset<D>;\n}\n\nexport type LoadSpriteSrc = string | ImageSource;\n\nexport type AsepriteData = {\n    frames: Array<{\n        frame: {\n            x: number;\n            y: number;\n            w: number;\n            h: number;\n        };\n    }>;\n    meta: {\n        size: { w: number; h: number };\n        frameTags: Array<{\n            name: string;\n            from: number;\n            to: number;\n            direction: \"forward\" | \"reverse\" | \"pingpong\";\n        }>;\n    };\n};\n\nexport declare class SpriteData {\n    tex: Texture;\n    frames: Quad[];\n    anims: SpriteAnims;\n    /**\n     * @since v3001.0\n     */\n    width: number;\n    /**\n     * @since v3001.0\n     */\n    height: number;\n    slice9: NineSlice | null;\n    constructor(tex: Texture, frames?: Quad[], anims?: SpriteAnims);\n    static from(src: LoadSpriteSrc, opt?: LoadSpriteOpt): Promise<SpriteData>;\n    static fromImage(data: ImageSource, opt?: LoadSpriteOpt): SpriteData;\n    static fromURL(url: string, opt?: LoadSpriteOpt): Promise<SpriteData>;\n}\n\nexport declare class SoundData {\n    buf: AudioBuffer;\n    constructor(buf: AudioBuffer);\n    static fromArrayBuffer(buf: ArrayBuffer): Promise<SoundData>;\n    static fromURL(url: string): Promise<SoundData>;\n}\n\nexport type MusicData = string;\n\nexport interface LoadFontOpt {\n    filter?: TexFilter;\n    outline?: number | Outline;\n    /**\n     * The size to load the font in (default 64).\n     *\n     * @since v3001.0\n     */\n    size?: number;\n}\n\nexport interface LoadBitmapFontOpt {\n    chars?: string;\n    filter?: TexFilter;\n    outline?: number;\n}\n\nexport declare class FontData {\n    fontface: FontFace;\n    filter: TexFilter;\n    outline: Outline | null;\n}\n\nexport type BitmapFontData = GfxFont;\nexport type ShaderData = Shader;\n\n// TODO: enable setting on load, make part of SoundData\n/**\n * Audio play configurations.\n */\nexport interface AudioPlayOpt {\n    /**\n     * If audio should start out paused.\n     *\n     * @since v3000.0\n     */\n    paused?: boolean;\n    /**\n     * If audio should be played again from start when its ended.\n     */\n    loop?: boolean;\n    /**\n     * Volume of audio. 1.0 means full volume, 0.5 means half volume.\n     */\n    volume?: number;\n    /**\n     * Playback speed. 1.0 means normal playback speed, 2.0 means twice as fast.\n     */\n    speed?: number;\n    /**\n     * Detune the sound. Every 100 means a semitone.\n     *\n     * @example\n     * ```js\n     * // play a random note in the octave\n     * play(\"noteC\", {\n     *     detune: randi(0, 12) * 100,\n     * })\n     * ```\n     */\n    detune?: number;\n    /**\n     * The start time, in seconds.\n     */\n    seek?: number;\n}\n\nexport interface AudioPlay {\n    /**\n     * Start playing audio.\n     *\n     * @since v3000.0\n     */\n    play(time?: number): void;\n    /**\n     * Seek time.\n     *\n     * @since v3000.0\n     */\n    seek(time: number): void;\n    /**\n     * Stop the sound.\n     *\n     * @since v3001.0\n     */\n    stop(): void;\n    /**\n     * If the sound is paused.\n     *\n     * @since v2000.1\n     */\n    paused: boolean;\n    /**\n     * Playback speed of the sound. 1.0 means normal playback speed, 2.0 means twice as fast.\n     */\n    speed: number;\n    /**\n     * Detune the sound. Every 100 means a semitone.\n     *\n     * @example\n     * ```js\n     * // tune down a semitone\n     * music.detune = -100\n     *\n     * // tune up an octave\n     * music.detune = 1200\n     * ```\n     */\n    detune: number;\n    /**\n     * Volume of the sound. 1.0 means full volume, 0.5 means half volume.\n     */\n    volume: number;\n    /**\n     * If the audio should start again when it ends.\n     */\n    loop: boolean;\n    /**\n     * The current playing time (not accurate if speed is changed).\n     */\n    time(): number;\n    /**\n     * The total duration.\n     */\n    duration(): number;\n    /**\n     * Register an event that runs when audio ends.\n     *\n     * @since v3000.0\n     */\n    onEnd(action: () => void): EventController;\n    then(action: () => void): EventController;\n}\n\nexport declare class Shader {\n    ctx: GfxCtx;\n    glProgram: WebGLProgram;\n    constructor(ctx: GfxCtx, vert: string, frag: string, attribs: string[]);\n    bind();\n    unbind();\n    send(uniform: Uniform);\n    free();\n}\n\nexport type TextureOpt = {\n    filter?: TexFilter;\n    wrap?: TexWrap;\n};\n\nexport type ImageSource = Exclude<TexImageSource, VideoFrame>;\n\ntype GfxCtx = any;\n\nexport declare class Texture {\n    ctx: GfxCtx;\n    src: null | ImageSource;\n    glTex: WebGLTexture;\n    width: number;\n    height: number;\n    constructor(ctx: GfxCtx, w: number, h: number, opt?: TextureOpt);\n    static fromImage(ctx: GfxCtx, img: ImageSource, opt?: TextureOpt): Texture;\n    update(img: ImageSource, x?: number, y?: number);\n    bind();\n    unbind();\n    /**\n     * Frees up texture memory. Call this once the texture is no longer being used to avoid memory leaks.\n     */\n    free(): void;\n}\n\nexport declare class FrameBuffer {\n    ctx: GfxCtx;\n    tex: Texture;\n    glFramebuffer: WebGLFramebuffer;\n    glRenderbuffer: WebGLRenderbuffer;\n    constructor(ctx: GfxCtx, w: number, h: number, opt?: TextureOpt);\n    width: number;\n    height: number;\n    toImageData(): ImageData;\n    toDataURL(): string;\n    clear(): void;\n    draw(action: () => void): void;\n    bind(): void;\n    unbind(): void;\n    free(): void;\n}\n\nexport type Canvas = {\n    width: number;\n    height: number;\n    toImageData(): ImageData;\n    toDataURL(): string;\n    clear(): void;\n    draw(action: () => void): void;\n    free(): void;\n};\n\nexport interface GfxFont {\n    tex: Texture;\n    map: Record<string, Quad>;\n    size: number;\n}\n\nexport interface Vertex {\n    pos: Vec2;\n    uv: Vec2;\n    color: Color;\n    opacity: number;\n}\n\n/**\n * Texture scaling filter. \"nearest\" is mainly for sharp pixelated scaling, \"linear\" means linear interpolation.\n */\nexport type TexFilter = \"nearest\" | \"linear\";\nexport type TexWrap = \"repeat\" | \"clampToEdge\";\n\n/**\n * Common render properties.\n */\nexport interface RenderProps {\n    pos?: Vec2;\n    scale?: Vec2 | number;\n    angle?: number;\n    color?: Color;\n    opacity?: number;\n    fixed?: boolean;\n    shader?: string | ShaderData | Asset<ShaderData>;\n    uniform?: Uniform;\n    outline?: Outline;\n}\n\nexport type DrawTextureOpt = RenderProps & {\n    tex: Texture;\n    width?: number;\n    height?: number;\n    tiled?: boolean;\n    flipX?: boolean;\n    flipY?: boolean;\n    quad?: Quad;\n    anchor?: Anchor | Vec2;\n};\n\n/**\n * How the sprite should look like.\n */\nexport type DrawSpriteOpt = RenderProps & {\n    /**\n     * The sprite name in the asset manager, or the raw sprite data.\n     */\n    sprite: string | SpriteData | Asset<SpriteData>;\n    /**\n     * If the sprite is loaded with multiple frames, or sliced, use the frame option to specify which frame to draw.\n     */\n    frame?: number;\n    /**\n     * Width of sprite. If `height` is not specified it'll stretch with aspect ratio. If `tiled` is set to true it'll tiled to the specified width horizontally.\n     */\n    width?: number;\n    /**\n     * Height of sprite. If `width` is not specified it'll stretch with aspect ratio. If `tiled` is set to true it'll tiled to the specified width vertically.\n     */\n    height?: number;\n    /**\n     * When set to true, `width` and `height` will not scale the sprite but instead render multiple tiled copies of them until the specified width and height. Useful for background texture pattern etc.\n     */\n    tiled?: boolean;\n    /**\n     * If flip the texture horizontally.\n     */\n    flipX?: boolean;\n    /**\n     * If flip the texture vertically.\n     */\n    flipY?: boolean;\n    /**\n     * The sub-area to render from the texture, by default it'll render the whole `quad(0, 0, 1, 1)`\n     */\n    quad?: Quad;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n};\n\nexport type DrawUVQuadOpt = RenderProps & {\n    /**\n     * Width of the UV quad.\n     */\n    width: number;\n    /**\n     * Height of the UV quad.\n     */\n    height: number;\n    /**\n     * If flip the texture horizontally.\n     */\n    flipX?: boolean;\n    /**\n     * If flip the texture vertically.\n     */\n    flipY?: boolean;\n    /**\n     * The texture to sample for this quad.\n     */\n    tex?: Texture;\n    /**\n     * The texture sampling area.\n     */\n    quad?: Quad;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n};\n\n/**\n * How the rectangle should look like.\n */\nexport type DrawRectOpt = RenderProps & {\n    /**\n     * Width of the rectangle.\n     */\n    width: number;\n    /**\n     * Height of the rectangle.\n     */\n    height: number;\n    /**\n     * Use gradient instead of solid color.\n     *\n     * @since v3000.0\n     */\n    gradient?: [Color, Color];\n    /**\n     * If the gradient should be horizontal.\n     *\n     * @since v3000.0\n     */\n    horizontal?: boolean;\n    /**\n     * If fill the shape with color (set this to false if you only want an outline).\n     */\n    fill?: boolean;\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n};\n\n/**\n * How the line should look like.\n */\nexport type DrawLineOpt = Omit<RenderProps, \"angle\" | \"scale\"> & {\n    /**\n     * Starting point of the line.\n     */\n    p1: Vec2;\n    /**\n     * Ending point of the line.\n     */\n    p2: Vec2;\n    /**\n     * The width, or thickness of the line,\n     */\n    width?: number;\n};\n\nexport type LineJoin =\n    | \"none\"\n    | \"round\"\n    | \"bevel\"\n    | \"miter\";\n\n/**\n * How the lines should look like.\n */\nexport type DrawLinesOpt = Omit<RenderProps, \"angle\" | \"scale\"> & {\n    /**\n     * The points that should be connected with a line.\n     */\n    pts: Vec2[];\n    /**\n     * The width, or thickness of the lines,\n     */\n    width?: number;\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n    /**\n     * Line join style (default \"none\").\n     */\n    join?: LineJoin;\n};\n\nexport type DrawCurveOpt = RenderProps & {\n    /**\n     * The amount of line segments to draw.\n     */\n    segments?: number;\n    /**\n     * The width of the line.\n     */\n    width?: number;\n};\n\nexport type DrawBezierOpt = DrawCurveOpt & {\n    /**\n     * The first point.\n     */\n    pt1: Vec2;\n    /**\n     * The the first control point.\n     */\n    pt2: Vec2;\n    /**\n     * The the second control point.\n     */\n    pt3: Vec2;\n    /**\n     * The second point.\n     */\n    pt4: Vec2;\n};\n\n/**\n * How the triangle should look like.\n */\nexport type DrawTriangleOpt = RenderProps & {\n    /**\n     * First point of triangle.\n     */\n    p1: Vec2;\n    /**\n     * Second point of triangle.\n     */\n    p2: Vec2;\n    /**\n     * Third point of triangle.\n     */\n    p3: Vec2;\n    /**\n     * If fill the shape with color (set this to false if you only want an outline).\n     */\n    fill?: boolean;\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n};\n\n/**\n * How the circle should look like.\n */\nexport type DrawCircleOpt = Omit<RenderProps, \"angle\"> & {\n    /**\n     * Radius of the circle.\n     */\n    radius: number;\n    /**\n     * Starting angle.\n     */\n    start?: number;\n    /**\n     * Ending angle.\n     */\n    end?: number;\n    /**\n     * If fill the shape with color (set this to false if you only want an outline).\n     */\n    fill?: boolean;\n    /**\n     * Use gradient instead of solid color.\n     *\n     * @since v3000.0\n     */\n    gradient?: [Color, Color];\n    /**\n     * Multiplier for circle vertices resolution (default 1)\n     */\n    resolution?: number;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n};\n\n/**\n * How the ellipse should look like.\n */\nexport type DrawEllipseOpt = RenderProps & {\n    /**\n     * The horizontal radius.\n     */\n    radiusX: number;\n    /**\n     * The vertical radius.\n     */\n    radiusY: number;\n    /**\n     * Starting angle.\n     */\n    start?: number;\n    /**\n     * Ending angle.\n     */\n    end?: number;\n    /**\n     * If fill the shape with color (set this to false if you only want an outline).\n     */\n    fill?: boolean;\n    /**\n     * Use gradient instead of solid color.\n     *\n     * @since v3000.0\n     */\n    gradient?: [Color, Color];\n    /**\n     * Multiplier for circle vertices resolution (default 1)\n     */\n    resolution?: number;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n};\n\n/**\n * How the polygon should look like.\n */\nexport type DrawPolygonOpt = RenderProps & {\n    /**\n     * The points that make up the polygon\n     */\n    pts: Vec2[];\n    /**\n     * If fill the shape with color (set this to false if you only want an outline).\n     */\n    fill?: boolean;\n    /**\n     * Manual triangulation.\n     */\n    indices?: number[];\n    /**\n     * The center point of transformation in relation to the position.\n     */\n    offset?: Vec2;\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n    /**\n     * The color of each vertex.\n     *\n     * @since v3000.0\n     */\n    colors?: Color[];\n    /**\n     * The uv of each vertex.\n     *\n     * @since v3001.0\n     */\n    uv?: Vec2[];\n    /**\n     * The texture if uv are supplied.\n     *\n     * @since v3001.0\n     */\n    tex?: Texture;\n    /**\n     * Triangulate concave polygons.\n     *\n     * @since v3001.0\n     */\n    triangulate?: boolean;\n};\n\nexport interface Outline {\n    /**\n     * The width, or thinkness of the line.\n     */\n    width?: number;\n    /**\n     * The color of the line.\n     */\n    color?: Color;\n    /**\n     * Line join.\n     *\n     * @since v3000.0\n     */\n    join?: LineJoin;\n}\n\n/**\n * How the text should be aligned.\n *\n * @group Draw\n */\nexport type TextAlign =\n    | \"center\"\n    | \"left\"\n    | \"right\";\n\n/**\n * How the text should look like.\n *\n * @group Draw\n */\nexport type DrawTextOpt = RenderProps & {\n    /**\n     * The text to render.\n     */\n    text: string;\n    /**\n     * The name of font to use.\n     */\n    font?:\n        | string\n        | FontData\n        | Asset<FontData>\n        | BitmapFontData\n        | Asset<BitmapFontData>;\n    /**\n     * The size of text (the height of each character).\n     */\n    size?: number;\n    /**\n     * Text alignment (default \"left\")\n     *\n     * @since v3000.0\n     */\n    align?: TextAlign;\n    /**\n     * The maximum width. Will wrap word around if exceed.\n     */\n    width?: number;\n    /**\n     * The gap between each line (only available for bitmap fonts).\n     *\n     * @since v2000.2\n     */\n    lineSpacing?: number;\n    /**\n     * The gap between each character (only available for bitmap fonts).\n     *\n     * @since v2000.2\n     */\n    letterSpacing?: number;\n    /**\n     * The anchor point, or the pivot point. Default to \"topleft\".\n     */\n    anchor?: Anchor | Vec2;\n    /**\n     * Transform the pos, scale, rotation or color for each character based on the index or char (only available for bitmap fonts).\n     *\n     * @since v2000.1\n     */\n    transform?: CharTransform | CharTransformFunc;\n    /**\n     * Stylesheet for styled chunks, in the syntax of \"this is a [stylename]styled[/stylename] word\" (only available for bitmap fonts).\n     *\n     * @since v2000.2\n     */\n    styles?: Record<string, CharTransform | CharTransformFunc>;\n};\n\n/**\n * Formatted text with info on how and where to render each character.\n */\nexport type FormattedText = {\n    width: number;\n    height: number;\n    chars: FormattedChar[];\n    opt: DrawTextOpt;\n};\n\n/**\n * One formated character.\n */\nexport interface FormattedChar {\n    ch: string;\n    tex: Texture;\n    width: number;\n    height: number;\n    quad: Quad;\n    pos: Vec2;\n    scale: Vec2;\n    angle: number;\n    color: Color;\n    opacity: number;\n}\n\n/**\n * A function that returns a character transform config. Useful if you're generating dynamic styles.\n */\nexport type CharTransformFunc = (idx: number, ch: string) => CharTransform;\n\n/**\n * Describes how to transform each character.\n *\n * @group Component Options\n */\nexport interface CharTransform {\n    pos?: Vec2;\n    scale?: Vec2 | number;\n    angle?: number;\n    color?: Color;\n    opacity?: number;\n}\n\n/**\n * @group Draw\n */\nexport type Cursor =\n    | string\n    | \"auto\"\n    | \"default\"\n    | \"none\"\n    | \"context-menu\"\n    | \"help\"\n    | \"pointer\"\n    | \"progress\"\n    | \"wait\"\n    | \"cell\"\n    | \"crosshair\"\n    | \"text\"\n    | \"vertical-text\"\n    | \"alias\"\n    | \"copy\"\n    | \"move\"\n    | \"no-drop\"\n    | \"not-allowed\"\n    | \"grab\"\n    | \"grabbing\"\n    | \"all-scroll\"\n    | \"col-resize\"\n    | \"row-resize\"\n    | \"n-resize\"\n    | \"e-resize\"\n    | \"s-resize\"\n    | \"w-resize\"\n    | \"ne-resize\"\n    | \"nw-resize\"\n    | \"se-resize\"\n    | \"sw-resize\"\n    | \"ew-resize\"\n    | \"ns-resize\"\n    | \"nesw-resize\"\n    | \"nwse-resize\"\n    | \"zoom-int\"\n    | \"zoom-out\";\n\n/**\n * @group Draw\n */\nexport type Anchor =\n    | \"topleft\"\n    | \"top\"\n    | \"topright\"\n    | \"left\"\n    | \"center\"\n    | \"right\"\n    | \"botleft\"\n    | \"bot\"\n    | \"botright\";\n\n/**\n * @group Math\n */\nexport type Vec2Args =\n    | [number, number]\n    | [number]\n    | [Vec2]\n    | [number | Vec2]\n    | [];\n\n/**\n * A 2D vector.\n *\n * @group Math\n */\nexport declare class Vec2 {\n    x: number;\n    y: number;\n    static LEFT: Vec2;\n    static RIGHT: Vec2;\n    static UP: Vec2;\n    static DOWN: Vec2;\n    static fromAngle(deg: number): Vec2;\n    constructor(x: number, y: number);\n    constructor(xy: number);\n    constructor();\n    clone(): Vec2;\n    /**\n     * Returns the addition with another vector.\n     */\n    add(p: Vec2): Vec2;\n    add(x: number, y: number): Vec2;\n    /**\n     * Returns the subtraction with another vector.\n     */\n    sub(p: Vec2): Vec2;\n    sub(x: number, y: number): Vec2;\n    /**\n     * Scale by another vector, or a single number.\n     */\n    scale(p: Vec2): Vec2;\n    scale(s: number): Vec2;\n    scale(sx: number, sy: number): Vec2;\n    /**\n     * Get the dot product with another vector.\n     */\n    dot(p: Vec2): number;\n    /**\n     * Get the cross product with another vector.\n     *\n     * @since v3000.0\n     */\n    cross(p2: Vec2): number;\n    /**\n     * Get distance between another vector.\n     */\n    dist(p: Vec2): number;\n    /**\n     * Get squared distance between another vector.\n     *\n     * @since v3000.0\n     */\n    sdist(p: Vec2): number;\n    len(): number;\n    /**\n     * Get squared length of a vector.\n     *\n     * @since v3000.0\n     */\n    slen(): number;\n    /**\n     * Get the unit vector (length of 1).\n     */\n    unit(): Vec2;\n    /**\n     * Get the perpendicular vector.\n     */\n    normal(): Vec2;\n    /**\n     * Get the reflection of a vector with a normal.\n     *\n     * @since v3000.0\n     */\n    reflect(normal: Vec2): Vec2;\n    /**\n     * Get the projection of a vector onto another vector.\n     *\n     * @since v3000.0\n     */\n    project(on: Vec2): Vec2;\n    /**\n     * Get the rejection of a vector onto another vector.\n     *\n     * @since v3000.0\n     */\n    reject(on: Vec2): Vec2;\n    /**\n     * Get the angle of the vector from p towards this.\n     */\n    angle(p: Vec2): number;\n    /**\n     * Get the angle between this vector and another vector.\n     *\n     * @since v3000.0\n     */\n    angleBetween(...args: any): number;\n    /**\n     * Linear interpolate to a destination vector (for positions).\n     */\n    lerp(p: Vec2, t: number): Vec2;\n    /**\n     * Spherical linear interpolate to a destination vector (for rotations).\n     *\n     * @since v3000.0\n     */\n    slerp(p: Vec2, t: number): Vec2;\n    /**\n     * If both x and y is 0.\n     *\n     * @since v3000.0\n     */\n    isZero(): boolean;\n    /**\n     * To n precision floating point.\n     */\n    toFixed(n: number): Vec2;\n    /**\n     * Multiply by a Mat4.\n     *\n     * @since v3000.0\n     */\n    transform(n: Mat4): Vec2;\n    bbox(): Rect;\n    eq(p: Vec2): boolean;\n    toString(): string;\n}\n\n/**\n * @group Math\n */\nexport declare class Mat4 {\n    m: number[];\n    constructor(m?: number[]);\n    static translate(p: Vec2): Mat4;\n    static scale(s: Vec2): Mat4;\n    static rotateX(a: number): Mat4;\n    static rotateY(a: number): Mat4;\n    static rotateZ(a: number): Mat4;\n    clone(): Mat4;\n    mult(other: Mat4): Mat4;\n    multVec2(p: Vec2): Vec2;\n    translate(p: Vec2): Mat4;\n    scale(s: Vec2): Mat4;\n    rotate(a: number): Mat4;\n    getTranslation(): Vec2;\n    getScale(): Vec2;\n    getRotation(): number;\n    getSkew(): Vec2;\n    invert(): Mat4;\n    toString(): string;\n}\n\n/**\n * 0-255 RGBA color.\n *\n * @group Math\n */\nexport declare class Color {\n    /**\n     * Red (0-255).\n     */\n    r: number;\n    /**\n     * Green (0-255).\n     */\n    g: number;\n    /**\n     * Blue (0-255).\n     */\n    b: number;\n    constructor(r: number, g: number, b: number);\n    static fromArray(arr: number[]): Color;\n    static fromHSL(h: number, s: number, l: number): Color;\n    /**\n     * Create color from hex string or literal.\n     *\n     * @since v3000.0\n     *\n     * @example\n     * ```js\n     * Color.fromHex(0xfcef8d)\n     * Color.fromHex(\"#5ba675\")\n     * Color.fromHex(\"d46eb3\")\n     * ```\n     */\n    static fromHex(hex: number | string): Color;\n    static RED: Color;\n    static GREEN: Color;\n    static BLUE: Color;\n    static YELLOW: Color;\n    static MAGENTA: Color;\n    static CYAN: Color;\n    static WHITE: Color;\n    static BLACK: Color;\n    clone(): Color;\n    /**\n     * Lighten the color (adds RGB by n).\n     */\n    lighten(n: number): Color;\n    /**\n     * Darkens the color (subtracts RGB by n).\n     */\n    darken(n: number): Color;\n    invert(): Color;\n    mult(other: Color): Color;\n    /**\n     * Linear interpolate to a destination color.\n     *\n     * @since v3000.0\n     */\n    lerp(dest: Color, t: number): Color;\n    eq(c: Color): boolean;\n    /**\n     * Convert color into HSL format.\n     *\n     * @since v3001.0\n     */\n    toHSL(): [number, number, number];\n    toString(): string;\n    /**\n     * Return the hex string of color.\n     *\n     * @since v3000.0\n     */\n    toHex(): string;\n    /**\n     * Return the color converted to an array.\n     *\n     * @since v3001.0\n     */\n    toArray(): Array<number>;\n}\n\n/**\n * @group Math\n */\nexport declare class Quad {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    constructor(x: number, y: number, w: number, h: number);\n    scale(q: Quad): Quad;\n    pos(): Vec2;\n    clone(): Quad;\n    eq(q: Quad): boolean;\n}\n\n/**\n * @group Math\n */\nexport type LerpValue =\n    | number\n    | Vec2\n    | Color;\n\n/**\n * @group Math\n */\nexport type RNGValue =\n    | number\n    | Vec2\n    | Color;\n\n/**\n * @group Math\n */\nexport type ShapeType =\n    | Vec2\n    | Circle\n    | Ellipse\n    | Line\n    | Rect\n    | Polygon;\n\n/**\n * @group Math\n */\nexport type RaycastHit = {\n    fraction: number;\n    normal: Vec2;\n    point: Vec2;\n    gridPos?: Vec2;\n    object?: GameObj;\n};\n\n/**\n * @group Math\n */\nexport type RaycastResult = RaycastHit | null;\n\n/**\n * @group Math\n */\nexport declare class Rect {\n    pos: Vec2;\n    width: number;\n    height: number;\n    constructor(pos: Vec2, width: number, height: number);\n    static fromPoints(p1: Vec2, p2: Vec2): Rect;\n    center(): Vec2;\n    points(): [Vec2, Vec2, Vec2, Vec2];\n    transform(m: Mat4): Polygon;\n    bbox(): Rect;\n    area(): number;\n    clone(): Rect;\n    distToPoint(p: Vec2): number;\n    sdistToPoint(p: Vec2): number;\n    collides(shape: ShapeType): boolean;\n    contains(point: Vec2): boolean;\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n}\n\n/**\n * @group Math\n */\nexport declare class Line {\n    p1: Vec2;\n    p2: Vec2;\n    constructor(p1: Vec2, p2: Vec2);\n    transform(m: Mat4): Line;\n    bbox(): Rect;\n    area(): number;\n    clone(): Line;\n    collides(shape: ShapeType): boolean;\n    contains(point: Vec2): boolean;\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n}\n\n/**\n * @group Math\n */\nexport declare class Circle {\n    center: Vec2;\n    radius: number;\n    constructor(pos: Vec2, radius: number);\n    transform(m: Mat4): Ellipse;\n    bbox(): Rect;\n    area(): number;\n    clone(): Circle;\n    collides(shape: ShapeType): boolean;\n    contains(point: Vec2): boolean;\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n}\n\n/**\n * @group Math\n */\nexport declare class Ellipse {\n    center: Vec2;\n    radiusX: number;\n    radiusY: number;\n    constructor(pos: Vec2, rx: number, ry: number);\n    transform(m: Mat4): Ellipse;\n    bbox(): Rect;\n    area(): number;\n    clone(): Ellipse;\n    collides(shape: ShapeType): boolean;\n    contains(point: Vec2): boolean;\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n}\n\n/**\n * @group Math\n */\nexport declare class Polygon {\n    pts: Vec2[];\n    constructor(pts: Vec2[]);\n    transform(m: Mat4): Polygon;\n    bbox(): Rect;\n    area(): number;\n    clone(): Polygon;\n    collides(shape: ShapeType): boolean;\n    contains(point: Vec2): boolean;\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n}\n\n/**\n * @group Math\n */\nexport type Point = Vec2;\n\n/**\n * @group Math\n */\nexport declare class RNG {\n    seed: number;\n    constructor(seed: number);\n    gen(): number;\n    genNumber(a: number, b: number): number;\n    genVec2(a: Vec2, b?: Vec2): Vec2;\n    genColor(a: Color, b: Color): Color;\n    genAny<T = RNGValue>(...args: T[]): T;\n}\n\n/**\n * @group Component System\n */\nexport interface Comp {\n    /**\n     * Component ID (if left out won't be treated as a comp).\n     */\n    id?: Tag;\n    /**\n     * What other comps this comp depends on.\n     */\n    require?: Tag[];\n    /**\n     * Event that runs when host game obj is added to scene.\n     */\n    add?: () => void;\n    /**\n     * Event that runs every frame.\n     */\n    update?: () => void;\n    /**\n     * Event that runs every frame after update.\n     */\n    draw?: () => void;\n    /**\n     * Event that runs when obj is removed from scene.\n     */\n    destroy?: () => void;\n    /**\n     * Debug info for inspect mode.\n     */\n    inspect?: () => string | void;\n    /**\n     * Draw debug info in inspect mode\n     *\n     * @since v3000.0\n     */\n    drawInspect?: () => void;\n}\n\n/**\n * @group Game Obj\n */\nexport type GameObjID = number;\n\n/**\n * A component without own properties.\n *\n * @group Component System\n */\nexport type EmptyComp = { id: string } & Comp;\n\n/**\n * @group Component System\n */\nexport interface PosComp extends Comp {\n    /**\n     * Object's current world position.\n     */\n    pos: Vec2;\n    /**\n     * Move how many pixels per second. If object is 'solid', it won't move into other 'solid' objects.\n     */\n    move(xVel: number, yVel: number): void;\n    move(vel: Vec2): void;\n    /**\n     * Move how many pixels, without multiplying dt, but still checking for 'solid'.\n     */\n    moveBy(dx: number, dy: number): void;\n    moveBy(d: Vec2): void;\n    /**\n     * Move to a spot with a speed (pixels per second), teleports if speed is not given.\n     */\n    moveTo(dest: Vec2, speed?: number): void;\n    moveTo(x: number, y: number, speed?: number): void;\n    /**\n     * Get position on screen after camera transform.\n     */\n    screenPos(): Vec2;\n    /**\n     * Get position on screen after camera / parent transform.\n     */\n    worldPos(): Vec2;\n}\n\n/**\n * @group Component System\n */\nexport interface ScaleComp extends Comp {\n    scale: Vec2;\n    scaleTo(s: number): void;\n    scaleTo(s: Vec2): void;\n    scaleTo(sx: number, sy: number): void;\n    scaleBy(s: number): void;\n    scaleBy(s: Vec2): void;\n    scaleBy(sx: number, sy: number): void;\n}\n\n/**\n * @group Component System\n */\nexport interface RotateComp extends Comp {\n    /**\n     * Angle in degrees.\n     */\n    angle: number;\n    /**\n     * Rotate in degrees.\n     */\n    rotateBy(angle: number): void;\n    /**\n     * Rotate to a degree (like directly assign to .angle)\n     *\n     * @since v3000.0\n     */\n    rotateTo(s: number): void;\n}\n\n/**\n * @group Component System\n */\nexport interface ColorComp extends Comp {\n    color: Color;\n}\n\n/**\n * @group Component System\n */\nexport interface OpacityComp extends Comp {\n    opacity: number;\n    fadeIn(time?: number, easeFunc?: EaseFunc): TweenController;\n    fadeOut(time?: number, easeFunc?: EaseFunc): TweenController;\n}\n\n/**\n * @group Component System\n */\nexport interface AnchorComp extends Comp {\n    /**\n     * Anchor point for render.\n     */\n    anchor: Anchor | Vec2;\n}\n\n/**\n * @group Component System\n */\nexport interface ZComp extends Comp {\n    /**\n     * Defines the z-index of this game obj\n     */\n    z: number;\n}\n\n/**\n * @group Component System\n */\nexport interface FollowComp extends Comp {\n    follow: {\n        obj: GameObj;\n        offset: Vec2;\n    };\n}\n\n/**\n * @group Component System\n */\nexport interface OffScreenCompOpt {\n    /**\n     * If hide object when out of view.\n     */\n    hide?: boolean;\n    /**\n     * If pause object when out of view.\n     */\n    pause?: boolean;\n    /**\n     * If destroy object when out of view.\n     */\n    destroy?: boolean;\n    /**\n     * The distance when out of view is triggered (default 200).\n     *\n     * @since v3000.0\n     */\n    distance?: number;\n}\n\n/**\n * @group Component System\n */\nexport interface OffScreenComp extends Comp {\n    /**\n     * If object is currently out of view.\n     */\n    isOffScreen(): boolean;\n    /**\n     * Register an event that runs when object goes out of view.\n     */\n    onExitScreen(action: () => void): EventController;\n    /**\n     * Register an event that runs when object enters view.\n     */\n    onEnterScreen(action: () => void): EventController;\n}\n\n/**\n * Collision resolution data.\n *\n * @group Component System\n */\nexport interface Collision {\n    /**\n     * The first game object in the collision.\n     */\n    source: GameObj;\n    /**\n     * The second game object in the collision.\n     */\n    target: GameObj;\n    /**\n     * The displacement source game object have to make to avoid the collision.\n     */\n    displacement: Vec2;\n    /**\n     * If the collision is resolved.\n     */\n    resolved: boolean;\n    /**\n     * Prevent collision resolution if not yet resolved.\n     *\n     * @since v3000.0\n     */\n    preventResolution(): void;\n    /**\n     * If the 2 objects have any overlap, or they're just touching edges.\n     *\n     * @since v3000.0\n     */\n    hasOverlap(): void;\n    /**\n     * Get a new collision with reversed source and target relationship.\n     */\n    reverse(): Collision;\n    /**\n     * If the collision happened (roughly) on the top side.\n     */\n    isTop(): boolean;\n    /**\n     * If the collision happened (roughly) on the bottom side.\n     */\n    isBottom(): boolean;\n    /**\n     * If the collision happened (roughly) on the left side.\n     */\n    isLeft(): boolean;\n    /**\n     * If the collision happened (roughly) on the right side.\n     */\n    isRight(): boolean;\n}\n\n/**\n * @group Component Options\n */\nexport interface AreaCompOpt {\n    /**\n     * The shape of the area (currently only Rect and Polygon is supported).\n     *\n     * @example\n     * ```js\n     * add([\n     *     sprite(\"butterfly\"),\n     *     pos(100, 200),\n     *     // a triangle shape!\n     *     area({ shape: new Polygon([vec2(0), vec2(100), vec2(-100, 100)]) }),\n     * ])\n     * ```\n     */\n    shape?: Shape;\n    /**\n     * Area scale.\n     */\n    scale?: number | Vec2;\n    /**\n     * Area offset.\n     */\n    offset?: Vec2;\n    /**\n     * Cursor on hover.\n     */\n    cursor?: Cursor;\n    /**\n     * If this object should ignore collisions against certain other objects.\n     *\n     * @since v3000.0\n     */\n    collisionIgnore?: Tag[];\n}\n\n/**\n * @group Component System\n */\nexport interface AreaComp extends Comp {\n    /**\n     * Collider area info.\n     */\n    area: {\n        /**\n         * If we use a custom shape over render shape.\n         */\n        shape: Shape | null;\n        /**\n         * Area scale.\n         */\n        scale: Vec2;\n        /**\n         * Area offset.\n         */\n        offset: Vec2;\n        /**\n         * Cursor on hover.\n         */\n        cursor: Cursor | null;\n    };\n    /**\n     * If this object should ignore collisions against certain other objects.\n     *\n     * @since v3000.0\n     */\n    collisionIgnore: Tag[];\n    /**\n     * If was just clicked on last frame.\n     */\n    isClicked(): boolean;\n    /**\n     * If is being hovered on.\n     */\n    isHovering(): boolean;\n    /**\n     * Check collision with another game obj.\n     *\n     * @since v3000.0\n     */\n    checkCollision(other: GameObj<AreaComp>): Collision | null;\n    /**\n     * Get all collisions currently happening.\n     *\n     * @since v3000.0\n     */\n    getCollisions(): Collision[];\n    /**\n     * If is currently colliding with another game obj.\n     */\n    isColliding(o: GameObj<AreaComp>): boolean;\n    /**\n     * If is currently overlapping with another game obj (like isColliding, but will return false if the objects are just touching edges).\n     */\n    isOverlapping(o: GameObj<AreaComp>): boolean;\n    /**\n     * Register an event runs when clicked.\n     *\n     * @since v2000.1\n     */\n    onClick(f: () => void, btn?: MouseButton): void;\n    /**\n     * Register an event runs once when hovered.\n     *\n     * @since v3000.0\n     */\n    onHover(action: () => void): EventController;\n    /**\n     * Register an event runs every frame when hovered.\n     *\n     * @since v3000.0\n     */\n    onHoverUpdate(action: () => void): EventController;\n    /**\n     * Register an event runs once when unhovered.\n     *\n     * @since v3000.0\n     */\n    onHoverEnd(action: () => void): EventController;\n    /**\n     * Register an event runs once when collide with another game obj with certain tag.\n     *\n     * @since v2001.0\n     */\n    onCollide(tag: Tag, f: (obj: GameObj, col?: Collision) => void): void;\n    /**\n     * Register an event runs once when collide with another game obj.\n     *\n     * @since v2000.1\n     */\n    onCollide(f: (obj: GameObj, col?: Collision) => void): void;\n    /**\n     * Register an event runs every frame when collide with another game obj with certain tag.\n     *\n     * @since v3000.0\n     */\n    onCollideUpdate(\n        tag: Tag,\n        f: (obj: GameObj, col?: Collision) => void,\n    ): EventController;\n    /**\n     * Register an event runs every frame when collide with another game obj.\n     *\n     * @since v3000.0\n     */\n    onCollideUpdate(\n        f: (obj: GameObj, col?: Collision) => void,\n    ): EventController;\n    /**\n     * Register an event runs once when stopped colliding with another game obj with certain tag.\n     *\n     * @since v3000.0\n     */\n    onCollideEnd(tag: Tag, f: (obj: GameObj) => void): EventController;\n    /**\n     * Register an event runs once when stopped colliding with another game obj.\n     *\n     * @since v3000.0\n     */\n    onCollideEnd(f: (obj: GameObj) => void): void;\n    /**\n     * If has a certain point inside collider.\n     */\n    hasPoint(p: Vec2): boolean;\n    /**\n     * Push out from another solid game obj if currently overlapping.\n     */\n    resolveCollision(obj: GameObj): void;\n    /**\n     * Get the geometry data for the collider in local coordinate space.\n     *\n     * @since v3000.0\n     */\n    localArea(): Shape;\n    /**\n     * Get the geometry data for the collider in world coordinate space.\n     */\n    worldArea(): Polygon;\n    /**\n     * Get the geometry data for the collider in screen coordinate space.\n     */\n    screenArea(): Polygon;\n}\n\n/**\n * @group Component Options\n */\nexport interface SpriteCompOpt {\n    /**\n     * If the sprite is loaded with multiple frames, or sliced, use the frame option to specify which frame to draw.\n     */\n    frame?: number;\n    /**\n     * If provided width and height, don't stretch but instead render tiled.\n     */\n    tiled?: boolean;\n    /**\n     * Stretch sprite to a certain width.\n     */\n    width?: number;\n    /**\n     * Stretch sprite to a certain height.\n     */\n    height?: number;\n    /**\n     * Play an animation on start.\n     */\n    anim?: string;\n    /**\n     * Speed multiplier for all animations (for the actual fps for an anim use .play(\"anim\", { speed: 10 })).\n     */\n    animSpeed?: number;\n    /**\n     * Flip texture horizontally.\n     */\n    flipX?: boolean;\n    /**\n     * Flip texture vertically.\n     */\n    flipY?: boolean;\n    /**\n     * The rectangular sub-area of the texture to render, default to full texture `quad(0, 0, 1, 1)`.\n     */\n    quad?: Quad;\n    /**\n     * If fill the sprite (useful if you only want to render outline with outline() component).\n     */\n    fill?: boolean;\n}\n\n/**\n * @group Component System\n */\nexport interface SpriteComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * Width for sprite.\n     */\n    width: number;\n    /**\n     * Height for sprite.\n     */\n    height: number;\n    /**\n     * Current frame.\n     */\n    frame: number;\n    /**\n     * The rectangular area of the texture to render.\n     */\n    quad: Quad;\n    /**\n     * Play a piece of anim.\n     */\n    play(anim: string, options?: SpriteAnimPlayOpt): void;\n    /**\n     * Stop current anim.\n     */\n    stop(): void;\n    /**\n     * Get total number of frames.\n     */\n    numFrames(): number;\n    /**\n     * Get current anim name.\n     */\n    curAnim(): string;\n    /**\n     * Speed multiplier for all animations (for the actual fps for an anim use .play(\"anim\", { speed: 10 })).\n     */\n    animSpeed: number;\n    /**\n     * Flip texture horizontally.\n     */\n    flipX: boolean;\n    /**\n     * Flip texture vertically.\n     */\n    flipY: boolean;\n    /**\n     * Register an event that runs when an animation is played.\n     */\n    onAnimStart(action: (anim: string) => void): EventController;\n    /**\n     * Register an event that runs when an animation is ended.\n     */\n    onAnimEnd(action: (anim: string) => void): EventController;\n    /**\n     * @since v3000.0\n     */\n    renderArea(): Rect;\n}\n\n/**\n * @group Component System\n */\nexport interface TextComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * The text to render.\n     */\n    text: string;\n    /**\n     * The text size.\n     */\n    textSize: number;\n    /**\n     * The font to use.\n     */\n    font: string | BitmapFontData;\n    /**\n     * Width of text.\n     */\n    width: number;\n    /**\n     * Height of text.\n     */\n    height: number;\n    /**\n     * Text alignment (\"left\", \"center\" or \"right\", default \"left\").\n     *\n     * @since v3000.0\n     */\n    align: TextAlign;\n    /**\n     * The gap between each line.\n     *\n     * @since v2000.2\n     */\n    lineSpacing: number;\n    /**\n     * The gap between each character.\n     *\n     * @since v2000.2\n     */\n    letterSpacing: number;\n    /**\n     * Transform the pos, scale, rotation or color for each character based on the index or char.\n     *\n     * @since v2000.1\n     */\n    textTransform: CharTransform | CharTransformFunc;\n    /**\n     * Stylesheet for styled chunks, in the syntax of \"this is a [style]text[/style] word\".\n     *\n     * @since v2000.2\n     */\n    textStyles: Record<string, CharTransform | CharTransformFunc>;\n    /**\n     * @since v3000.0\n     */\n    renderArea(): Rect;\n}\n\n/**\n * @group Component Options\n */\nexport interface TextCompOpt {\n    /**\n     * Height of text.\n     */\n    size?: number;\n    /**\n     * The font to use.\n     */\n    font?: string | BitmapFontData;\n    /**\n     * Wrap text to a certain width.\n     */\n    width?: number;\n    /**\n     * Text alignment (\"left\", \"center\" or \"right\", default \"left\").\n     *\n     * @since v3000.0\n     */\n    align?: TextAlign;\n    /**\n     * The gap between each line.\n     *\n     * @since v2000.2\n     */\n    lineSpacing?: number;\n    /**\n     * The gap between each character.\n     *\n     * @since v2000.2\n     */\n    letterSpacing?: number;\n    /**\n     * Transform the pos, scale, rotation or color for each character based on the index or char.\n     *\n     * @since v2000.1\n     */\n    transform?: CharTransform | CharTransformFunc;\n    /**\n     * Stylesheet for styled chunks, in the syntax of \"this is a [style]text[/style] word\".\n     *\n     * @since v2000.2\n     */\n    styles?: Record<string, CharTransform | CharTransformFunc>;\n}\n\n/**\n * @group Component Options\n */\nexport interface RectCompOpt {\n    /**\n     * Radius of the rectangle corners.\n     */\n    radius?: number;\n    /**\n     * If fill the rectangle (useful if you only want to render outline with outline() component).\n     */\n    fill?: boolean;\n}\n\n/**\n * @group Component System\n */\nexport interface RectComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * Width of rectangle.\n     */\n    width: number;\n    /**\n     * Height of rectangle.\n     */\n    height: number;\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n    /**\n     * @since v3000.0\n     */\n    renderArea(): Rect;\n}\n\n/**\n * @group Component Options\n */\nexport type PolygonCompOpt = Omit<DrawPolygonOpt, \"pts\">;\n\n/**\n * Component to draw a polygon.\n *\n * @since v3001.0\n * @group Component System\n */\nexport interface PolygonComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * Points in the polygon.\n     */\n    pts: Vec2[];\n    /**\n     * The radius of each corner.\n     */\n    radius?: number;\n    /**\n     * The color of each vertex.\n     */\n    colors?: Color[];\n    /**\n     * The uv of each vertex.\n     *\n     * @since v3001.0\n     */\n    uv?: Vec2[];\n    /**\n     * The texture used when uv coordinates are present.\n     *\n     * @since v3001.0\n     */\n    tex?: Texture;\n    renderArea(): Polygon;\n}\n\n/**\n * @group Component Options\n */\nexport interface CircleCompOpt {\n    /**\n     * If fill the circle (useful if you only want to render outline with outline() component).\n     */\n    fill?: boolean;\n}\n\n/**\n * @group Component System\n */\nexport interface CircleComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * Radius of circle.\n     */\n    radius: number;\n    /**\n     * @since v3000.0\n     */\n    renderArea(): Rect;\n}\n\n/**\n * @group Component System\n */\nexport interface UVQuadComp extends Comp {\n    draw: Comp[\"draw\"];\n    /**\n     * Width of rect.\n     */\n    width: number;\n    /**\n     * Height of height.\n     */\n    height: number;\n    /**\n     * @since v3000.0\n     */\n    renderArea(): Rect;\n}\n\n/**\n * @group Draw\n */\nexport type Shape =\n    | Rect\n    | Line\n    | Point\n    | Circle\n    | Ellipse\n    | Polygon;\n\n/**\n * @group Component System\n */\nexport interface OutlineComp extends Comp {\n    outline: Outline;\n}\n\n/**\n * @group Debug\n */\nexport interface Debug {\n    /**\n     * Pause the whole game.\n     */\n    paused: boolean;\n    /**\n     * Draw bounding boxes of all objects with `area()` component, hover to inspect their states.\n     */\n    inspect: boolean;\n    /**\n     * Global time scale.\n     */\n    timeScale: number;\n    /**\n     * Show the debug log or not.\n     */\n    showLog: boolean;\n    /**\n     * Current frames per second.\n     */\n    fps(): number;\n    /**\n     * Total number of frames elapsed.\n     *\n     * @since v3000.0\n     */\n    numFrames(): number;\n    /**\n     * Number of draw calls made last frame.\n     */\n    drawCalls(): number;\n    /**\n     * Step to the next frame. Useful with pausing.\n     */\n    stepFrame(): void;\n    /**\n     * Clear the debug log.\n     */\n    clearLog(): void;\n    /**\n     * Log some text to on screen debug log.\n     */\n    log(msg: string | { toString(): string }): void;\n    /**\n     * Log an error message to on screen debug log.\n     */\n    error(msg: string | { toString(): string }): void;\n    /**\n     * The recording handle if currently in recording mode.\n     *\n     * @since v2000.1\n     */\n    curRecording: Recording | null;\n    /**\n     * Get total number of objects.\n     *\n     * @since v3001.0\n     */\n    numObjects(): number;\n}\n\n/**\n * @group Math\n */\nexport type UniformValue =\n    | number\n    | Vec2\n    | Color\n    | Mat4\n    | number[]\n    | Vec2[]\n    | Color[];\n\n/**\n * @group Math\n */\nexport type UniformKey = Exclude<string, \"u_tex\">;\n/**\n * @group Math\n */\nexport type Uniform = Record<UniformKey, UniformValue>;\n\n/**\n * @group Component System\n */\nexport interface ShaderComp extends Comp {\n    uniform: Uniform;\n    shader: string;\n}\n\n/**\n * @group Component System\n */\nexport interface BodyComp extends Comp {\n    /**\n     * Object current velocity.\n     *\n     * @since v3001.0\n     */\n    vel: Vec2;\n    /**\n     * How much velocity decays (velocity *= (1 - drag) every frame).\n     *\n     * @since v3001.0\n     */\n    drag: number;\n    /**\n     * If object is static, won't move, and all non static objects won't move past it.\n     */\n    isStatic: boolean;\n    /**\n     * Initial speed in pixels per second for jump().\n     */\n    jumpForce: number;\n    /**\n     * Gravity multiplier.\n     */\n    gravityScale: number;\n    /**\n     * Mass of the body, decides how much a non-static body should move when resolves with another non-static body. (default 1).\n     *\n     * @since v3000.0\n     */\n    mass?: number;\n    /**\n     * If object should move with moving platform (default true).\n     *\n     * @since v3000.0\n     */\n    stickToPlatform?: boolean;\n    /**\n     * Current platform landing on.\n     */\n    curPlatform(): GameObj | null;\n    /**\n     * If currently landing on a platform.\n     *\n     * @since v2000.1\n     */\n    isGrounded(): boolean;\n    /**\n     * If currently falling.\n     *\n     * @since v2000.1\n     */\n    isFalling(): boolean;\n    /**\n     * If currently rising.\n     *\n     * @since v3000.0\n     */\n    isJumping(): boolean;\n    /**\n     * Upward thrust.\n     */\n    jump(force?: number): void;\n    /**\n     * Register an event that runs when a collision is resolved.\n     *\n     * @since v3000.0\n     */\n    onPhysicsResolve(action: (col: Collision) => void): EventController;\n    /**\n     * Register an event that runs before a collision would be resolved.\n     *\n     * @since v3000.0\n     */\n    onBeforePhysicsResolve(action: (col: Collision) => void): EventController;\n    /**\n     * Register an event that runs when the object is grounded.\n     *\n     * @since v2000.1\n     */\n    onGround(action: () => void): EventController;\n    /**\n     * Register an event that runs when the object starts falling.\n     *\n     * @since v2000.1\n     */\n    onFall(action: () => void): EventController;\n    /**\n     * Register an event that runs when the object falls off platform.\n     *\n     * @since v3000.0\n     */\n    onFallOff(action: () => void): EventController;\n    /**\n     * Register an event that runs when the object bumps into something on the head.\n     *\n     * @since v2000.1\n     */\n    onHeadbutt(action: () => void): EventController;\n}\n\n/**\n * @group Component System\n */\nexport interface DoubleJumpComp extends Comp {\n    /**\n     * Number of jumps allowed.\n     */\n    numJumps: number;\n    /**\n     * Performs double jump (the initial jump only happens if player is grounded).\n     */\n    doubleJump(force?: number): void;\n    /**\n     * Register an event that runs when the object performs the second jump when double jumping.\n     */\n    onDoubleJump(action: () => void): EventController;\n}\n\n/**\n * @group Component Options\n */\nexport interface BodyCompOpt {\n    /**\n     * How much velocity decays (velocity *= (1 - drag) every frame).\n     *\n     * @since v3001.0\n     */\n    drag?: number;\n    /**\n     * Initial speed in pixels per second for jump().\n     */\n    jumpForce?: number;\n    /**\n     * Maximum velocity when falling.\n     */\n    maxVelocity?: number;\n    /**\n     * Gravity multiplier.\n     */\n    gravityScale?: number;\n    /**\n     * If object is static, won't move, and all non static objects won't move past it.\n     *\n     * @since v3000.0\n     */\n    isStatic?: boolean;\n    /**\n     * If object should move with moving platform (default true).\n     *\n     * @since v3000.0\n     */\n    stickToPlatform?: boolean;\n    /**\n     * Mass of the body, decides how much a non-static body should move when resolves with another non-static body. (default 1).\n     *\n     * @since v3000.0\n     */\n    mass?: number;\n}\n\n/**\n * @group Component System\n */\nexport interface TimerComp extends Comp {\n    /**\n     * Run the callback after n seconds.\n     */\n    wait(time: number, action?: () => void): TimerController;\n    /**\n     * Run the callback every n seconds.\n     *\n     * @since v3000.0\n     */\n    loop(time: number, action: () => void): EventController;\n    /**\n     * Tweeeeen! Note that this doesn't specifically mean tweening on this object's property, this just registers the timer on this object, so the tween will cancel with the object gets destroyed, or paused when obj.paused is true.\n     *\n     * @since v3000.0\n     */\n    tween<V extends LerpValue>(\n        from: V,\n        to: V,\n        duration: number,\n        setValue: (value: V) => void,\n        easeFunc?: (t: number) => number,\n    ): TweenController;\n}\n\n/**\n * @group Component System\n */\nexport interface FixedComp extends Comp {\n    /**\n     * If the obj is unaffected by camera\n     */\n    fixed: boolean;\n}\n\n/**\n * @group Component System\n */\nexport interface StayComp extends Comp {\n    /**\n     * If the obj should not be destroyed on scene switch.\n     */\n    stay: boolean;\n    /**\n     * Array of scenes that the obj will stay on.\n     */\n    scenesToStay: string[];\n}\n\n/**\n * @group Component System\n */\nexport interface HealthComp extends Comp {\n    /**\n     * Decrease HP by n (defaults to 1).\n     */\n    hurt(n?: number): void;\n    /**\n     * Increase HP by n (defaults to 1).\n     */\n    heal(n?: number): void;\n    /**\n     * Current health points.\n     */\n    hp(): number;\n    /**\n     * Set current health points.\n     */\n    setHP(hp: number): void;\n    /**\n     * Max amount of HP.\n     */\n    maxHP(): number | null;\n    /**\n     * Set max amount of HP.\n     */\n    setMaxHP(hp: number): void;\n    /**\n     * Register an event that runs when hurt() is called upon the object.\n     *\n     * @since v2000.1\n     */\n    onHurt(action: (amount?: number) => void): EventController;\n    /**\n     * Register an event that runs when heal() is called upon the object.\n     *\n     * @since v2000.1\n     */\n    onHeal(action: (amount?: number) => void): EventController;\n    /**\n     * Register an event that runs when object's HP is equal or below 0.\n     *\n     * @since v2000.1\n     */\n    onDeath(action: () => void): EventController;\n}\n\n/**\n * @group Component Options\n */\nexport interface LifespanCompOpt {\n    /**\n     * Fade out duration (default 0 which is no fade out).\n     */\n    fade?: number;\n}\n\n/**\n * @group Component System\n */\nexport interface StateComp extends Comp {\n    /**\n     * Current state.\n     */\n    state: string;\n    /**\n     * Enter a state, trigger onStateEnd for previous state and onStateEnter for the new State state.\n     */\n    enterState: (state: string, ...args: any) => void;\n    /**\n     * Register event that runs once when a specific state transition happens. Accepts arguments passed from `enterState(name, ...args)`.\n     *\n     * @since v2000.2\n     */\n    onStateTransition(\n        from: string,\n        to: string,\n        action: () => void,\n    ): EventController;\n    /**\n     * Register event that runs once when enters a specific state. Accepts arguments passed from `enterState(name, ...args)`.\n     */\n    onStateEnter: (\n        state: string,\n        action: (...args: any) => void,\n    ) => EventController;\n    /**\n     * Register an event that runs once when leaves a specific state.\n     */\n    onStateEnd: (state: string, action: () => void) => EventController;\n    /**\n     * Register an event that runs every frame when in a specific state.\n     */\n    onStateUpdate: (state: string, action: () => void) => EventController;\n    /**\n     * Register an event that runs every frame when in a specific state.\n     */\n    onStateDraw: (state: string, action: () => void) => EventController;\n}\n\nexport type Mask = \"intersect\" | \"subtract\";\n\n/**\n * @group Component System\n */\nexport interface MaskComp extends Comp {\n    mask: Mask;\n}\n\n/**\n * @group Component Options\n */\nexport interface LevelOpt {\n    /**\n     * Width of each block.\n     */\n    tileWidth: number;\n    /**\n     * Height of each block.\n     */\n    tileHeight: number;\n    /**\n     * Position of the first block.\n     */\n    pos?: Vec2;\n    /**\n     * Definition of each tile.\n     */\n    tiles: {\n        [sym: string]: (pos: Vec2) => CompList<any>;\n    };\n    /**\n     * Called when encountered a symbol not defined in \"tiles\".\n     */\n    wildcardTile?: (sym: string, pos: Vec2) => CompList<any> | null | undefined;\n}\n\n/**\n * @group Math\n */\nexport type Edge =\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\";\n\n/**\n * @group Math\n */\nexport enum EdgeMask {\n    None = 0,\n    Left = 1,\n    Top = 2,\n    LeftTop = 3,\n    Right = 4,\n    Horizontal = 5,\n    RightTop = 6,\n    HorizontalTop = 7,\n    Bottom = 8,\n    LeftBottom = 9,\n    Vertical = 10,\n    LeftVertical = 11,\n    RightBottom = 12,\n    HorizontalBottom = 13,\n    RightVertical = 14,\n    All = 15,\n}\n\n/**\n * @group Component Options\n */\nexport type TileCompOpt = {\n    /**\n     * If the tile is an obstacle in pathfinding.\n     */\n    isObstacle?: boolean;\n    /**\n     * How much a tile is cost to traverse in pathfinding (default 0).\n     */\n    cost?: number;\n    /**\n     * If the tile has hard edges that cannot pass in pathfinding.\n     */\n    edges?: Edge[];\n    /**\n     * Position offset when setting `tilePos`.\n     */\n    offset?: Vec2;\n};\n\n/**\n * @group Component System\n */\nexport interface TileComp extends Comp {\n    /**\n     * The tile position inside the level.\n     */\n    tilePos: Vec2;\n    /**\n     * If the tile is an obstacle in pathfinding.\n     */\n    isObstacle: boolean;\n    /**\n     * How much a tile is cost to traverse in pathfinding (default 0).\n     */\n    cost: number;\n    /**\n     * If the tile has hard edges that cannot pass in pathfinding.\n     */\n    edges: Edge[];\n    /**\n     * Position offset when setting `tilePos`.\n     */\n    tilePosOffset: Vec2;\n    readonly edgeMask: EdgeMask;\n    getLevel(): GameObj<LevelComp>;\n    moveLeft(): void;\n    moveRight(): void;\n    moveUp(): void;\n    moveDown(): void;\n}\n\n/**\n * @group Component System\n */\nexport interface LevelComp extends Comp {\n    tileWidth(): number;\n    tileHeight(): number;\n    numRows(): number;\n    numColumns(): number;\n    /**\n     * Spawn a tile from a symbol defined previously.\n     */\n    spawn(sym: string, p: Vec2): GameObj | null;\n    spawn(sym: string, x: number, y: number): GameObj | null;\n    /**\n     * Spawn a tile from a component list.\n     */\n    spawn<T>(obj: CompList<T>, p: Vec2): GameObj<T>;\n    spawn<T>(sym: CompList<T>, x: number, y: number): GameObj<T>;\n    /**\n     * Total width of level in pixels.\n     */\n    levelWidth(): number;\n    /**\n     * Total height of level in pixels.\n     */\n    levelHeight(): number;\n    /**\n     * Get all game objects that's currently inside a given tile.\n     */\n    getAt(tilePos: Vec2): GameObj[];\n    /**\n     * Raycast all game objects on the given path.\n     */\n    raycast(origin: Vec2, direction: Vec2): RaycastResult;\n    /**\n     * Convert tile position to pixel position.\n     */\n    tile2Pos(tilePos: Vec2): Vec2;\n    tile2Pos(x: number, y: number): Vec2;\n    /**\n     * Convert pixel position to tile position.\n     */\n    pos2Tile(pos: Vec2): Vec2;\n    pos2Tile(x: number, y: number): Vec2;\n    /**\n     * Find the path to navigate from one tile to another tile.\n     *\n     * @returns A list of traverse points in tile positions.\n     */\n    getTilePath(from: Vec2, to: Vec2, opts?: PathFindOpt): Vec2[] | null;\n    /**\n     * Find the path to navigate from one tile to another tile.\n     *\n     * @returns A list of traverse points in pixel positions.\n     */\n    getPath(from: Vec2, to: Vec2, opts?: PathFindOpt): Vec2[] | null;\n    getSpatialMap(): GameObj[][];\n    onSpatialMapChanged(cb: () => void): EventController;\n    onNavigationMapInvalid(cb: () => void): EventController;\n    invalidateNavigationMap(): void;\n    onNavigationMapChanged(cb: () => void): EventController;\n}\n\n/**\n * @group Component Options\n */\nexport type PathFindOpt = {\n    allowDiagonals?: boolean;\n};\n\n/**\n * @group Component Options\n */\nexport type AgentCompOpt = {\n    speed?: number;\n    allowDiagonals?: boolean;\n};\n\n/**\n * @group Component System\n */\nexport interface AgentComp extends Comp {\n    agentSpeed: number;\n    allowDiagonals: boolean;\n    getDistanceToTarget(): number;\n    getNextLocation(): Vec2 | null;\n    getPath(): Vec2[] | null;\n    getTarget(): Vec2 | null;\n    isNavigationFinished(): boolean;\n    isTargetReachable(): boolean;\n    isTargetReached(): boolean;\n    setTarget(target: Vec2): void;\n    onNavigationStarted(cb: () => void): EventController;\n    onNavigationNext(cb: () => void): EventController;\n    onNavigationEnded(cb: () => void): EventController;\n    onTargetReached(cb: () => void): EventController;\n}\n\n/**\n * @group Component Options\n */\nexport interface BoomOpt {\n    /**\n     * Animation speed.\n     */\n    speed?: number;\n    /**\n     * Scale.\n     */\n    scale?: number;\n    /**\n     * Additional components.\n     *\n     * @since v3000.0\n     */\n    comps?: CompList<any>;\n}\n\n/**\n * @group Math\n */\nexport type EaseFuncs =\n    | \"linear\"\n    | \"easeInSine\"\n    | \"easeOutSine\"\n    | \"easeInOutSine\"\n    | \"easeInQuad\"\n    | \"easeOutQuad\"\n    | \"easeInOutQuad\"\n    | \"easeInCubic\"\n    | \"easeOutCubic\"\n    | \"easeInOutCubic\"\n    | \"easeInQuart\"\n    | \"easeOutQuart\"\n    | \"easeInOutQuart\"\n    | \"easeInQuint\"\n    | \"easeOutQuint\"\n    | \"easeInOutQuint\"\n    | \"easeInExpo\"\n    | \"easeOutExpo\"\n    | \"easeInOutExpo\"\n    | \"easeInCirc\"\n    | \"easeOutCirc\"\n    | \"easeInOutCirc\"\n    | \"easeInBack\"\n    | \"easeOutBack\"\n    | \"easeInOutBack\"\n    | \"easeInElastic\"\n    | \"easeOutElastic\"\n    | \"easeInOutElastic\"\n    | \"easeInBounce\"\n    | \"easeOutBounce\"\n    | \"easeInOutBounce\";\n\n/**\n * @group Math\n */\nexport type EaseFunc = (t: number) => number;\n\n// TODO: use PromiseLike or extend Promise?\n/**\n * @group Timer\n */\nexport type TimerController = {\n    /**\n     * If the event handler is paused.\n     */\n    paused: boolean;\n    /**\n     * Cancel the event handler.\n     */\n    cancel(): void;\n    /**\n     * Register an event when finished.\n     */\n    onEnd(action: () => void): void;\n    then(action: () => void): TimerController;\n};\n\n/**\n * @group Timer\n */\nexport type TweenController = TimerController & {\n    /**\n     * Finish the tween now and cancel.\n     */\n    finish(): void;\n};\n\n/**\n * @group Events\n */\nexport declare class EventController {\n    /**\n     * If the event handler is paused.\n     */\n    paused: boolean;\n    /**\n     * Cancel the event handler.\n     */\n    readonly cancel: () => void;\n    constructor(cancel: () => void);\n    static join(events: EventController[]): EventController;\n}\n\nexport interface SpriteCurAnim {\n    name: string;\n    timer: number;\n    loop: boolean;\n    speed: number;\n    pingpong: boolean;\n    onEnd: () => void;\n}\n\n// TODO: global name conflict, renamed to KEvent?\nexport declare class Event<Args extends any[] = any[]> {\n    add(action: (...args: Args) => void): EventController;\n    addOnce(action: (...args: any) => void): EventController;\n    next(): Promise<Args>;\n    trigger(...args: Args): void;\n    numListeners(): number;\n    clear(): void;\n}\n\nexport declare class EventHandler<EventMap extends Record<string, any[]>> {\n    on<Name extends keyof EventMap>(\n        name: Name,\n        action: (...args: EventMap[Name]) => void,\n    ): EventController;\n    onOnce<Name extends keyof EventMap>(\n        name: Name,\n        action: (...args: EventMap[Name]) => void,\n    ): EventController;\n    next<Name extends keyof EventMap>(name: Name): Promise<unknown>;\n    trigger<Name extends keyof EventMap>(\n        name: Name,\n        ...args: EventMap[Name]\n    ): void;\n    remove<Name extends keyof EventMap>(name: Name): void;\n    clear(): void;\n    numListeners<Name extends keyof EventMap>(name: Name): number;\n}\n\nexport default kaboom;\n", "import { Vec2, vec2 } from \"@/math\";\nimport {\n    type Edge,\n    EdgeMask,\n    type GameObj,\n    type LevelComp,\n    type TileComp,\n    type TileCompOpt,\n} from \"@/types\";\n\nexport function tile(opts: TileCompOpt = {}): TileComp {\n    let tilePos = vec2(0);\n    let isObstacle = opts.isObstacle ?? false;\n    let cost = opts.cost ?? 0;\n    let edges = opts.edges ?? [];\n\n    const getEdgeMask = () => {\n        const loopup = {\n            \"left\": EdgeMask.Left,\n            \"top\": EdgeMask.Top,\n            \"right\": EdgeMask.Right,\n            \"bottom\": EdgeMask.Bottom,\n        };\n        return edges.map(s => loopup[s] || 0).reduce(\n            (mask, dir) => mask | dir,\n            0,\n        );\n    };\n\n    let edgeMask = getEdgeMask();\n\n    return {\n        id: \"tile\",\n        tilePosOffset: opts.offset ?? vec2(0),\n\n        set tilePos(p: Vec2) {\n            const level = this.getLevel();\n            tilePos = p.clone();\n            // @ts-ignore\n            this.pos = vec2(\n                this.tilePos.x * level.tileWidth(),\n                this.tilePos.y * level.tileHeight(),\n            ).add(this.tilePosOffset);\n        },\n\n        get tilePos() {\n            return tilePos;\n        },\n\n        set isObstacle(is: boolean) {\n            if (isObstacle === is) return;\n            isObstacle = is;\n            this.getLevel().invalidateNavigationMap();\n        },\n\n        get isObstacle() {\n            return isObstacle;\n        },\n\n        set cost(n: number) {\n            if (cost === n) return;\n            cost = n;\n            this.getLevel().invalidateNavigationMap();\n        },\n\n        get cost() {\n            return cost;\n        },\n\n        set edges(e: Edge[]) {\n            edges = e;\n            edgeMask = getEdgeMask();\n            this.getLevel().invalidateNavigationMap();\n        },\n\n        get edges() {\n            return edges;\n        },\n\n        get edgeMask() {\n            return edgeMask;\n        },\n\n        getLevel(this: GameObj) {\n            return this.parent as GameObj<LevelComp>;\n        },\n\n        moveLeft() {\n            this.tilePos = this.tilePos.add(vec2(-1, 0));\n        },\n\n        moveRight() {\n            this.tilePos = this.tilePos.add(vec2(1, 0));\n        },\n\n        moveUp() {\n            this.tilePos = this.tilePos.add(vec2(0, -1));\n        },\n\n        moveDown() {\n            this.tilePos = this.tilePos.add(vec2(0, 1));\n        },\n    };\n}\n", "import type { EventController } from \"@/utils\";\nimport type { GameObj, HealthComp } from \"../../types\";\n\nexport function health(\n    hp: number,\n    maxHP?: number,\n): HealthComp {\n    if (hp == null) {\n        throw new Error(\"health() requires the initial amount of hp\");\n    }\n\n    return {\n        id: \"health\",\n        hurt(this: GameObj, n: number = 1) {\n            this.setHP(hp - n);\n            this.trigger(\"hurt\", n);\n        },\n        heal(this: GameObj, n: number = 1) {\n            const origHP = hp;\n            this.setHP(hp + n);\n            this.trigger(\"heal\", hp - origHP);\n        },\n        hp(): number {\n            return hp;\n        },\n        maxHP(): number | null {\n            return maxHP ?? null;\n        },\n        setMaxHP(n: number): void {\n            maxHP = n;\n        },\n        setHP(this: GameObj, n: number) {\n            hp = maxHP ? Math.min(maxHP, n) : n;\n            if (hp <= 0) {\n                this.trigger(\"death\");\n            }\n        },\n        onHurt(\n            this: GameObj,\n            action: (amount?: number) => void,\n        ): EventController {\n            return this.on(\"hurt\", action);\n        },\n        onHeal(\n            this: GameObj,\n            action: (amount?: number) => void,\n        ): EventController {\n            return this.on(\"heal\", action);\n        },\n        onDeath(this: GameObj, action: () => void): EventController {\n            return this.on(\"death\", action);\n        },\n        inspect() {\n            return `${hp}`;\n        },\n    };\n}\n", "import easings from \"@/easings\";\nimport { getKaboomContext } from \"@/kaboom\";\nimport type { EmptyComp, GameObj, LifespanCompOpt, OpacityComp } from \"@/types\";\n\nexport function lifespan(time: number, opt: LifespanCompOpt = {}): EmptyComp {\n    const k = getKaboomContext(this);\n\n    if (time == null) {\n        throw new Error(\"lifespan() requires time\");\n    }\n    const fade = opt.fade ?? 0;\n    return {\n        id: \"lifespan\",\n        require: [\"opacity\"],\n        async add(this: GameObj<OpacityComp>) {\n            await k.wait(time);\n            this.opacity = this.opacity ?? 1;\n            if (fade > 0) {\n                await k.tween(\n                    this.opacity,\n                    0,\n                    fade,\n                    (a) => this.opacity = a,\n                    easings.linear,\n                );\n            }\n            this.destroy();\n        },\n    };\n}\n", "import type { StateComp } from \"@/types\";\nimport { Event, EventController } from \"@/utils\";\n\nexport function state(\n    initState: string,\n    stateList?: string[],\n    transitions?: Record<string, string | string[]>,\n): StateComp {\n    if (!initState) {\n        throw new Error(\"state() requires an initial state\");\n    }\n\n    const events = {};\n\n    function initStateEvents(state: string) {\n        if (!events[state]) {\n            events[state] = {\n                enter: new Event(),\n                end: new Event(),\n                update: new Event(),\n                draw: new Event(),\n            };\n        }\n    }\n\n    function on(event, state, action) {\n        initStateEvents(state);\n        return events[state][event].add(action);\n    }\n\n    function trigger(event, state, ...args) {\n        initStateEvents(state);\n        events[state][event].trigger(...args);\n    }\n\n    let didFirstEnter = false;\n\n    return {\n        id: \"state\",\n        state: initState,\n\n        enterState(state: string, ...args) {\n            didFirstEnter = true;\n\n            if (stateList && !stateList.includes(state)) {\n                throw new Error(`State not found: ${state}`);\n            }\n\n            const oldState = this.state;\n\n            if (transitions) {\n                // check if the transition is legal, if transition graph is defined\n                if (!transitions?.[oldState]) {\n                    return;\n                }\n\n                const available = typeof transitions[oldState] === \"string\"\n                    ? [transitions[oldState]]\n                    : transitions[oldState] as string[];\n\n                if (!available.includes(state)) {\n                    throw new Error(\n                        `Cannot transition state from \"${oldState}\" to \"${state}\". Available transitions: ${\n                            available.map((s) => `\"${s}\"`).join(\", \")\n                        }`,\n                    );\n                }\n            }\n\n            trigger(\"end\", oldState, ...args);\n            this.state = state;\n            trigger(\"enter\", state, ...args);\n            trigger(\"enter\", `${oldState} -> ${state}`, ...args);\n        },\n\n        onStateTransition(\n            from: string,\n            to: string,\n            action: () => void,\n        ): EventController {\n            return on(\"enter\", `${from} -> ${to}`, action);\n        },\n\n        onStateEnter(state: string, action: () => void): EventController {\n            return on(\"enter\", state, action);\n        },\n\n        onStateUpdate(state: string, action: () => void): EventController {\n            return on(\"update\", state, action);\n        },\n\n        onStateDraw(state: string, action: () => void): EventController {\n            return on(\"draw\", state, action);\n        },\n\n        onStateEnd(state: string, action: () => void): EventController {\n            return on(\"end\", state, action);\n        },\n\n        update() {\n            // execute the enter event for initState\n            if (!didFirstEnter) {\n                trigger(\"enter\", initState);\n                didFirstEnter = true;\n            }\n            trigger(\"update\", this.state);\n        },\n\n        draw() {\n            trigger(\"draw\", this.state);\n        },\n\n        inspect() {\n            return this.state;\n        },\n    };\n}\n", "import type { StayComp } from \"@/types\";\n\nexport function stay(scenesToStay?: string[]): StayComp {\n    return {\n        id: \"stay\",\n        stay: true,\n        scenesToStay: scenesToStay,\n    };\n}\n", "import easings from \"@/easings\";\nimport { getKaboomContext } from \"@/kaboom\";\nimport { lerp } from \"@/math\";\nimport type {\n    EventController,\n    GameObj,\n    LerpValue,\n    TimerComp,\n    TimerController,\n} from \"@/types\";\n\nexport function timer(): TimerComp {\n    return {\n        id: \"timer\",\n        wait(\n            this: GameObj<TimerComp>,\n            time: number,\n            action?: () => void,\n        ): TimerController {\n            const k = getKaboomContext(this);\n            const actions = [];\n            if (action) actions.push(action);\n            let t = 0;\n            const ev = this.onUpdate(() => {\n                t += k.dt();\n                if (t >= time) {\n                    actions.forEach((f) => f());\n                    ev.cancel();\n                }\n            });\n            return {\n                get paused() {\n                    return ev.paused;\n                },\n                set paused(p) {\n                    ev.paused = p;\n                },\n                cancel: ev.cancel,\n                onEnd(action) {\n                    actions.push(action);\n                },\n                then(action) {\n                    this.onEnd(action);\n                    return this;\n                },\n            };\n        },\n        loop(t: number, action: () => void): EventController {\n            let curTimer: null | TimerController = null;\n            const newAction = () => {\n                // TODO: should f be execute right away as loop() is called?\n                curTimer = this.wait(t, newAction);\n                action();\n            };\n            curTimer = this.wait(0, newAction);\n            return {\n                get paused() {\n                    return curTimer.paused;\n                },\n                set paused(p) {\n                    curTimer.paused = p;\n                },\n                cancel: () => curTimer.cancel(),\n            };\n        },\n        tween<V extends LerpValue>(\n            this: GameObj<TimerComp>,\n            from: V,\n            to: V,\n            duration: number,\n            setValue: (value: V) => void,\n            easeFunc = easings.linear,\n        ) {\n            const k = getKaboomContext(this);\n            let curTime = 0;\n            const onEndEvents: Array<() => void> = [];\n            const ev = this.onUpdate(() => {\n                curTime += k.dt();\n                const t = Math.min(curTime / duration, 1);\n                setValue(lerp(from, to, easeFunc(t)));\n                if (t === 1) {\n                    ev.cancel();\n                    setValue(to);\n                    onEndEvents.forEach((action) => action());\n                }\n            });\n            return {\n                get paused() {\n                    return ev.paused;\n                },\n                set paused(p) {\n                    ev.paused = p;\n                },\n                onEnd(action: () => void) {\n                    onEndEvents.push(action);\n                },\n                then(action: () => void) {\n                    this.onEnd(action);\n                    return this;\n                },\n                cancel() {\n                    ev.cancel();\n                },\n                finish() {\n                    ev.cancel();\n                    setValue(to);\n                    onEndEvents.forEach((action) => action());\n                },\n            };\n        },\n    };\n}\n", "import { DEF_ANCHOR } from \"@/constants\";\nimport { anchorPt, getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Polygon, rgb, testPolygonPoint, Vec2, vec2 } from \"@/math\";\nimport type {\n    AnchorComp,\n    AreaComp,\n    AreaCompOpt,\n    Collision,\n    FixedComp,\n    GameObj,\n    MouseButton,\n    PosComp,\n    Shape,\n    Tag,\n} from \"@/types\";\nimport type { EventController } from \"@/utils\";\n\nexport function area(opt: AreaCompOpt = {}): AreaComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n    const { app } = internal;\n\n    const colliding = {};\n    const collidingThisFrame = new Set();\n\n    return {\n        id: \"area\",\n        collisionIgnore: opt.collisionIgnore ?? [],\n\n        add(this: GameObj<AreaComp>) {\n            if (this.area.cursor) {\n                this.onHover(() => app.setCursor(this.area.cursor));\n            }\n\n            this.onCollideUpdate((obj, col) => {\n                if (!colliding[obj.id]) {\n                    this.trigger(\"collide\", obj, col);\n                }\n                colliding[obj.id] = col;\n                collidingThisFrame.add(obj.id);\n            });\n        },\n\n        update(this: GameObj<AreaComp>) {\n            for (const id in colliding) {\n                if (!collidingThisFrame.has(Number(id))) {\n                    this.trigger(\"collideEnd\", colliding[id].target);\n                    delete colliding[id];\n                }\n            }\n            collidingThisFrame.clear();\n        },\n\n        drawInspect(this: GameObj<AreaComp | AnchorComp | FixedComp>) {\n            const a = this.localArea();\n\n            k.pushTransform();\n            k.pushScale(this.area.scale);\n            k.pushTranslate(this.area.offset);\n\n            const opts = {\n                outline: {\n                    width: 4 / internal.getViewportScale(),\n                    color: rgb(0, 0, 255),\n                },\n                anchor: this.anchor,\n                fill: false,\n                fixed: internal.isFixed(this),\n            };\n\n            if (a instanceof k.Rect) {\n                k.drawRect({\n                    ...opts,\n                    pos: a.pos,\n                    width: a.width,\n                    height: a.height,\n                });\n            } else if (a instanceof k.Polygon) {\n                k.drawPolygon({\n                    ...opts,\n                    pts: a.pts,\n                });\n            } else if (a instanceof k.Circle) {\n                k.drawCircle({\n                    ...opts,\n                    pos: a.center,\n                    radius: a.radius,\n                });\n            }\n\n            k.popTransform();\n        },\n\n        area: {\n            shape: opt.shape ?? null,\n            scale: opt.scale ? vec2(opt.scale) : vec2(1),\n            offset: opt.offset ?? vec2(0),\n            cursor: opt.cursor ?? null,\n        },\n\n        isClicked(): boolean {\n            return app.isMousePressed() && this.isHovering();\n        },\n\n        isHovering(this: GameObj) {\n            const mpos = internal.isFixed(this)\n                ? k.mousePos()\n                : k.toWorld(k.mousePos());\n            return this.hasPoint(mpos);\n        },\n\n        checkCollision(this: GameObj, other: GameObj<AreaComp>) {\n            return colliding[other.id] ?? null;\n        },\n\n        getCollisions() {\n            return Object.values(colliding);\n        },\n\n        // TODO: perform check instead of use cache\n        isColliding(other: GameObj<AreaComp>) {\n            return Boolean(colliding[other.id]);\n        },\n\n        isOverlapping(other) {\n            const col = colliding[other.id];\n            return col && col.hasOverlap();\n        },\n\n        onClick(\n            this: GameObj<AreaComp>,\n            f: () => void,\n            btn: MouseButton = \"left\",\n        ): EventController {\n            const e = app.onMousePress(btn, () => {\n                if (this.isHovering()) {\n                    f();\n                }\n            });\n            this.onDestroy(() => e.cancel());\n            return e;\n        },\n\n        onHover(this: GameObj, action: () => void): EventController {\n            let hovering = false;\n            return this.onUpdate(() => {\n                if (!hovering) {\n                    if (this.isHovering()) {\n                        hovering = true;\n                        action();\n                    }\n                } else {\n                    hovering = this.isHovering();\n                }\n            });\n        },\n\n        onHoverUpdate(this: GameObj, onHover: () => void): EventController {\n            return this.onUpdate(() => {\n                if (this.isHovering()) {\n                    onHover();\n                }\n            });\n        },\n\n        onHoverEnd(this: GameObj, action: () => void): EventController {\n            let hovering = false;\n            return this.onUpdate(() => {\n                if (hovering) {\n                    if (!this.isHovering()) {\n                        hovering = false;\n                        action();\n                    }\n                } else {\n                    hovering = this.isHovering();\n                }\n            });\n        },\n\n        onCollide(\n            this: GameObj,\n            tag: Tag | ((obj: GameObj, col?: Collision) => void),\n            cb?: (obj: GameObj, col?: Collision) => void,\n        ): EventController {\n            if (typeof tag === \"function\" && cb === undefined) {\n                return this.on(\"collide\", tag);\n            } else if (typeof tag === \"string\") {\n                return this.onCollide((obj, col) => {\n                    if (obj.is(tag)) {\n                        cb(obj, col);\n                    }\n                });\n            }\n        },\n\n        onCollideUpdate(\n            this: GameObj<AreaComp>,\n            tag: Tag | ((obj: GameObj, col?: Collision) => void),\n            cb?: (obj: GameObj, col?: Collision) => void,\n        ): EventController {\n            if (typeof tag === \"function\" && cb === undefined) {\n                return this.on(\"collideUpdate\", tag);\n            } else if (typeof tag === \"string\") {\n                return this.on(\n                    \"collideUpdate\",\n                    (obj, col) => obj.is(tag) && cb(obj, col),\n                );\n            }\n        },\n\n        onCollideEnd(\n            this: GameObj<AreaComp>,\n            tag: Tag | ((obj: GameObj) => void),\n            cb?: (obj: GameObj) => void,\n        ): EventController {\n            if (typeof tag === \"function\" && cb === undefined) {\n                return this.on(\"collideEnd\", tag);\n            } else if (typeof tag === \"string\") {\n                return this.on(\n                    \"collideEnd\",\n                    (obj) => obj.is(tag) && cb(obj),\n                );\n            }\n        },\n\n        hasPoint(pt: Vec2): boolean {\n            // TODO: convert to pt to local space instead\n            return testPolygonPoint(this.worldArea(), pt);\n        },\n\n        // push an obj out of another if they're overlapped\n        resolveCollision(\n            this: GameObj<AreaComp | PosComp>,\n            obj: GameObj<AreaComp>,\n        ) {\n            const col = this.checkCollision(obj);\n            if (col && !col.resolved) {\n                this.pos = this.pos.add(col.displacement);\n                col.resolved = true;\n            }\n        },\n\n        localArea(\n            this: GameObj<AreaComp | { renderArea(): Shape }>,\n        ): Shape {\n            return this.area.shape\n                ? this.area.shape\n                : this.renderArea();\n        },\n\n        // TODO: cache\n        worldArea(this: GameObj<AreaComp | AnchorComp>): Polygon {\n            const localArea = this.localArea();\n\n            if (\n                !(localArea instanceof k.Polygon || localArea instanceof k.Rect)\n            ) {\n                throw new Error(\n                    \"Only support polygon and rect shapes for now\",\n                );\n            }\n\n            const transform = this.transform\n                .clone()\n                .scale(vec2(this.area.scale ?? 1))\n                .translate(this.area.offset);\n\n            if (localArea instanceof k.Rect) {\n                const offset = anchorPt(this.anchor || DEF_ANCHOR)\n                    .add(1, 1)\n                    .scale(-0.5)\n                    .scale(localArea.width, localArea.height);\n                transform.translate(offset);\n            }\n\n            return localArea.transform(transform) as Polygon;\n        },\n\n        screenArea(this: GameObj<AreaComp | FixedComp>): Polygon {\n            const area = this.worldArea();\n            if (internal.isFixed(this)) {\n                return area;\n            } else {\n                return area.transform(internal.game.cam.transform);\n            }\n        },\n\n        inspect() {\n            return `(${this.area.scale.x.toFixed(1)}, ${\n                this.area.scale.y.toFixed(1)\n            })`;\n        },\n    };\n}\n", "import { DEF_JUMP_FORCE, MAX_VEL } from \"@/constants\";\nimport { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { vec2 } from \"@/math\";\nimport type {\n    AreaComp,\n    BodyComp,\n    BodyCompOpt,\n    GameObj,\n    PosComp,\n} from \"@/types\";\nimport type { EventController } from \"@/utils\";\n\nexport function body(opt: BodyCompOpt = {}): BodyComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n    let curPlatform: GameObj<PosComp | AreaComp | BodyComp> | null = null;\n    let lastPlatformPos = null;\n    let willFall = false;\n\n    return {\n        id: \"body\",\n        require: [\"pos\"],\n        vel: vec2(0),\n        drag: opt.drag ?? 0,\n        jumpForce: opt.jumpForce ?? DEF_JUMP_FORCE,\n        gravityScale: opt.gravityScale ?? 1,\n        isStatic: opt.isStatic ?? false,\n        // TODO: prefer density * area\n        mass: opt.mass ?? 1,\n\n        add(this: GameObj<PosComp | BodyComp | AreaComp>) {\n            if (this.mass === 0) {\n                throw new Error(\"Can't set body mass to 0\");\n            }\n\n            if (this.is(\"area\")) {\n                // static vs static: don't resolve\n                // static vs non-static: always resolve non-static\n                // non-static vs non-static: resolve the first one\n                this.onCollideUpdate(\n                    (other: GameObj<PosComp | BodyComp>, col) => {\n                        if (!other.is(\"body\")) {\n                            return;\n                        }\n\n                        if (col.resolved) {\n                            return;\n                        }\n\n                        this.trigger(\"beforePhysicsResolve\", col);\n                        const rcol = col.reverse();\n                        other.trigger(\"beforePhysicsResolve\", rcol);\n\n                        // user can mark 'resolved' in beforePhysicsResolve to stop a resolution\n                        if (col.resolved || rcol.resolved) {\n                            return;\n                        }\n\n                        if (this.isStatic && other.isStatic) {\n                            return;\n                        } else if (!this.isStatic && !other.isStatic) {\n                            // TODO: update all children transform?\n                            const tmass = this.mass + other.mass;\n                            this.pos = this.pos.add(\n                                col.displacement.scale(other.mass / tmass),\n                            );\n                            other.pos = other.pos.add(\n                                col.displacement.scale(-this.mass / tmass),\n                            );\n                            this.transform = internal.calcTransform(this);\n                            other.transform = internal.calcTransform(other);\n                        } else {\n                            // if one is static and on is not, resolve the non static one\n                            const col2 = (!this.isStatic && other.isStatic)\n                                ? col\n                                : col.reverse();\n                            col2.source.pos = col2.source.pos.add(\n                                col2.displacement,\n                            );\n                            col2.source.transform = internal.calcTransform(\n                                col2.source,\n                            );\n                        }\n\n                        col.resolved = true;\n                        this.trigger(\"physicsResolve\", col);\n                        other.trigger(\"physicsResolve\", col.reverse());\n                    },\n                );\n\n                this.onPhysicsResolve((col) => {\n                    if (internal.game.gravity) {\n                        if (col.isBottom() && this.isFalling()) {\n                            this.vel = this.vel.reject(\n                                internal.game.gravity.unit(),\n                            );\n                            curPlatform = col.target as GameObj<\n                                PosComp | BodyComp | AreaComp\n                            >;\n                            lastPlatformPos = col.target.pos;\n                            if (willFall) {\n                                willFall = false;\n                            } else {\n                                this.trigger(\"ground\", curPlatform);\n                            }\n                        } else if (col.isTop() && this.isJumping()) {\n                            this.vel = this.vel.reject(\n                                internal.game.gravity.unit(),\n                            );\n                            this.trigger(\"headbutt\", col.target);\n                        }\n                    }\n                });\n            }\n        },\n\n        update(this: GameObj<PosComp | BodyComp | AreaComp>) {\n            if (internal.game.gravity && !this.isStatic) {\n                if (willFall) {\n                    curPlatform = null;\n                    lastPlatformPos = null;\n                    this.trigger(\"fallOff\");\n                    willFall = false;\n                }\n\n                let addGravity = true;\n\n                if (curPlatform) {\n                    if (\n                        // TODO: this prevents from falling when on edge\n                        !this.isColliding(curPlatform)\n                        || !curPlatform.exists()\n                        || !curPlatform.is(\"body\")\n                    ) {\n                        willFall = true;\n                    } else {\n                        if (\n                            !curPlatform.pos.eq(lastPlatformPos)\n                            && opt.stickToPlatform !== false\n                        ) {\n                            this.moveBy(\n                                curPlatform.pos.sub(lastPlatformPos),\n                            );\n                        }\n                        lastPlatformPos = curPlatform.pos;\n                        addGravity = false;\n                    }\n                }\n\n                if (addGravity) {\n                    const prevVel = this.vel.clone();\n\n                    // Apply gravity\n                    this.vel = this.vel.add(\n                        internal.game.gravity.scale(this.gravityScale * k.dt()),\n                    );\n\n                    // Clamp velocity\n                    const maxVel = opt.maxVelocity ?? MAX_VEL;\n                    if (this.vel.slen() > maxVel * maxVel) {\n                        this.vel = this.vel.unit().scale(maxVel);\n                    }\n\n                    if (\n                        prevVel.dot(internal.game.gravity) < 0\n                        && this.vel.dot(internal.game.gravity) >= 0\n                    ) {\n                        this.trigger(\"fall\");\n                    }\n                }\n            }\n\n            this.vel.x *= 1 - this.drag;\n            this.vel.y *= 1 - this.drag;\n\n            this.move(this.vel);\n        },\n\n        onPhysicsResolve(this: GameObj, action) {\n            return this.on(\"physicsResolve\", action);\n        },\n\n        onBeforePhysicsResolve(this: GameObj, action) {\n            return this.on(\"beforePhysicsResolve\", action);\n        },\n\n        curPlatform(): GameObj | null {\n            return curPlatform;\n        },\n\n        isGrounded() {\n            return curPlatform !== null;\n        },\n\n        isFalling(): boolean {\n            return this.vel.dot(internal.game.gravity) > 0;\n        },\n\n        isJumping(): boolean {\n            return this.vel.dot(internal.game.gravity) < 0;\n        },\n\n        jump(force: number) {\n            curPlatform = null;\n            lastPlatformPos = null;\n            this.vel = internal.game.gravity.unit().scale(\n                -force || -this.jumpForce,\n            );\n        },\n\n        onGround(this: GameObj, action: () => void): EventController {\n            return this.on(\"ground\", action);\n        },\n\n        onFall(this: GameObj, action: () => void): EventController {\n            return this.on(\"fall\", action);\n        },\n\n        onFallOff(this: GameObj, action: () => void): EventController {\n            return this.on(\"fallOff\", action);\n        },\n\n        onHeadbutt(this: GameObj, action: () => void): EventController {\n            return this.on(\"headbutt\", action);\n        },\n    };\n}\n", "import type { BodyComp, DoubleJumpComp, GameObj } from \"@/types\";\nimport type { EventController } from \"@/utils\";\n\nexport function doubleJump(numJumps: number = 2): DoubleJumpComp {\n    let jumpsLeft = numJumps;\n    return {\n        id: \"doubleJump\",\n        require: [\"body\"],\n        numJumps: numJumps,\n        add(this: GameObj<BodyComp | DoubleJumpComp>) {\n            this.onGround(() => {\n                jumpsLeft = this.numJumps;\n            });\n        },\n        doubleJump(\n            this: GameObj<BodyComp | DoubleJumpComp>,\n            force?: number,\n        ) {\n            if (jumpsLeft <= 0) {\n                return;\n            }\n            if (jumpsLeft < this.numJumps) {\n                this.trigger(\"doubleJump\");\n            }\n            jumpsLeft--;\n            this.jump(force);\n        },\n        onDoubleJump(this: GameObj, action: () => void): EventController {\n            return this.on(\"doubleJump\", action);\n        },\n        inspect(this: GameObj<BodyComp | DoubleJumpComp>) {\n            return `${jumpsLeft}`;\n        },\n    };\n}\n", "import type { Vec2 } from \"@/math\";\nimport type { Anchor, AnchorComp } from \"@/types\";\n\nexport function anchor(o: Anchor | Vec2): AnchorComp {\n    if (!o) {\n        throw new Error(\"Please define an anchor\");\n    }\n    return {\n        id: \"anchor\",\n        anchor: o,\n        inspect() {\n            if (typeof this.anchor === \"string\") {\n                return this.anchor;\n            } else {\n                return this.anchor.toString();\n            }\n        },\n    };\n}\n", "import type { FixedComp } from \"@/types\";\n\nexport function fixed(): FixedComp {\n    return {\n        id: \"fixed\",\n        fixed: true,\n    };\n}\n", "import { Vec2, vec2 } from \"@/math\";\nimport type { FollowComp, GameObj, PosComp } from \"@/types\";\n\nexport function follow(obj: GameObj, offset?: Vec2): FollowComp {\n    return {\n        id: \"follow\",\n        require: [\"pos\"],\n        follow: {\n            obj: obj,\n            offset: offset ?? vec2(0),\n        },\n        add(this: GameObj<FollowComp | PosComp>) {\n            if (obj.exists()) {\n                this.pos = this.follow.obj.pos.add(this.follow.offset);\n            }\n        },\n        update(this: GameObj<FollowComp | PosComp>) {\n            if (obj.exists()) {\n                this.pos = this.follow.obj.pos.add(this.follow.offset);\n            }\n        },\n    };\n}\n", "import { Vec2 } from \"@/math\";\nimport type { EmptyComp, GameObj, PosComp } from \"@/types\";\n\nexport function move(dir: number | Vec2, speed: number): EmptyComp {\n    const d = typeof dir === \"number\" ? Vec2.fromAngle(dir) : dir.unit();\n    return {\n        id: \"move\",\n        require: [\"pos\"],\n        update(this: GameObj<PosComp>) {\n            this.move(d.scale(speed));\n        },\n    };\n}\n", "import { DEF_OFFSCREEN_DIS } from \"@/constants\";\nimport { getKaboomContext } from \"@/kaboom\";\nimport { Rect, vec2 } from \"@/math\";\nimport type {\n    GameObj,\n    OffScreenComp,\n    OffScreenCompOpt,\n    PosComp,\n} from \"@/types\";\nimport type { EventController } from \"@/utils\";\n\nexport function offscreen(opt: OffScreenCompOpt = {}): OffScreenComp {\n    const k = getKaboomContext(this);\n    const distance = opt.distance ?? DEF_OFFSCREEN_DIS;\n    let isOut = false;\n\n    return {\n        id: \"offscreen\",\n        require: [\"pos\"],\n        isOffScreen(this: GameObj<PosComp>): boolean {\n            const pos = this.screenPos();\n            const screenRect = new Rect(vec2(0), k.width(), k.height());\n            return !k.testRectPoint(screenRect, pos)\n                && screenRect.sdistToPoint(pos) > distance * distance;\n        },\n        onExitScreen(this: GameObj, action: () => void): EventController {\n            return this.on(\"exitView\", action);\n        },\n        onEnterScreen(this: GameObj, action: () => void): EventController {\n            return this.on(\"enterView\", action);\n        },\n        update(this: GameObj) {\n            if (this.isOffScreen()) {\n                if (!isOut) {\n                    this.trigger(\"exitView\");\n                    isOut = true;\n                }\n                if (opt.hide) this.hidden = true;\n                if (opt.pause) this.paused = true;\n                if (opt.destroy) this.destroy();\n            } else {\n                if (isOut) {\n                    this.trigger(\"enterView\");\n                    isOut = false;\n                }\n                if (opt.hide) this.hidden = false;\n                if (opt.pause) this.paused = false;\n            }\n        },\n    };\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { Vec2, vec2 } from \"@/math\";\nimport type { FixedComp, GameObj, PosComp, Vec2Args } from \"@/types\";\n\nfunction isFixed(obj: GameObj) {\n    if (obj.fixed) return true;\n    return obj.parent ? isFixed(obj.parent) : false;\n}\n\nexport function pos(...args: Vec2Args): PosComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    return {\n        id: \"pos\",\n        pos: vec2(...args),\n\n        moveBy(...args: Vec2Args) {\n            this.pos = this.pos.add(vec2(...args));\n        },\n\n        // move with velocity (pixels per second)\n        move(...args: Vec2Args) {\n            this.moveBy(vec2(...args).scale(k.dt()));\n        },\n\n        // move to a destination, with optional speed\n        moveTo(...args) {\n            if (\n                typeof args[0] === \"number\" && typeof args[1] === \"number\"\n            ) {\n                return this.moveTo(vec2(args[0], args[1]), args[2]);\n            }\n            const dest = args[0];\n            const speed = args[1];\n            if (speed === undefined) {\n                this.pos = vec2(dest);\n                return;\n            }\n            const diff = dest.sub(this.pos);\n            if (diff.len() <= speed * k.dt()) {\n                this.pos = vec2(dest);\n                return;\n            }\n            this.move(diff.unit().scale(speed));\n        },\n\n        worldPos(this: GameObj<PosComp>): Vec2 {\n            return this.parent\n                ? this.parent.transform.multVec2(this.pos)\n                : this.pos;\n        },\n\n        // get the screen position (transformed by camera)\n        screenPos(this: GameObj<PosComp | FixedComp>): Vec2 {\n            const pos = this.worldPos();\n            return isFixed(this)\n                ? pos\n                : k.toScreen(pos);\n        },\n\n        inspect() {\n            return `(${Math.round(this.pos.x)}, ${Math.round(this.pos.y)})`;\n        },\n\n        drawInspect() {\n            k.drawCircle({\n                color: k.rgb(255, 0, 0),\n                radius: 4 / internal.getViewportScale(),\n            });\n        },\n    };\n}\n", "import type { RotateComp } from \"@/types\";\n\nexport function rotate(r: number): RotateComp {\n    return {\n        id: \"rotate\",\n        angle: r ?? 0,\n        rotateBy(angle: number) {\n            this.angle += angle;\n        },\n        rotateTo(angle: number) {\n            this.angle = angle;\n        },\n        inspect() {\n            return `${Math.round(this.angle)}`;\n        },\n    };\n}\n", "import { getInternalContext, getKaboomContext } from \"@/kaboom\";\nimport { vec2 } from \"@/math\";\nimport type { ScaleComp, Vec2Args } from \"@/types\";\n\n// TODO: allow single number assignment\nexport function scale(...args: Vec2Args): ScaleComp {\n    const k = getKaboomContext(this);\n    const internal = getInternalContext(k);\n\n    if (args.length === 0) {\n        return scale(1);\n    }\n    return {\n        id: \"scale\",\n        scale: vec2(...args),\n        scaleTo(...args: Vec2Args) {\n            this.scale = vec2(...args);\n        },\n        scaleBy(...args: Vec2Args) {\n            this.scale.scale(vec2(...args));\n        },\n        inspect() {\n            return `(${internal.toFixed(this.scale.x, 2)}, ${\n                internal.toFixed(this.scale.y, 2)\n            })`;\n        },\n    };\n}\n", "import type { ZComp } from \"@/types\";\n\nexport function z(z: number): ZComp {\n    return {\n        id: \"z\",\n        z: z,\n        inspect() {\n            return `${this.z}`;\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["kaboom_exports", "__export", "anchorPt", "kaboom_default", "getInternalContext", "getKaboomContext", "isKaboomCtx", "deg2rad", "deg", "__name", "rad2deg", "rad", "clamp", "val", "min", "max", "lerp", "a", "b", "t", "Vec2", "Color", "map", "v", "l1", "h1", "l2", "h2", "mapc", "_Vec2", "x", "y", "angle", "args", "p2", "vec2", "s", "len", "normal", "on", "dest", "cos", "sin", "n", "m", "other", "Rect", "_Color", "r", "g", "arr", "hex", "result", "h", "l", "hue2rgb", "p", "q", "d", "rgb", "hsl2rgb", "Quad", "_Quad", "w", "quad", "Mat2", "_Mat2", "c", "point", "det", "e1", "e2", "radians", "Mat3", "_Mat3", "__name", "m11", "m12", "m13", "m21", "m22", "m23", "m31", "m32", "m33", "m", "Mat2", "other", "radians", "c", "s", "oldA", "oldB", "x", "y", "det", "Mat4", "_Mat4", "p", "a", "deg2rad", "m0", "m1", "m4", "m5", "out", "i", "j", "Vec2", "r", "rad2deg", "f00", "f01", "f02", "f03", "f04", "f05", "f06", "f07", "f08", "f09", "f10", "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "wave", "lo", "hi", "t", "f", "A", "C", "M", "RNG", "seed", "b", "Color", "args", "vec2", "rgb", "defRNG", "randSeed", "rand", "randi", "chance", "shuffle", "list", "chooseMultiple", "count", "choose", "testRectRect", "r1", "r2", "__name", "testLineLineT", "l1", "l2", "denom", "ua", "ub", "testLineLine", "t", "vec2", "testRectLine", "r", "l", "dir", "tmin", "tmax", "tx1", "tx2", "ty1", "ty2", "testRectPoint", "r", "pt", "__name", "testRectCircle", "c", "nx", "ny", "vec2", "testRectPolygon", "p", "testPolygonPolygon", "Polygon", "testLinePoint", "l", "v1", "v2", "t", "testLineCircle", "circle", "v", "a", "centerToOrigin", "b", "dis", "t1", "t2", "testCirclePoint", "testLinePolygon", "testPolygonPoint", "i", "p1", "p2", "testLineLine", "Line", "testCircleCircle", "c1", "c2", "testCirclePolygon", "prev", "cur", "poly", "j", "testEllipsePoint", "ellipse", "angle", "deg2rad", "s", "vx", "vy", "testEllipseCircle", "center", "cx", "cy", "Ellipse", "testEllipseLine", "line", "T", "Circle", "testEllipseEllipse", "ellipse1", "ellipse2", "A1", "Mat3", "A2", "x1", "y1", "x2", "y2", "theta1", "theta2", "M1", "M2", "M1inv", "M2inv", "A", "B", "a11", "a12", "a13", "a21", "a22", "a23", "a31", "a32", "a33", "b11", "b12", "b13", "b21", "b22", "b23", "b31", "b32", "b33", "factor", "condition1", "condition2", "condition3", "testEllipseRect", "rect", "testEllipsePolygon", "testLineShape", "line", "shape", "Vec2", "testLinePoint", "Circle", "testLineCircle", "Line", "testLineLine", "Rect", "testRectLine", "Polygon", "testLinePolygon", "Ellipse", "testEllipseLine", "__name", "testCircleShape", "circle", "testCirclePoint", "testCircleCircle", "testRectCircle", "testCirclePolygon", "testEllipseCircle", "testRectShape", "rect", "testRectPoint", "testRectRect", "testRectPolygon", "testEllipseRect", "testPolygonShape", "polygon", "testPolygonPoint", "testPolygonPolygon", "testEllipsePolygon", "testEllipseShape", "ellipse", "testEllipsePoint", "testEllipseEllipse", "raycastLine", "origin", "direction", "line", "a", "c", "d", "ab", "cd", "abxcd", "ac", "s", "t", "normal", "__name", "raycastRect", "rect", "tmin", "tmax", "tx1", "tx2", "vec2", "ty1", "ty2", "raycastCircle", "circle", "A", "centerToOrigin", "B", "C", "disc", "point", "t1", "t2", "raycastPolygon", "polygon", "points", "minHit", "prev", "i", "cur", "hit", "Line", "raycastEllipse", "ellipse", "T", "TI", "Torigin", "Tdirection", "result", "Circle", "R", "Mat2", "deg2rad", "p", "fraction", "raycastGrid", "gridPosHit", "maxDistance", "pos", "len", "dir", "gridPos", "step", "tDelta", "dist", "tMax", "steppedIndex", "_Line", "p1", "p2", "m", "Rect", "shape", "testLineShape", "_Rect", "width", "height", "Vec2", "Polygon", "pt", "min", "max", "dx", "dy", "testRectShape", "_Circle", "center", "radius", "tr", "Ellipse", "testCircleShape", "_Ellipse", "rx", "ry", "degrees", "inv", "M", "e1", "e2", "v1", "v2", "b", "rad2deg", "angle", "scale", "Mat3", "ux", "uy", "vx", "vy", "halfwidth", "halfheight", "testEllipseShape", "_Polygon", "pts", "total", "l", "testPolygonShape", "evaluateBezier", "pt1", "pt2", "pt3", "pt4", "t3", "mt", "mt2", "mt3", "sat", "overlap", "displacement", "poly", "axisProj", "min1", "max1", "j", "q", "min2", "max2", "o", "o1", "o2", "isOrientedCcw", "isOrientedCcwPolygon", "onSameSide", "px", "py", "pointInTriangle", "someInTriangle", "vertices", "isEar", "triangulate", "nextIdx", "prevIdx", "idx", "lm", "concaveVertices", "triangles", "nVertices", "current", "skipped", "next", "isConvex", "k", "winding", "Registry", "__name", "v", "id", "EventController", "_EventController", "cancel", "events", "ev", "e", "p", "Event", "action", "args", "res", "EventHandler", "name", "deepEq", "o1", "o2", "t1", "t2", "k1", "k2", "k", "v1", "v2", "base64ToArrayBuffer", "base64", "binstr", "len", "bytes", "i", "dataURLToArrayBuffer", "url", "download", "filename", "a", "downloadText", "text", "downloadJSON", "data", "downloadBlob", "blob", "isDataURL", "str", "getFileName", "__name", "p", "overload2", "fn1", "fn2", "args", "al", "uid", "id", "getErrorMessage", "__name", "error", "BinaryHeap", "__name", "compareFn", "a", "b", "item", "lastItem", "pos", "parent", "child", "index1", "index2", "GRAPHEMES", "runes", "string", "result", "i", "increment", "nextUnits", "isGrapheme", "isVariationSelector", "isDiacriticalMark", "isZeroWidthJoiner", "__name", "current", "isFirstOfSurrogatePair", "currentPair", "nextPair", "isRegionalIndicator", "isSubdivisionFlag", "isSupplementarySpecialpurposePlane", "isFitzpatrickModifier", "betweenInclusive", "codePointFromSurrogatePair", "codePoint", "GRAPHEMES", "pair", "highOffset", "lowOffset", "value", "lower", "upper", "gamepad_default", "ButtonState", "__name", "btn", "GamepadState", "FPSCounter", "dt", "a", "b", "app_default", "opt", "state", "Vec2", "EventHandler", "isHidden", "time", "fps", "numFrames", "screenshot", "setCursor", "c", "getCursor", "setCursorLocked", "res", "e", "isCursorLocked", "enterFullscreen", "el", "exitFullscreen", "getFullscreenElement", "setFullscreen", "f", "isFullscreen", "quit", "name", "canvasEvents", "docEvents", "winEvents", "resizeObserver", "run", "action", "accumulatedDt", "frame", "t", "loopTime", "realDt", "desiredDt", "processInput", "resetInput", "isTouchscreen", "mousePos", "mouseDeltaPos", "isMousePressed", "m", "isMouseDown", "isMouseReleased", "isMouseMoved", "isKeyPressed", "k", "isKeyPressedRepeat", "isKeyDown", "isKeyReleased", "isGamepadButtonPressed", "isGamepadButtonDown", "isGamepadButtonReleased", "onResize", "onKeyDown", "overload2", "key", "onKeyPress", "onKeyPressRepeat", "onKeyRelease", "onMouseDown", "mouse", "onMousePress", "onMouseRelease", "onMouseMove", "onCharInput", "onTouchStart", "onTouchMove", "onTouchEnd", "onScroll", "onHide", "onShow", "onGamepadButtonDown", "onGamepadButtonPress", "onGamepadButtonRelease", "onGamepadStick", "stick", "v", "onGamepadConnect", "onGamepadDisconnect", "getGamepadStick", "charInputted", "getGamepads", "processGamepad", "s", "registerGamepad", "browserGamepad", "gamepad", "removeGamepad", "g", "map", "gamepad_default", "gamepadState", "i", "stickName", "value", "pd", "cw", "ch", "ww", "wh", "rw", "rc", "ratio", "offset", "MOUSE_BUTTONS", "PREVENT_DEFAULT_KEYS", "KEY_ALIAS", "touches", "box", "lastMousePos", "kbGamepad", "entries", "entry", "Texture", "_Texture", "__name", "ctx", "w", "h", "opt", "gl", "filter", "wrap", "img", "tex", "x", "y", "FrameBuffer", "data", "bytesPerRow", "temp", "topOffset", "bottomOffset", "canvas", "action", "Shader", "vert", "frag", "attribs", "vertShader", "fragShader", "prog", "attrib", "i", "vertError", "fragError", "uniform", "name", "val", "loc", "Mat4", "Color", "Vec2", "first", "v", "BatchRenderer", "format", "maxVertices", "maxIndices", "sum", "primitive", "verts", "indices", "shader", "deepEq", "indexOffset", "genStack", "setFunc", "stack", "push", "__name", "item", "pop", "cur", "initGfx", "gl", "opts", "gc", "onDestroy", "action", "destroy", "curVertexFormat", "setVertexFormat", "fmt", "deepEq", "stride", "sum", "f", "offset", "i", "pushTexture2D", "popTexture2D", "t", "pushArrayBuffer", "popArrayBuffer", "b", "pushElementArrayBuffer", "popElementArrayBuffer", "pushFramebuffer", "popFramebuffer", "pushRenderbuffer", "popRenderbuffer", "pushViewport", "popViewport", "x", "y", "w", "h", "pushProgram", "popProgram", "p", "Asset", "_Asset", "__name", "Event", "loader", "data", "err", "asset", "action", "AssetBucket", "name", "id", "handle", "loaded", "fetchURL", "url", "res", "fetchJSON", "path", "fetchText", "fetchArrayBuffer", "loadImg", "src", "img", "resolve", "reject", "ASCII_CHARS", "DEF_ANCHOR", "DEF_FONT", "DBG_FONT", "DEF_FONT_FILTER", "VERTEX_FORMAT", "STRIDE", "sum", "f", "MAX_BATCHED_QUAD", "MAX_BATCHED_VERTS", "MAX_BATCHED_INDICES", "VERT_TEMPLATE", "FRAG_TEMPLATE", "DEF_VERT", "DEF_FRAG", "COMP_DESC", "COMP_EVENTS", "TEXT_STYLE_RE", "DEF_OFFSCREEN_DIS", "DEF_JUMP_FORCE", "MAX_VEL", "c2", "c3", "c4", "c5", "easings", "x", "easings_default", "TexPacker", "__name", "gfx", "w", "h", "Texture", "img", "tex", "Quad", "curTex", "pos", "Vec2", "getRenderProps", "obj", "__name", "circle", "radius", "opt", "k", "getKaboomContext", "Rect", "Vec2", "drawon", "c", "__name", "fadeIn", "time", "k", "getKaboomContext", "finalOpacity", "t", "done", "__name", "mask", "m", "__name", "opacity", "a", "k", "getKaboomContext", "internal", "getInternalContext", "time", "easeFunc", "__name", "outline", "width", "color", "rgb", "__name", "polygon", "pts", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "Polygon", "p", "__name", "raycast", "origin", "direction", "exclude", "k", "getKaboomContext", "minHit", "s", "tag", "hit", "__name", "rect", "w", "h", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "Rect", "vec2", "__name", "shader", "id", "uniform", "__name", "sprite", "src", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "spriteData", "curAnim", "curAnimDir", "spriteLoadedEvent", "Event", "calcTexScale", "__name", "tex", "q", "w", "h", "scale", "vec2", "Quad", "left", "right", "top", "bottom", "tw", "th", "iw", "ih", "w1", "w3", "w2", "h1", "h3", "h2", "quads", "quad", "i", "uv", "transform", "setSpriteData", "spr", "anim", "name", "prevAnim", "action", "text", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "update", "obj", "ftext", "__name", "nt", "Rect", "vec2", "uvquad", "w", "h", "k", "getKaboomContext", "internal", "getInternalContext", "Rect", "vec2", "__name", "agent", "opts", "target", "path", "index", "navMapChangedEvent", "p", "cb", "__name", "types_default", "tile", "opts", "tilePos", "vec2", "isObstacle", "cost", "edges", "getEdgeMask", "__name", "loopup", "s", "mask", "dir", "edgeMask", "p", "level", "is", "n", "e", "health", "hp", "maxHP", "origHP", "action", "__name", "lifespan", "time", "opt", "k", "getKaboomContext", "fade", "easings_default", "__name", "state", "initState", "stateList", "transitions", "events", "initStateEvents", "Event", "__name", "on", "event", "action", "trigger", "args", "didFirstEnter", "oldState", "available", "s", "from", "to", "stay", "scenesToStay", "__name", "timer", "time", "action", "k", "getKaboomContext", "actions", "t", "ev", "f", "p", "curTimer", "newAction", "__name", "from", "to", "duration", "setValue", "easeFunc", "easings_default", "curTime", "onEndEvents", "lerp", "area", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "app", "colliding", "collidingThisFrame", "obj", "col", "id", "a", "opts", "rgb", "vec2", "mpos", "other", "f", "btn", "e", "action", "hovering", "onHover", "tag", "cb", "pt", "testPolygonPoint", "localArea", "transform", "offset", "anchorPt", "DEF_ANCHOR", "__name", "body", "opt", "k", "getKaboomContext", "internal", "getInternalContext", "curPlatform", "lastPlatformPos", "willFall", "vec2", "DEF_JUMP_FORCE", "other", "col", "rcol", "tmass", "col2", "addGravity", "prevVel", "maxVel", "MAX_VEL", "action", "force", "__name", "doubleJump", "numJumps", "jumpsLeft", "force", "action", "__name", "anchor", "o", "__name", "fixed", "__name", "follow", "obj", "offset", "vec2", "__name", "move", "dir", "speed", "d", "Vec2", "__name", "offscreen", "opt", "k", "getKaboomContext", "distance", "DEF_OFFSCREEN_DIS", "isOut", "pos", "screenRect", "Rect", "vec2", "action", "__name", "isFixed", "obj", "__name", "pos", "args", "k", "getKaboomContext", "internal", "getInternalContext", "vec2", "dest", "speed", "diff", "rotate", "r", "angle", "__name", "scale", "args", "k", "getKaboomContext", "internal", "getInternalContext", "vec2", "__name", "z", "__name", "VERSION", "anchorPt", "orig", "Vec2", "__name", "alignPt", "align", "createEmptyAudioBuffer", "ctx", "isKaboomCtx", "obj", "getKaboomContext", "fallBack", "getInternalContext", "kaboom", "kaboom_default", "gopt", "root", "canvas", "gscale", "fixedSize", "styles", "cw", "ch", "pixelDensity", "fontCacheCanvas", "fontCacheC2d", "app", "app_default", "gc", "gl", "ggl", "initGfx", "gfx", "defShader", "makeShader", "DEF_VERT", "DEF_FRAG", "emptyTex", "Texture", "frameBuffer", "FrameBuffer", "bgColor", "bgAlpha", "rgb", "renderer", "BatchRenderer", "VERTEX_FORMAT", "MAX_BATCHED_VERTS", "MAX_BATCHED_INDICES", "bgTex", "Mat4", "SpriteData", "Quad", "tex", "frames", "anims", "slice9", "src", "opt", "data", "quad", "assets", "f", "slice", "url", "loadImg", "img", "SoundData", "buf", "resolve", "reject", "audio", "isDataURL", "dataURLToArrayBuffer", "fetchArrayBuffer", "masterNode", "burpSnd", "burp_default", "err", "AssetBucket", "TexPacker", "fixURL", "game", "EventHandler", "make", "vec2", "timer", "load", "prom", "loadProgress", "buckets", "n", "bucket", "loadRoot", "path", "loadJSON", "name", "fetchJSON", "FontData", "DEF_FONT_FILTER", "face", "loadFont", "font", "loadBitmapFont", "gw", "gh", "makeFont", "ASCII_CHARS", "x", "y", "dx", "dy", "w", "h", "qw", "qh", "j", "i", "loadSpriteAtlas", "res", "rej", "json", "atlas", "map", "info", "spr", "createSpriteSheet", "images", "width", "height", "c2d", "merged", "loadSprite", "s", "loadPedit", "loadAseprite", "imgSrc", "jsonSrc", "getFileName", "resolveJSON", "size", "anim", "loadShader", "vert", "frag", "loadShaderURL", "resolveUrl", "fetchText", "vcode", "fcode", "loadSound", "loadMusic", "a", "loadBean", "bean_default", "getSprite", "getSound", "getFont", "getBitmapFont", "getShader", "getAsset", "resolveSprite", "Asset", "resolveSound", "snd", "resolveShader", "shader", "resolveFont", "DEF_FONT", "bfont", "volume", "v", "playMusic", "onEndEvents", "Event", "el", "resumeAudioCtx", "debug", "play", "time", "l", "p", "val", "clamp", "d", "action", "paused", "srcNode", "gainNode", "pos", "startTime", "stopTime", "started", "getTime", "start", "t", "cloneNode", "oldNode", "newNode", "burp", "makeCanvas", "fb", "flush", "vertSrc", "fragSrc", "VERT_TEMPLATE", "FRAG_TEMPLATE", "Shader", "e", "fmt", "match", "getErrorMessage", "line", "msg", "ty", "chars", "cols", "charMap", "drawRaw", "verts", "indices", "fixed", "shaderSrc", "uniform", "transform", "vv", "pt", "screen2ndc", "frameStart", "drawUnscaled", "drawUVQuad", "usePostEffect", "frameEnd", "ow", "oh", "drawTexture", "pushMatrix", "m", "pushTranslate", "args", "pushScale", "pushRotate", "pushTransform", "popTransform", "offset", "DEF_ANCHOR", "q", "color", "opacity", "uvPadX", "uvPadY", "qx", "qy", "scale", "repX", "repY", "drawSprite", "getArcPts", "radiusX", "radiusY", "end", "deg2rad", "pts", "nverts", "step", "drawRect", "r", "drawPolygon", "drawLine", "p1", "p2", "dis", "Color", "drawLines", "minSLen", "radius", "drawCircle", "drawCurve", "curve", "segments", "drawBezier", "evaluateBezier", "drawTriangle", "drawEllipse", "polyOpt", "npts", "isConvex", "triangulate", "drawStenciled", "content", "mask", "test", "drawMasked", "drawSubtracted", "getViewportScale", "applyCharTransform", "fchar", "tr", "compileStyledText", "text", "charStyleMap", "renderText", "TEXT_STYLE_RE", "idxOffset", "origIdx", "fontAtlases", "formatText", "runes", "fontName", "opts", "lineSpacing", "letterSpacing", "curX", "tw", "th", "lines", "curLine", "cursor", "lastSpace", "lastSpaceWidth", "fchars", "ox", "idx", "style", "drawText", "drawFormattedText", "ftext", "windowToContent", "contentToView", "mousePos", "debugPaused", "updateFrame", "max", "get", "dt", "camPos", "center", "camScale", "camRot", "angle", "shake", "intensity", "toScreen", "toWorld", "calcTransform", "comps", "compStates", "cleanups", "events", "inputEvents", "onCurCompCleanup", "uid", "trigger", "o", "child", "tag", "o1", "o2", "children", "maskFunc", "comp", "k", "COMP_DESC", "prop", "COMP_EVENTS", "func", "c", "checkDeps", "dep", "id", "list", "recurse", "isChild", "onAdd", "onDestroy", "ev", "ctrl", "cb", "evs", "on", "event", "Registry", "onUpdate", "overload2", "add", "onDraw", "onCollide", "t1", "t2", "b", "col", "onCollideUpdate", "onCollideEnd", "forAllCurrentAndFuture", "onClick", "EventController", "onHover", "onHoverUpdate", "onHoverEnd", "setGravity", "g", "getGravity", "setGravityDirection", "getGravityDirection", "setBackground", "getBackground", "toFixed", "isFixed", "getRenderProps", "onLoad", "scene", "def", "go", "initEvents", "onSceneLeave", "getSceneName", "getData", "key", "setData", "plug", "plugin", "funcs", "funcsObj", "EdgeMask", "addLevel", "level", "numRows", "numColumns", "spatialMap", "costMap", "edgeMap", "connectivityMap", "tile2Hash", "tilePos", "hash2Tile", "hash", "createSpatialMap", "insertIntoSpatialMap", "removeFromSpatialMap", "index", "updateSpatialMap", "spatialMapChanged", "createCostMap", "objects", "cost", "createEdgeMap", "len", "createConnectivityMap", "traverse", "frontier", "getNeighbours", "getCost", "node", "neighbour", "getHeuristic", "goal", "diagonals", "left", "top", "right", "bottom", "levelComp", "hasPos", "hasTile", "tile", "origin", "direction", "hit", "raycastGrid", "from", "to", "BinaryHeap", "cameFrom", "costSoFar", "current", "neighbours", "next", "newCost", "row", "keys", "record", "frameRate", "stream", "audioDest", "recorder", "chunks", "filename", "blob", "downloadBlob", "isFocused", "destroy", "readd", "destroyAll", "wait", "loop", "tween", "boom", "speed", "kaSprite", "ka_default", "boomSprite", "boom_default", "addKaboom", "stay", "sprite", "anchor", "ka", "Collision", "source", "target", "resolved", "checkFrame", "grid", "cellSize", "stack", "checkObj", "aobj", "bbox", "xmin", "ymin", "xmax", "ymax", "checked", "cell", "check", "other", "sat", "col1", "col2", "drawFrame", "cam", "rand", "lerp", "drawLoadScreen", "progress", "drawInspectText", "txt", "pad", "ftxt", "DBG_FONT", "bw", "bh", "drawDebug", "inspecting", "flipped", "wave", "logs", "log", "str", "onLoading", "onResize", "onError", "handleErr", "textStyle", "title", "onCleanup", "quit", "numTextureUnits", "unit", "isFirstFrame", "updateViewport", "pd", "rc", "rg", "sw", "sh", "rotate", "area", "polygon", "rect", "circle", "uvquad", "outline", "body", "doubleJump", "health", "lifespan", "state", "z", "move", "offscreen", "follow", "fadeIn", "drawon", "raycast", "agent", "Line", "Rect", "Circle", "Ellipse", "Polygon", "RNG", "randi", "randSeed", "hsl2rgb", "choose", "chooseMultiple", "shuffle", "chance", "easings_default", "mapc", "rad2deg", "testLineLine", "testRectRect", "testRectLine", "testRectPoint", "testCirclePolygon", "testLinePoint", "testLineCircle", "download", "downloadJSON", "downloadText"]
}
